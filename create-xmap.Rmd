---
title: "Creating the ``r params$package_name`` R package"
author: "Cynthia Huang"
date: 2022-12-21
output: litr::litr_html_document
params:
  package_name: "xmap" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

```{=html}
<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->
```
## Package Setup

### DESCRIPTION file

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9007",
    Title = "xmap: A data-structure for extending crosswalks",
    Description = "Provides a 'xmap' S3 class (the 'Crossmap') based on 'tbl_df'
    class for use in {conformr} package.",
    `Authors@R` = person(
      given = "Cynthia",
      family = "Huang",
      email = "cynthiahqy@gmail.com",
      role = c("aut", "cre")
    ),
    `Config/testthat/edition` = 3
  )
)
usethis::use_mit_license(copyright_holder = "C. Huang")
```

### Dependencies

```{r}
# Imports
usethis::use_package("rlang", min_version = "1.0.0")
usethis::use_package("cli")

# Suggests
usethis::use_package("tibble", type = "Suggests")
usethis::use_package("testthat", type = "Suggests")
```

### Utilities

```{r send_to="R/utils.R"}
#' Defaults for NULL values
#'
`%||%` <- function(x, y) if (is.null(x)) y else x
```

### Package Level Documentation

``` {package-doc}
#' xmap: A data-structure for extending crosswalks
#'
#' @description
#' Provides 'xmap' S3 class (the 'Crossmap') for use in {conformr} package.
#'
#' @keywords internal
#' @import rlang
"_PACKAGE"
```

## Package Concepts

### Crossmap and Crosswalk tables

<!--# define crosswalks -->

Crosswalks are used in many different applications and domains, and generally refer to a table showing equivalent or related elements in two distinct nomenclature, schema or standards. Crosswalks are used to encode one-to-one, one-to-many, many-to-one, and many-to-many relations. Except for cases where there are only one-to-one relations, Crosswalks are "lateral" (one-way) mappings.

<!--# define crossmaps -->

Crossmaps extends the standard Crosswalk format to explictly encode the weights used when mapping data from one scheme to another. A crosswalk table generally consists of two columns, one each for the two schemes, and each row specifies a relation between elements of the disjoint schemes. A crossmap adds an additional column specifying transition weights for mapping data belonging to class elements in the source (initial) scheme into class elements in target scheme.

<!--# insert image of crosswalk & crossmap TABLES (generate ggxmap/gt?) -->

### Graph and Matrix Representations

<!--# relation to graph & incidence matrix representation -->

Crosswalked datasets are often visualised using Sankey flow diagrams. These diagrams hint at the fact that, when considered independently of the data they are applied to, crosswalks can be represented as directed acyclic bipartite graphs. Recall that for a bipartite graph, the nodes $N$ can be subdivided into two disjoint sets ($N_1, N_2$), and links are only allowed between these two sets. The class elements of the source and target classifications naturally form two disjoint sets of nodes.

<!--# INSERT image of crosswalk GRAPH (generate using ggxmap) -->

Noting that crossmaps are essentially lateral crosswalks with weights attached to each relation, we find that crossmaps can be represented as weighted acyclic bipartite digraphs. A crossmap fully captures all the information needed to "transition" or "translate" numeric and/or categorical data between the source and target classes (nodes).

<!--# INSERT image of crossmap as graph (generate using ggxmap) -->

Furthermore, the explicit weights make clear why mappings are generally "lateral". Consider the case <!--# above? --> where you have a many-to-one relation between source and target schemes.

### Application to Ex-Post Data Harmonisation

<!--# define ex-post data harmonisation -->

Crossmaps have features which are especially useful when using a Crosswalk approach to ex-post data harmonisation requiring one-to-many splits. Ex-post data harmonisation refers to the integration of data from ....

Continuing with the graph representation, we can attach arbitary numeric values (such as counts, or monetary amounts) to each source node as additional properties of each node. <!--# brings us back to sankey diagram representation -->

<!--# related but distinct requirements compared to crosswalks in metadata / data mapping -->

Although both processes use crosswalks, the requirements of an ex-post harmonisation workflow have some important differences to crosswalking between database schemas ("metadata translation using schema crosswalks [(Wikipedia)](https://en.wikipedia.org/wiki/Schema_crosswalk)")[^1], and are more specific than "data mapping" [(Wikipedia)](https://en.wikipedia.org/wiki/Data_mapping) between distinct data models. In particular, for the latter two cases, there are often more obvious constraints on candidate crosswalks (agreed upon standards etc., translation between legacy systems etc., more obvious connection between the two databases, harmonising data flows), and fewer classes (fields).

[^1]: Schema crosswalks show equivalent elements or "fields" between database schema, and are used to "translate" data from one format into another in "metadata mapping".

On the other hand, ex-post harmonisation is often a "last resort" attempt to bring together data from different sources to answer difficult questions (social sciences). The data is often scarce, expensive to collect, and as a result the semantic ties between the datasets are not so obvious, and much more subjective opinion is applied when designing crosswalks (and the implicit weights).

### Crosswalk vs. Crossmap Transformation

<!--# applying crosswalks vs. crossmaps -->

A crossmap transformation can be performed by passing a valid crossmap table and validated input data can be passed as inputs into "generic" transformation function, which implements a (left join, mutate, and aggregate), to produce the target dataset without generating any additional code. The specific conditions for source data are discussed in `{conformr}`.

<!--# insert image of transformation -- JOIN -->

On the other hand, crosswalks need to be translated into procedural code (ETL, graphical manuals, for-loops). <!--# short list of drawbacks -->. The drawbacks and limitation of these approaches are discussed in more detail in `{conformr}`.

<!--# ETL, graphical methods not so relevant (because we're not generally looking at data stored in database schema) -->

<!--# common practice is for-loops; drawbacks // maybe point people to conformr pkg -->

For-loops must be coded from either the source-code or target-code perspective (i.e. you iterate over the source classes or target classes, dealing with each set of relations one by one). The most obvious drawback to this approach is the number of lines of code grows with the number of classes in the classifications, decreasing the readability of the code.

For-loops are often used when generating data-driven weights <!--# (are they? they are natural fit for it, especially for social science data) -->. However,

<!--# benefits of crosswalks for ex-post harmonisation -->

Crossmaps provide a systematic structure for validating candidate mappings, and can enable tractable experimentation with different processes for generating mappings[^2] and conducting sensitivity analysis.

[^2]: e.g. using data-driven mapping ([Wikipedia, no reference](https://en.wikipedia.org/wiki/Data_mapping))

### Sharing Dataset Harmonisation Designs and Transformations

In addition to standard data cleaning tasks, researchers and analysts invest considerable time and effort into integrating datasets from different sources. Unfortunately, harmonisation designs are generally embedded in custom transformation scripts, or provided in non-machine readable formats like user manuals and classification standard handbooks.

The `xmap` construct, and `xmap_df`, `xmap_graph` & `xmap_matrix` formats provide a standard framework for encoding harmonisation decisions as a machine-readable input to a data transformation workflow. The format allows researchers to easily share, modify and/or reuse harmonisation designs -- saving time, improving reproducibility, and data consistency.

## Package Design Notes

### Reference Index

Draft [pkgdown function reference](https://pkgdown.r-lib.org/articles/pkgdown.html#reference) to be placed in `_pkgdown.yml`

``` yml
reference:
- title: "Overview"
  - "xmap-package"
  - "xmap_df-class"
- title: "Creation and Coercion"
  desc: >
    Functions for constructing a `xmap_df`.
  - xmap
  - as_xmap
- title: "Helpers and Validation"
  - new_xmap
  - validate_xmap
  - starts_with("has", internal = TRUE)
```

### Toy Examples

```{r ideal-xmap}
## define some test data here

input_df <- tibble::tribble(
  ~from, ~to, ~weights,
  "A1", "B01", 1,
  "A2", "B02", 1,
  "A3", "B02", 1,
  "A4", "B03", 0.25,
  "A4", "B04", 0.75
)

int_dat <- list("input_df" = input_df)

usethis::use_data(int_dat, internal = TRUE, overwrite = TRUE)
```

## `xmap_df` Class Constructor

Following the advice given in [13.3 of Advanced R](https://adv-r.hadley.nz/s3.html#s3-classes) & Tidyverse Design Guide

### `xmap_df` properties

An object of class `xmap_df`:

-   inherits from classes: `data.frame`, `xmap_df`, `xmap`
-   has additional attributes named using graph terminology:
    -   `col_from`: source nodes
    -   `col_to`: target nodes
    -   `col_weights`: link weights
    -   `from_set`: source node set

The low-level constructor takes in:

-   one data argument (`x`), accepts base objects of type data.frames (and subclasses)
-   three required descriptor arguments (`from`, `to`, `weights`) which are stored as attributes, and must be character strings only.
-   one optional descriptor arugment (`from_set`) which is stored as an attribute, and must be a character vector.

The constructor does the following:

-   checks base object and attribute types.
-   checks column type restrictions. `from` should be coercible into character (from factor, numeric etc.), and `weights` should be numeric. This is also an implicit check that the columns `from` and `weights` exist in `x`.
-   naively generates the `from_set` of unique `from` values
-   returns an S3 object with the class `xmap_df` and `xmap`

```{r xmap-constructor}
#' Low Level Constructor for xmap_df
#'
new_xmap_df <- function(x = data.frame(), from, to, weights, from_set = NULL) {
  #' checks argument types
  stopifnot(is.data.frame(x))
  stopifnot(length(from) == 1 && is.character(from))
  stopifnot(length(to) == 1 && is.character(to))
  stopifnot(length(weights) == 1 && is.character(weights))

  #' naively generates `from_set` if it is missing
  from_set <- from_set %||% as.character(unique(x[[from]]))
  stopifnot(is.vector(from_set, mode = "character"))

  #' @return `x` with additional subclasses `xmap` and `xmap_df`

  class(x) <- append(c("xmap_df", "xmap"), class(x))
  structure(x,
    col_from = from,
    col_to = to,
    col_weights = weights,
    from_set = from_set
  )
}

new_xmap <- new_xmap_df
```

Tests:

```{r test-constructor-success}
testthat::test_that(
  "new_xmap_df() accepts arbitrary data.frames with correct from argument",
  {
    df <- data.frame(
      x = letters[1:5],
      y = 1:5,
      z = runif(5)
    )
    xmap <- new_xmap_df(x = df, from = "x", to = "y", weights = "z")
    xmap_attrs <- attributes(xmap)
    testthat::expect_s3_class(xmap, "xmap_df")
    testthat::expect_s3_class(xmap, "xmap")
    testthat::expect_identical(xmap_attrs$col_from, "x")
    testthat::expect_identical(xmap_attrs$col_to, "y")
    testthat::expect_identical(xmap_attrs$col_weights, "z")
    testthat::expect_identical(xmap_attrs$from_set, unique(df$x))
  }
)
```

Snapshot tests don't work in litr

``` r
testthat::test_that(
  "new_xmap_df() rejects incorrect object types",
  {
    testthat::local_edition(3)
    testthat::expect_snapshot(error = TRUE, new_xmap_df(x = "not a data.frame"))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = 33))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = expression(5 + 9)))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = "char", weights = c("dsf", "3925")))
  }
)
```

## `xmap_df` Validation

### Validation Helpers & Error Messages

The conventions for validation helpers:

`df_check_*(df,...)` all take an data.frame for first argument, and character values or vectors for the remaining arguments. They throw an error if the validation condition does not pass, and `NULL` otherwise.

```{r send_to="R/validate-helpers.R"}
#' xmap_df validation helpers
#'
#' @description
#' Checks issues with an xmap_df object.
#'
#' @param df a data.frame-like object containing an crossmap
#' @param col_* character vector or values naming columns from `df`
#'
#' @returns An error if the validation condition fails,
#' and invisibly returns `df` otherwise.
#'
#' @name df_check
NULL
```

`has_*(x_)` functions take in vector arguments only, and are designed to be able to validate the graph features of non-data.frame xmaps (so long as the links can be decomposed into from,to,weight vectors).

#### Dimension Check

```{r send_to="R/validate-helpers.R"}
#' @describeIn df_check Abort if `df` does not have exactly three columns
#'
df_check_ncol3 <- function(df) {
  if (ncol(df) != 3) {
    rlang::abort(
      message = "`x` must only have the three columns: from, to, weights",
      class = "abort_ncol3"
    )
  }
  invisible(df)
}
```

#### Missing Columns Check

```{r send_to="R/validate-helpers.R"}
#' Abort if named columns can't be found in xmap_df
#'
#' @rdname df_check
df_check_cols <- function(df, col_attrs) {
  stopifnot(length(col_attrs) == 3)
  missing_cols <- setdiff(col_attrs, names(df))
  if (length(missing_cols) != 0) {
    cli::cli_abort(
      message = "The column{?s} {.var {missing_cols}} {?was/were} not found.",
      class = "abort_missing_cols"
    )
  }
  invisible(df)
}
```

#### Missing Value Check

```{r send_to="R/validate-helpers.R"}
#' Abort if xmap_df has missing values
#'
df_check_na <- function(df) {
  if (base::anyNA(df)) {
    cli::cli_abort(
      message = "NA values found. Please enter missing `from` or `to` node labels and/or convert NA weights",
      class = "abort_na"
    )
  }
  invisible(df)
}
```

#### Column Type Check

```{r send_to="R/validate-helpers.R"}
#' Abort if xmap_df has wrong column types
#'
df_check_col_type <- function(df, col_weights) {
  if (!is.numeric(df[[col_weights]])) {
    cli::cli_abort(
      message = "The column `{col_weights}` should be of type numeric",
      class = "abort_col_type"
    )
  }
  invisible(df)
}
```

#### From Set Check

```{r send_to="R/validate-helpers.R"}
#' Abort if from_set attribute doesn't match xmap_df values
#'
df_check_from_set <- function(df, col_from, from_set) {
  col_from_set <- as.character(unique(df[[col_from]]))
  stopifnot(identical(col_from_set, from_set))

  invisible(df)
}
```

#### No Duplicate Node Pairs (links)

```{r send_to="R/validate-helpers.R"}
#' Flag if xmap has duplicate links
#'
#' @param x_from,x_to equal length vectors containing the source-target node pairs
#' of a given xmap.
has_dup_links <- function(x_from, x_to) {
  stopifnot(is.vector(x_from))
  stopifnot(is.vector(x_to))
  stopifnot(identical(length(x_from), length(x_to)))
  links <- data.frame(x_from, x_to)
  dup_idx <- anyDuplicated(links)
  as.logical(dup_idx)
}

#' Abort if xmap_df has duplicate links
#'
df_check_links <- function(df, col_from, col_to) {
  if (has_dup_links(df[[col_from]], df[[col_to]])) {
    cli::cli_abort(
      message = "Duplicate `from`-`to` links were found.
      Please remove or collapse duplicates.",
      class = "abort_dup"
    )
  }
  invisible(df)
}
```

#### Complete Mapping Weights

```{r fnc-flag-weights, send_to="R/validate-helpers.R"}
#' Flag that df has complete weights
#'
#' @param x_from,x_weights equal length vectors containing the source node and
#' weight on the outgoing links.
has_complete_weights <- function(x_from, x_weights) {
  stopifnot(is.vector(x_from))
  stopifnot(is.vector(x_weights))
  stopifnot(identical(length(x_from), length(x_weights)))
  sum_w <- tapply(
    X = x_weights,
    INDEX = x_from,
    FUN = sum,
    simplify = TRUE
  )
  all(sum_w == 1)
}

#' Abort if df has invalid mapping weights
#'
df_check_weights <- function(df, col_from, col_weights) {
  if (!has_complete_weights(df[[col_from]], df[[col_weights]])) {
    cli::cli_abort(
      message = "Incomplete mapping weights found. Check sum of weights for each `from` group sums to 1",
      class = "abort_weights"
    )
  }
  invisible(df)
}
```

#### Tests

`df_check*` fncs are currently checked along with the Master Validator.

```{r test-has-flags}
testthat::test_that(
  "has_* validation helpers work as expected on valid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.67,
      "A4", "B04", 0.33
    )
    testthat::expect_false(has_dup_links(df$from, df$to))
    testthat::expect_true(has_complete_weights(df$from, df$weights))
  }
)

testthat::test_that(
  "has_* validation helpers catch invalid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 0.3,
      "A2", "B02", 0.5
    )
    testthat::expect_false(has_complete_weights(df$from, df$weights))
    testthat::expect_true(has_dup_links(df$from, df$to))
  }
)
```

### Master Validator

-   order checks from cheapest to most expensive
-   validates data.frame properties:
    -   contains columns named in attributes
        -   (implies df has at least `3` columns) -- ncol3 check removed as discussed in [conformr-project #57](https://github.com/cynthiahqy/conformr-project/issues/57#issuecomment-1401239494)
    -   has no missing values in ANY column
    -   from_set attributes matches
    -   weights column is `numeric`
-   checks graph properties:
    -   A: duplicate source-target rows (weights should be collapsed into a single row)
    -   B: no missing weights (checked above with missing values)
    -   C: `sum()` of values in weights column by source-code is `1` (or subject to floating point tolerance)
        -   C will also fail if B fails, but not if A fails.

```{r xmap-validator}
#' Validator for xmap_df objects
#'
#' @rdname validate_xmap
validate_xmap_df <- function(x) {
  stopifnot(inherits(x, "xmap_df"))

  df <- data.frame(x) # unclass(x)
  x_attrs <- attributes(x)
  col_attrs <- simplify2array(x_attrs[startsWith(names(x_attrs), "col")])

  ## ---- df attributes ----
  df_check_cols(df, col_attrs)
  df_check_na(df)
  df_check_col_type(df, x_attrs$col_weights)
  df_check_from_set(df, x_attrs$col_from, x_attrs$from_set)


  ## ---- xmap graph properties ----
  df_check_links(df, x_attrs$col_from, x_attrs$col_to)
  df_check_weights(df, x_attrs$col_from, x_attrs$col_weights)

  ## return original object
  invisible(x)
}

#' Validator for `xmap` objects
#'
#' @param x An `xmap` to be validated
#'
#' @return `x` if validation passes. Throws error otherwise.
#' @export
#' @name validate_xmap
#'
validate_xmap <- validate_xmap_df
```

#### Tests

```{r test-validator-success}
testthat::test_that(
  "validate_xmap_df() accepts well-formed xmaps",
  {
    df <- tibble::tribble(
      ~node_A, ~node_B, ~w_AB,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    x <- new_xmap(df, from = "node_A", to = "node_B", weights = "w_AB")
    out <- testthat::expect_invisible(validate_xmap_df(x))
    testthat::expect_identical(out, x)
  }
)
```

```{r test-validator-malformed}
## columns present
testthat::test_that(
  "validate_xmap_df() rejects missing columns",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1
    )
    x <- new_xmap_df(df, "from", "missing_col", "weights")
    testthat::expect_error(df_check_cols(df, c("from", "missing_col", "weights")),
      class = "abort_missing_cols"
    )
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_missing_cols"
    )
  }
)

## any NA values
testthat::test_that(
  "validate_xmap_df() rejects missing values",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B2", NA,
      NA, "B2", NA,
      "A3", "B1", 1
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_na")
  }
)


## column type
testthat::test_that(
  "validate_xmap_df() rejects non-numeric weight columns",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    ) |>
      dplyr::mutate(weights = as.character(weights))
    testthat::expect_error(df_check_col_type(df, "weights"),
      class = "abort_col_type"
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_col_type"
    )
  }
)

## from set check
testthat::test_that(
  "validate_xmap_df() rejects mismatching from_set",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    bad_set <- c("bad set", "of", "nodes")
    testthat::expect_error(df_check_from_set(df, "from", bad_set))
    x <- new_xmap_df(df, "from", "to", "weights", from_set = bad_set)
    testthat::expect_error(validate_xmap_df(x))
  }
)

## duplicate links
testthat::test_that(
  "validate_xmap_df() rejects duplicate from-to links",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B02", 0.3,
      "A1", "B02", 1
    )
    testthat::expect_error(df_check_links(df, "from", "to"))
    x <- new_xmap_df(df, from = "from", to = "to", weights = "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_dup")
  }
)

## complete weights
testthat::test_that(
  "validate_xmap_df() rejects invalid weights",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 0.4,
      "A1", "B02", 0.59
    )
    testthat::expect_error(df_check_weights(df, "from", "weights"),
      class = "abort_weights"
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_weights")
  }
)
```

### Helpers

#### User Friendly Constructor

-   checks for:
    -   [x] existence of columns via `validate_xmap_df()`
-   warns for:
    -   [x] dropping extra columns (anything other than `from`, `to`, `weights`) as controlled by `.drop` argument
-   throws errors for:
    -   [x] any validation failures via `validate_xmap_df()`

```{r}
#' Coerce a data.frame-like object to `xmap`
#'
#' This creates a valid crossmap which can be used to map numeric values `from` a set of source nodes `to` a set of target nodes.
#'
#' @param x
#'  * For `as_xmap()`: A data.frame or data.frame-like object
#'  * For `is_xmap()`: An object to test.
#' @param from,to Columns in `x` specifying the source and target nodes
#' @param weights Column in `x` specifying the weight applied to data passed along the directed link between source and target node
#' @param .drop Logical indicating whether or not to drop additional columns in `x`. Defaults to FALSE.
#'
#' @return A crossmap `xmap_df` S3 object.
#' @export
#'
#' @examples
#' # For a well formed crossmap:
#' links <- data.frame(
#'   a = "AUS",
#'   b = c("VIC", "NSW", "WA", "OTHER"),
#'   w = c(0.1, 0.15, 0.25, 0.5)
#' )
#' as_xmap(links, from = a, to = b, weights = w)
#'
#' # extra columns are dropped,
#' links$extra <- c(2, 4, 5, 6)
#' as_xmap(links, from = a, to = b, weights = w)
#'
as_xmap <- function(x, from, to, weights, .drop = FALSE) {
  ## coercion & checks
  stopifnot(is.data.frame(x))

  # get string names for columns
  col_from <- deparse(substitute(from))
  col_to <- deparse(substitute(to))
  col_weights <- deparse(substitute(weights))
  col_strings <- c(col_from, col_to, col_weights)

  if (.drop) {
    df_check_cols(df, col_strings)
    df <- x[col_strings]
    if (ncol(df) < ncol(x)) {
    cli::cli_warn("Dropped additional columns in `x`")
  }
  }

  ## construction
  xmap <- new_xmap(df, from = col_from, to = col_to, weights = col_weights)

  ## validation
  validate_xmap(xmap)

  return(xmap)
}
```

#### Class Test

```{r}
#' Test if object is a crossmap
#'
#' This function returns `TRUE` for crossmaps `xmap` or subclasses thereof (`xmap_df`), and `FALSE` for all other objects, including regular data.frames or tibbles.
#' @export
#' @rdname as_xmap
is_xmap <- function(x) {
  inherits(x, "xmap")
}
```

## Enhancements (Planned)

### Class: Grouped Crossmap

A grouped variant of `xmap` is needed to facilitate multi-map workflows. However, it is not obvious how such a class should be implemented. Any implemented experiments should go here, otherwise discussion lives in this [GitHub Issue](https://github.com/cynthiahqy/conformr-project/issues/53).

### S3 Methods

See discussion [here](https://github.com/cynthiahqy/conformr-project/issues/43#issuecomment-1396445724)

#### print.xmap()

#### plot.xmap()

### Package Creation

We finish by running commands that will document, build, and install the package. It may also be a good idea to check the package from within this file.

```{r}
rm(list = ls())
litr::document() # <-- use instead of devtools::document()
devtools::run_examples()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```

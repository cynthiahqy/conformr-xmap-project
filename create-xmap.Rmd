---
title: "Creating the ``r params$package_name`` R package"
author: "Cynthia Huang"
date: 2022-12-21
output: 
  litr::litr_html_document:
    toc: true
params:
  package_name: "xmap" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

```{=html}
<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->
```
## Package Setup

### DESCRIPTION file

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9017",
    Title = "xmap: A data-structure for extending crosswalks",
    Description = "Provides 'xmap' S3 classes (the 'Crossmap') for use in {conformr} package.",
    `Authors@R` = person(
      given = "Cynthia",
      family = "Huang",
      email = "cynthiahqy@gmail.com",
      role = c("aut", "cre")
    ),
    `Config/testthat/edition` = 3
  )
)
usethis::use_mit_license(copyright_holder = "C. Huang")
```

### Dependencies

```{r}
# Imports
usethis::use_package("rlang", min_version = "1.0.0")
usethis::use_package("cli")

# Suggests
usethis::use_package("tibble", type = "Suggests")
usethis::use_package("testthat", type = "Suggests")
```

### Utilities

```{r}
## retain for interactive
library(rlang)
```

```{r send_to="R/utils.R"}
#' Defaults for NULL values
#' @name op-null-default
`%||%` <- function(x, y) if (is.null(x)) y else x
```

### Package Level Documentation

``` {package-doc}
#' xmap: A data-structure for extending crosswalks
#'
#' @description
#' Provides 'xmap' S3 class (the 'Crossmap') for use in {conformr} package.
#'
#' @keywords internal
#' @import rlang
"_PACKAGE"
```

## Package Design Notes

### Naming conventions

For `xmap` functions:

-   functions specific to subclass end with the `_<subclass>` suffix, and/or named as S3 dispatch method (i.e. `<generic>.<subclass>`). For example `validate_xmap_df()` and `xmap_validate.xmap_df()`

-   "internal" construction and validation functions take string arguments for column selection

-   user helpers take expression arguments (NSE) for column selection

-   functions should probably never end in `_xmap()` because it's not clear which subclass they act on.

For functions accepting `xmap` as inputs:

-   any function that accepts any subclass of `xmap` should be named using the `xmap_` prefix convention -- e.g. `xmap_validate()`

-   generics that will form part of a user workflow should follow the `xmap_` prefix convention (e.g. `xmap_validate()`). This makes reduces ambiguity when using these functions in a conformr workflow.

For functions return `xmap` subclasses as output:

-   any function that returns a specific subclass of `xmap` should end with the suffice `_<subclass>`. For example `as_xmap_df()` and `new_xmap_df()`

### Reference Index

Draft [pkgdown function reference](https://pkgdown.r-lib.org/articles/pkgdown.html#reference) to be placed in `_pkgdown.yml`

``` yml
reference:
- title: "Overview"
  - "xmap-package"
  - "xmap_df-class"
- title: "Creation and Coercion"
  desc: >
    Functions for constructing a `xmap_df`.
  - xmap
  - as_xmap_df
- title: "Helpers and Validation"
  - new_xmap
  - validate_xmap
  - starts_with("has", internal = TRUE)
```

### Toy Examples

```{r ideal-xmap}
## define some test data here

input_df <- tibble::tribble(
  ~from, ~to, ~weights,
  "A1", "B01", 1,
  "A2", "B02", 1,
  "A3", "B02", 1,
  "A4", "B03", 0.25,
  "A4", "B04", 0.75
)

int_dat <- list("input_df" = input_df)

usethis::use_data(int_dat, internal = TRUE, overwrite = TRUE)

```

```{r simple-xmap}
simple_xmap <- tibble::tribble(~f, ~t, ~w,
                                "x1111", "A1", 1,
                                "x2222", "B2", 0.5,
                                "x2222", "B3", 0.5,
                                "x3333", "C5", 1,
                                "x4444", "C5", 1,
                                "x5555", "D6", 0.4,
                                "x5555", "D7", 0.6,
                                "x6666", "D6", 0.3,
                                "x6666", "D7", 0.7,
                                "x7777", "D6", 1
)
```

## Class Structure

The package uses the class `xmap` as the superclass for all representations of a crossmaps, and subclasses: `xmap_df`

### `xmap` parent class properties

`xmap` is a virtual parent class indicating the object is a "crossmap", and satisfies the mathematical properties of a "crossmap" shared by all representations.

Let `g` be an object of class `xmap`. Then `g`:

-   has only one weighted link between each source-target pair of form:
-   `{source: "A1", target: "B01", weight: 1}`
-   for every source node, the weights on all (outgoing) links sum to 1 (subject to some floating point tolerance?)

### `xmap_df` subclass properties

`xmap_df` is a concrete subclass for encoding crossmaps as lists of graph edges with attributes indicating the node sets and direction of the map.

Let `X` be an **validated** object of class `xmap_df`. Then:

-   `X` inherits from the class `xmap_df`
-   `X` is a data.frame-like object and:
    -   contains the columns named in the `col_from`, `col_to`, `col_weights` attributes
    -   has no missing values - the character vector of all unique values in the `col_from` variable exactly match the `from_set` attribute - the `col_weights` column is a numeric vector - `X` inherits from the class `xmap`
    -   (each row represents a single weighted link)

## Construction

The naming convention for constructors is: `new_<subclass>()`. For example: `new_xmap_df()`

### Helper for subclass attributes

Eventually support matrix, graph, and data.frame?

```{r send_to="R/new_xmap.R"}
#'
.get_xmap_subclass_attr <- function(subclass = c("xmap_df")){
  subclass <- rlang::arg_match(subclass)

  class_attr <- switch(subclass,
         xmap_df = c("xmap_df", "xmap", "data.frame"),
         stop("Unknown xmap subclass"))
  
  return(class_attr)
}
```

```{r}
testthat::test_that(".get_xmap_subclass_attr() rejects unknown subclass",
                    {
                      testthat::expect_error(.get_xmap_subclass_attr("unknown"))
                    })
```

### `xmap_df` Constructor Method

The low-level constructor takes in:

-   one data argument (`x`), accepts base objects of type data.frames (and subclasses)
-   three required descriptor arguments (`from`, `to`, `weights`) which are stored as attributes, and must be character strings only.
-   one optional descriptor argument (`from_set`) which is stored as an attribute, and must be a character vector.

The constructor does the following:

-   checks base object and attribute types.
-   checks the descriptor argument types.
-   if `from_set` is not provided, naively generates the `from_set` of unique `from` values
-   appends the class attributes: `xmap_df` and `xmap`

It assumed, but not checked that:

-   (`x` contains the column named in `from`, `to`, `weights` arguments?)
-   (the `from_set` vector attributes contains all unique values of `from` column in `x`)
-   (the `weights` column contains numeric weights)

The constructor returns an object of class `xmap_df` which:

-   inherits from classes: `data.frame`, `xmap_df`, `xmap`
-   has additional attributes named using graph terminology:
    -   `col_from`: source nodes
    -   `col_to`: target nodes
    -   `col_weights`: link weights
    -   `from_set`: source node set

```{r xmap-constructor, send_to="R/new_xmap.R"}
#' Low Level Constructors for xmap subclasses
#' @param x data-frame like object.
#' @param col_from,col_to,col_weights character strings naming columns containing source nodes, target nodes and numeric weights.
#' @return xmap_df object. Note that this function unclasses tibbles.
#' @name new_xmap
NULL

#' @describeIn new_xmap Construct xmap_df from data.frame
new_xmap_df <- function(x, col_from, col_to, col_weights, from_set = NULL) {
  #' checks argument types
  stopifnot(is.data.frame(x))
  stopifnot(length(col_from) == 1 && is.character(col_from))
  stopifnot(length(col_to) == 1 && is.character(col_to))
  stopifnot(length(col_weights) == 1 && is.character(col_weights))

  #' naively generates `from_set` if it is missing
  from_set <- from_set %||% as.character(unique(x[[col_from]]))
  stopifnot(is.vector(from_set, mode = "character"))

  #' @return `x` with additional subclasses `xmap_df` and `xmap`

  class(x) <- .get_xmap_subclass_attr("xmap_df")
  structure(x,
    col_from = col_from,
    col_to = col_to,
    col_weights = col_weights,
    from_set = from_set
  )
}
```

Tests:

```{r test-constructor-success}
testthat::test_that(
  "new_xmap_df() accepts arbitrary data.frames with correct from argument",
  {
    df <- data.frame(
      x = letters[1:5],
      y = 1:5,
      z = runif(5)
    )
    xmap <- new_xmap_df(x = df, "x", "y", "z")
    xmap_attrs <- attributes(xmap)
    testthat::expect_s3_class(xmap, .get_xmap_subclass_attr("xmap_df"))
    testthat::expect_identical(xmap_attrs$col_from, "x")
    testthat::expect_identical(xmap_attrs$col_to, "y")
    testthat::expect_identical(xmap_attrs$col_weights, "z")
    testthat::expect_identical(xmap_attrs$from_set, unique(df$x))
  }
)
```

Snapshot tests don't work in litr

``` r
testthat::test_that(
  "new_xmap_df() rejects incorrect object types",
  {
    testthat::local_edition(3)
    testthat::expect_snapshot(error = TRUE, new_xmap_df(x = "not a data.frame"))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = 33))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = expression(5 + 9)))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = "char", weights = c("dsf", "3925")))
  }
)
```

### Class Tests

```{r send_to="R/is_xmap.R"}
#' Test if object is a crossmap
#'
#' This function returns `TRUE` for crossmaps `xmap` or subclasses thereof (`xmap_df`), and `FALSE` for all other objects, including regular data.frames or tibbles.
#' @export
#' @rdname as_xmap
is_xmap <- function(x) {
  base::inherits(x, "xmap")
}

#' Test if object is `xmap_df`
#' @export
#' @rdname as_xmap
is_xmap_df <- function(x) {
  rlang::inherits_all(x, c("xmap_df", "xmap"))
}
```

## Validation

### Diagnostic Helpers (`validate-helpers.R`)

The conventions for validation helpers:

`df_check_*(df,...)` all take an data.frame for first argument, and character values or vectors for the remaining arguments. They throw an error if the validation condition does not pass, and `NULL` otherwise.

```{r send_to="R/df_check.R"}
#' xmap_df validation helpers
#'
#' @description
#' Checks issues with an xmap_df object.
#'
#' @param df a data.frame-like object containing an crossmap
#' @param col_* character vector or values naming columns from `df`
#'
#' @returns An error if the validation condition fails,
#' and invisibly returns `df` otherwise.
#'
#' @name df_check
NULL
```

`has_*(x_)` functions take in vector arguments only, and are designed to be able to validate the graph features of non-data.frame xmaps (so long as the links can be decomposed into from,to,weight vectors).

#### Missing Columns Check

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if named columns can't be found in xmap_df
#'
df_check_cols <- function(df, col_attrs) {
  stopifnot(length(col_attrs) == 3)
  missing_cols <- setdiff(col_attrs, names(df))
  if (length(missing_cols) != 0) {
    cli::cli_abort(
      message = "The column{?s} {.var {missing_cols}} {?was/were} not found.",
      class = "abort_missing_cols"
    )
  }
  invisible(df)
}
```

#### Missing Value Check

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if xmap_df has missing values
#'
df_check_na <- function(df) {
  if (base::anyNA(df)) {
    cli::cli_abort(
      message = "NA values found. Please enter missing `from` or `to` node labels and/or convert NA weights",
      class = "abort_na"
    )
  }
  invisible(df)
}
```

#### Column Order Check

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if xmap_df columns are not in order
df_check_col_order <- function(df, col_from, col_to, col_weights){
  correct_order <- c(col_from, col_to, col_weights)
  first_three <- names(df[1:3])
  if(!identical(first_three, correct_order)){
    rlang::abort(
      message = "columns are not sorted in order `from`, `to`, `weights`",
      class = "abort_col_order"
    )
  }
  invisible(df)
}
```

```{r}
testthat::test_that("df_check_col_order() works as expected",
                    {
                      df <- data.frame(a = 1, b = 2, c = 3)
                      testthat::expect_invisible(df_check_col_order(df, "a", "b", "c"))
                      testthat::expect_identical(df_check_col_order(df, "a", "b", "c"), df)
                      testthat::expect_error(df_check_col_order(df, "b", "a", "c"),
                                             class = "abort_col_order")
                    })
```

#### Column Type Check

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if xmap_df has wrong column types
#'
df_check_col_type <- function(df, col_weights) {
  if (!is.numeric(df[[col_weights]])) {
    cli::cli_abort(
      message = "The column `{col_weights}` should be of type numeric",
      class = "abort_col_type"
    )
  }
  invisible(df)
}
```

#### From Set Check

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if from_set attribute doesn't match xmap_df values
#'
df_check_from_set <- function(df, col_from, from_set) {
  col_from_set <- as.character(unique(df[[col_from]]))
  stopifnot(identical(col_from_set, from_set))

  invisible(df)
}
```

#### No Duplicate Node Pairs (links)

```{r send_to="R/xmap-has.R"}
#' Boolean flags for xmap properties
#'
#' @description
#' `has_*()` and `is_*()` functions check properties used to validate and/or print xmaps.
#' The functions only accepts equal length vector inputs to support all subclasses of `xmap`,
#' but does not check if the inputs are from the same xmap.
#' @param x_from,x_to,x_weights equal length vectors containing the source-target node pairs
#' @name xmap-has
NULL

#' @describeIn xmap-has Returns TRUE if xmap has duplicate links
#'
has_dup_links <- function(x_from, x_to) {
  stopifnot(is.vector(x_from))
  stopifnot(is.vector(x_to))
  stopifnot(identical(length(x_from), length(x_to)))
  links <- data.frame(x_from, x_to)
  dup_idx <- anyDuplicated(links)
  as.logical(dup_idx)
}
```

```{r send_to="R/df_check.R"}
#' @describeIn df_check Abort if xmap_df has duplicate links
#'
df_check_links <- function(df, col_from, col_to) {
  if (has_dup_links(df[[col_from]], df[[col_to]])) {
    cli::cli_abort(
      message = "Duplicate `from`-`to` links were found.
      Please remove or collapse duplicates.",
      class = "abort_dup"
    )
  }
  invisible(df)
}
```

#### Complete Mapping Weights

```{r send_to="R/xmap-has.R"}
#' @describeIn xmap-has Returns TRUE if xmap has valid weights
has_complete_weights <- function(x_from, x_weights) {
  stopifnot(is.vector(x_from))
  stopifnot(is.vector(x_weights))
  stopifnot(identical(length(x_from), length(x_weights)))
  sum_w <- tapply(
    X = x_weights,
    INDEX = x_from,
    FUN = sum,
    simplify = TRUE
  ) |> as.vector()
  names(sum_w) <- NULL
  ones <- rep(1, length(sum_w))
  all(isTRUE(all.equal(sum_w, ones)))
}
```

```{r fnc-check-weights, send_to="R/df_check.R"}
#' @describeIn df_check Abort if df has invalid mapping weights
#'
df_check_weights <- function(df, col_from, col_weights) {
  if (!has_complete_weights(df[[col_from]], df[[col_weights]])) {
    cli::cli_abort(
      message = "Incomplete mapping weights found. Check sum of weights for each `from` group sums to 1",
      class = "abort_weights"
    )
  }
  invisible(df)
}
```

#### Tests

`df_check*` fncs are currently checked along with the Master Validator.

```{r test-has-flags}
testthat::test_that(
  "has_* validation helpers work as expected on valid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.67,
      "A4", "B04", 0.33
    )
    testthat::expect_false(has_dup_links(df$from, df$to))
    testthat::expect_true(has_complete_weights(df$from, df$weights))
  }
)

testthat::test_that(
  "has_* validation helpers catch invalid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 0.3,
      "A2", "B02", 0.5
    )
    testthat::expect_false(has_complete_weights(df$from, df$weights))
    testthat::expect_true(has_dup_links(df$from, df$to))
  }
)

testthat::test_that(
  "has_complete_weights() works on recurring fractional weights",
  {
    df <- data.frame(key1 = rep("A1", 3),
                     key2 = c("B01", "B02", "B03"),
                     share = rep(1/3, 3))

    testthat::expect_true(has_complete_weights(df$key1, df$share))
  }
)
```

### Internal: `validate_xmap_df()`

-   order checks from cheapest to most expensive
-   validates data.frame properties:
    -   contains columns named in attributes
        -   (implies df has at least `3` columns) -- ncol3 check removed as discussed in [conformr-project #57](https://github.com/cynthiahqy/conformr-project/issues/57#issuecomment-1401239494)
    -   has no missing values in ANY column
    -   from_set attributes matches
    -   weights column is `numeric`
-   checks graph properties:
    -   A: duplicate source-target rows (weights should be collapsed into a single row)
    -   B: no missing weights (checked above with missing values)
    -   C: `sum()` of values in weights column by source-code is `1` (or subject to floating point tolerance)
        -   C will also fail if B fails, but not if A fails.

```{r send_to="R/get-helpers.R"}
#'
.get_col_attrs.xmap_df <- function(x){
  stopifnot(is_xmap_df(x))
  x_attrs <- attributes(x)
  col_attrs <- x_attrs[startsWith(names(x_attrs), "col")]
  return(col_attrs)
}
```

```{r xmap-validator}
#' Validator for `xmap_df` objects
#'
validate_xmap_df <- function(x) {
  stopifnot(is_xmap_df(x))

  df <- data.frame(x) # unclass(x)
  x_attrs <- attributes(x)
  col_strings <- simplify2array(.get_col_attrs.xmap_df(x))

  ## ---- df attributes ----
  df_check_cols(df, col_strings)
  df_check_col_order(df, x_attrs$col_from, x_attrs$col_to, x_attrs$col_weights)
  df_check_na(df)
  df_check_col_type(df, x_attrs$col_weights)
  df_check_from_set(df, x_attrs$col_from, x_attrs$from_set)


  ## ---- xmap graph properties ----
  df_check_links(df, x_attrs$col_from, x_attrs$col_to)
  df_check_weights(df, x_attrs$col_from, x_attrs$col_weights)

  ## return original object
  invisible(x)
}
```

#### Tests

```{r test-validator-success}
testthat::test_that(
  "validate_xmap_df() accepts well-formed xmaps",
  {
    df <- tibble::tribble(
      ~node_A, ~node_B, ~w_AB,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    x <- new_xmap_df(df, "node_A", "node_B", "w_AB")
    out <- testthat::expect_invisible(validate_xmap_df(x))
    testthat::expect_identical(out, x)
  }
)
```

```{r test-validator-malformed}
## columns present
testthat::test_that(
  "validate_xmap_df() rejects missing columns",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1
    )
    x <- new_xmap_df(df, "from", "missing_col", "weights")
    testthat::expect_error(df_check_cols(df, c("from", "missing_col", "weights")),
      class = "abort_missing_cols"
    )
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_missing_cols"
    )
  }
)

## any NA values
testthat::test_that(
  "validate_xmap_df() rejects missing values",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B2", NA,
      NA, "B2", NA,
      "A3", "B1", 1
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_na")
  }
)


## column type
testthat::test_that(
  "validate_xmap_df() rejects non-numeric weight columns",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    ) |>
      dplyr::mutate(weights = as.character(weights))
    testthat::expect_error(df_check_col_type(df, "weights"),
      class = "abort_col_type"
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_col_type"
    )
  }
)

## from set check
testthat::test_that(
  "validate_xmap_df() rejects mismatching from_set",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    bad_set <- c("bad set", "of", "nodes")
    testthat::expect_error(df_check_from_set(df, "from", bad_set))
    x <- new_xmap_df(df, "from", "to", "weights", from_set = bad_set)
    testthat::expect_error(validate_xmap_df(x))
  }
)

## duplicate links
testthat::test_that(
  "validate_xmap_df() rejects duplicate from-to links",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B02", 0.3,
      "A1", "B02", 1
    )
    testthat::expect_error(df_check_links(df, "from", "to"))
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_dup")
  }
)

## complete weights
testthat::test_that(
  "validate_xmap_df() rejects invalid weights",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 0.4,
      "A1", "B02", 0.59
    )
    testthat::expect_error(df_check_weights(df, "from", "weights"),
      class = "abort_weights"
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_weights")
  }
)
```

## Coercion

### Generic: `as_xmap()`

```{r send_to="R/as_xmap.R"}
#' Coerce objects to xmap
#' 
#' Validates and creates a valid crossmap `xmap` object of the same type as the input.
#' 
#' @param x
#'  * For `as_xmap()`: An object to coerce
#'  * For `is_xmap()`: An object to test.
#' @param from,to Columns in `x` specifying the source and target nodes
#' @param weights Column in `x` specifying the weight applied to data passed along the directed link between source and target node
#' @param subclass Which xmap subclass to return. Defaults to `xmap_df` for `data.frame` and `tibble`
#' @param .drop_extra Drop columns other than `from`, `to` and `weights`. Defaults to `TRUE`
#' 
#' @return A validated `xmap` object.
#' 
#' @export
as_xmap_df <- function(x, from, to, weights, subclass = c("xmap_df"), ...) {
  UseMethod("as_xmap_df")
}
```

### `as_xmap_df.data.frame()`

-   checks for:
    -   [x] existence of columns via `validate_xmap_df()`
-   warns for:
    -   [x] dropping extra columns (anything other than `from`, `to`, `weights`) as controlled by `.drop` argument
-   throws errors for:
    -   [x] any validation failures via `validate_xmap_df()`

```{r send_to="R/as_xmap.R"}
#' @describeIn as_xmap Coerce a `data.frame` to `xmap`
#'
#' @export
#' @examples
#' # For a well formed crossmap:
#' links <- data.frame(
#'   a = "AUS",
#'   b = c("VIC", "NSW", "WA", "OTHER"),
#'   w = c(0.1, 0.15, 0.25, 0.5)
#' )
#' as_xmap_df(links, from = a, to = b, weights = w)
#'
#' # extra columns are dropped,
#' links$extra <- c(2, 4, 5, 6)
#' as_xmap_df(links, from = a, to = b, weights = w)
as_xmap_df.data.frame <- function(x, from, to, weights, subclass = "xmap_df", .drop_extra = TRUE) {
  ## coercion & checks
  stopifnot(is.data.frame(x))

  # get string names for columns
  col_from <- deparse(substitute(from))
  col_to <- deparse(substitute(to))
  col_weights <- deparse(substitute(weights))
  col_strings <- c(col_from, col_to, col_weights)
  ## check columns exist
  df_check_cols(x, col_strings)

  ## drop additional columns
  if (.drop_extra) {
    df <- x[col_strings]
  } else {
    df <- x
  }
  if (ncol(df) < ncol(x)) {
    cli::cli_inform("Dropped additional columns in {.arg {deparse(substitute(x))}}")
  }

  ## rearrange columns
  col_order <- c(col_strings, setdiff(names(df), col_strings))
  df <- df[col_order]

  ## construction
  xmap <- switch(subclass,
                 xmap_df = new_xmap_df(df, col_from, col_to, col_weights),
                 stop("Unknown xmap subclass"))

  ## validation
  validate_xmap_df(xmap)

  return(xmap)
}
```

```{r}
testthat::test_that(
  "as_xmap() is returns expected xmap subclasses",
  {
     tbl_links <- tibble::tribble(
      ~f, ~t, ~w,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.67,
      "A4", "B04", 0.33
      )
     df_links <- as.data.frame(tbl_links)
     
     ## default subclasses work as expected
     testthat::expect_s3_class(as_xmap_df(df_links, f, t, w),
                               .get_xmap_subclass_attr("xmap_df"))
     
     ## override subclass works as well
     testthat::expect_s3_class(as_xmap_df(tbl_links, f, t, w, subclass = "xmap_df"),
                               .get_xmap_subclass_attr("xmap_df"))
  }
)
```

### Helper: `xmap_drop_extra()`

```{r}
#' Drop extra columns from `xmap` objects
#'
#' @export
xmap_drop_extra <- function(x){
  UseMethod("xmap_drop_extra")
}

#' @export
xmap_drop_extra.xmap_df <- function(x){
  stopifnot(is_xmap_df(x))
  
  col_strings <- simplify2array(.get_col_attrs.xmap_df(x))
  
  z_attrs <- attributes(x)
  z_attrs$names <- unname(col_strings)
  
  z <- as.data.frame(x)
  z <- z[,col_strings]
  attributes(z) <- z_attrs
  
  return(z)
}
```

```{r test-drop-extra, render='as-is'}
testthat::test_that('xmap_drop_extra works as expected', {
  links <- tibble::tribble(
  ~f, ~t, ~w,
  "A1", "B01", 1,
  "A2", "B02", 1,
  "A3", "B02", 1,
  "A4", "B03", 0.25,
  "A4", "B04", 0.75
  ) 
  xmap_small <- as_xmap_df(links, f, t, w)

  links_extra <- links |> 
    dplyr::mutate(ex = "extra")
  xmap_extra <- as_xmap_df(links_extra, f, t, w, .drop_extra = FALSE)
  xmap_drop_df <- xmap_extra |> xmap_drop_extra.xmap_df()
  xmap_drop <- xmap_extra |> xmap_drop_extra()
  
  testthat::expect_identical(xmap_small, xmap_drop_df)
  testthat::expect_identical(xmap_small, xmap_drop)
})
```

## Description Tools

See [conformr-project #63](https://github.com/cynthiahqy/conformr-project/issues/63)

### Helper: xmap link classification

-   used for print methods, reverse

```{r print-helpers, send_to="R/xmap-has.R"}
#' @describeIn xmap-has Return TRUE if xmap recodes labels between `from` and `to`
has_1to1 <- function(x_weights) {
  stopifnot(is.vector(x_weights))
  any(x_weights == 1)
}
#'
has_recode <- has_1to1

#' @describeIn xmap-has Return TRUE if xmap has splitting links between `from` and `to`
has_1toM <- function(x_weights) {
  stopifnot(is.vector(x_weights))
  any(x_weights < 1)
}
#'
has_split <- has_1toM

#' @describeIn xmap-has Return TRUE if xmap has collapsing links between `from` and `to`
has_1fromM <- function(x_to){
  stopifnot(is.vector(x_to))
  as.logical(anyDuplicated(x_to))
}
#'
has_collapse <- has_1fromM
```

```{r}
testthat::test_that(
  "has_* split, recode, collapse checkers work as expected",
  {
    w_1to1 <- rep(1, 10)
    w_1toM <- rep(1/6, 6)
    to_1fromM <- rep("country", 4)
    testthat::expect_true(has_recode(w_1to1))
    testthat::expect_false(has_recode(w_1toM))
    testthat::expect_true(has_split(w_1toM))
    testthat::expect_false(has_split(w_1to1))
    testthat::expect_true(has_collapse(to_1fromM))
  }
)
```

### Helper: xmap is reversible

```{r}
#' @describeIn df_check Abort if xmap_df has wrong column types
#'
df_check_reversible <- function(df, col_to) {
  x_to <- df[[col_to]]
  if (has_collapse(x_to)){
    cli::cli_abort("Collapse links in {.var xmap_df} cannot be reversed. Please supply new weights and create a new xmap.")
  }
  invisible(df)
}
  
```

## Modification

See [conformr-project #67](https://github.com/cynthiahqy/conformr-project/issues/67)

### Generic: `xmap_reverse()`

```{r xmap-reverse, send_to="R/xmap_reverse.R"}
#' Reverse xmap direction
#'
#' @param x xmap object to be reversed
#' @param weights_into A string specifying the name of a new or existing column to store reverse weights in. 
#'
#' @return xmap object of same class as `x`, or throws an error if `x` is not reversible
#' @export
#'
#' @examples
xmap_reverse <- function(x, weights_into){
  UseMethod("xmap_reverse")
}

#' @describeIn xmap_reverse Reverse a `xmap_df`
#' 
#' @export
xmap_reverse.xmap_df <- function(x, weights_into = "r_weights"){
  stopifnot(inherits(x, "xmap_df"))
  x_attrs <- attributes(x)
  df <- as.data.frame(x)
  
  ## check xmap can be reversed
  df_check_reversible(df, x_attrs$col_to)

  ## make new xmap
  df[[weights_into]] <- 1
  new_from <- x_attrs$col_to
  new_to <- x_attrs$col_from
  new_weights <- weights_into
  new_cols <- c(new_from, new_to, new_weights)
  ## rearrange columns
  #col_order <- c(new_cols, setdiff(names(df), new_cols))
  df <- df[new_cols]
  
  ## construction
  xmap <- new_xmap_df(df, new_from, new_to, new_weights)
  
  ## validation
  validate_xmap_df(xmap)
  
  return(xmap)
}
```

```{r}
testthat::test_that("xmap_reverse.xmap_df() works as expected",             {
  df_x <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    ) |> as.data.frame() |> 
    new_xmap_df("from", "to", "weights")
  
  df_x_rev <- data.frame(
    to = df_x$to,
    from = df_x$from,
    r_weights = 1
  ) |>
    new_xmap_df("to", "from", "r_weights")
  
  # class checks
  testthat::expect_s3_class(xmap_reverse.xmap_df(df_x), class(df_x_rev))
  testthat::expect_s3_class(xmap_reverse(df_x), class(df_x_rev))
  
  # output checks
  testthat::expect_identical(xmap_reverse.xmap_df(df_x), df_x_rev)
  testthat::expect_identical(df_check_reversible(df_x,"to"), df_x)
}
)
```

## Visualisation

Adding in more dependencies

```{r vis-depend}
usethis::use_package("dplyr", type = "suggests")
usethis::use_package("tibble", type = "suggests")
usethis::use_package("ggplot2", type = "suggests")
usethis::use_package("ggbump", type = "suggests")
```

### Planned Generic: `xmap_viz_*()`

This section is left in for future reference, when I get around to properly developing visualisation functions for crossmaps.

#### `xmap_viz_bigraph()`

Doc-string for future reference

``` r
#' Visualise `xmap` as bigraph
#' 
#' Plot crossmap as bigraph using sigmoid curves from ggbump.
#'
#' @param x object to plot
#' @param ... reserved for future plot customisation options
#'
#' @return ggplot2 object
#' @export
#'
#' @examples
#' library(ggplot2)
#' library(dplyr)
#' simple_xmap <- tibble::tribble(~f, ~t, ~w,
#'                              "x1111", "A1", 1,
#'                              "x2222", "B2", 0.5,
#'                              "x2222", "B3", 0.5,
#'                              "x3333", "C5", 1,
#'                              "x4444", "C5", 1,
#'                              "x5555", "D6", 0.4,
#'                              "x5555", "D7", 0.6,
#'                              "x6666", "D6", 0.3,
#'                              "x6666", "D7", 0.7,
#'                              "x7777", "D6", 1)  |> 
#'                 as_xmap_df(from = f, to = t, weights = w)
#' xmap_viz_bigraph(simple_xmap)
xmap_viz_bigraph <- function(x, ...){
  UseMethod("xmap_viz_bigraph")
}

#' @describeIn xmap_viz_bigraph Plot `xmap_df` as sigmoid bigraph
#' @export
#'
#' xmap_viz_bigraph.xmap_df <- function(x, ...) {
```

#### `xmap_viz_matrix()`

```{r xmap-viz-matrix}

```

### Example Plots

See `vis-xmaps.Rmd` vignette

## S3 Enhancements

See discussion [here](https://github.com/cynthiahqy/conformr-project/issues/43#issuecomment-1396445724)

### Printing

[conformr-project #60](https://github.com/cynthiahqy/conformr-project/issues/60)

#### Method: `xmap_df`

```{r print-xmap-df, send_to="R/print.R", results='asis', paged.print=FALSE}
#'
.get_link_types.xmap_df <- function(xmap_df){
  x_attrs <- attributes(xmap_df)
  x_weights <- xmap_df[[x_attrs$col_weights]]
  x_to <- xmap_df[[x_attrs$col_to]]
  
  flags <- c(
      "recode" = has_recode(x_weights),
      "split" = has_split(x_weights),
      "collapse" = has_collapse(x_to)
    )
  types <- names(flags[flags == TRUE])
  type <- cli::pluralize("{types} {? }")

  return(type)
}

#'
.get_link_direction.xmap_df <- function(xmap_df){
  x_attrs <- attributes(xmap_df)
  direction <- paste0("(", x_attrs$col_from, " -> ", x_attrs$col_to, ") ", 
                      "BY " ,x_attrs$col_weights)
  return(direction)
}

#' Print an `xmap` object
#' 
#' @name print.xmap
NULL

#' @describeIn print.xmap Print an `xmap_df`
#'
#' @export
print.xmap_df <- function(x){
  x_direction <- .get_link_direction.xmap_df(x)
  x_type <- .get_link_types.xmap_df(x)
  x_links <- as.data.frame(x)

  ## print headers and links
  cat(paste0("xmap_df:\n",  x_type, "\n", x_direction, "\n"))
  print(x_links)
}
```

Test Prints:

```{r paged.print=FALSE}
valid_xmap_df <-
  tibble::tribble(
    ~new_sec, ~sector, ~weight,
    "mining", "MINE", 1,
    "agri", "AGRI", 1,
    "agri", "FISH", 1,
    "text", "MANU", 0.25,
    "food", "MANU", 0.25,
    "chem", "MANU", 0.25,
    "elec", "MANU", 0.25,
    "build", "CONS", 1 / 3,
    "roads", "CONS", 1 / 3,
    "civil", "CONS", 1 / 3,
  ) |>
  dplyr::mutate(extra_col = "stuff") |>
  as_xmap_df(from = sector, to = new_sec, weight)

print(valid_xmap_df)
```

### Read / Write Methods

Discussed here: [conformr-project #62](https://github.com/cynthiahqy/conformr-project/issues/62)

### Plot Method

Suggested in [confomr-project #43](https://github.com/cynthiahqy/conformr-project/issues/43#issuecomment-1396445724)

## Package Creation

### Add Vignettes

First add bibliography file

```{r}
add_vignette_bib <- function(bib_files){
  fs::dir_create("vignettes")
  for (fn in bib_files) fs::file_copy(fn, "vignettes")
}

add_vignette_bib("../xmap-source-files/using-xmaps.bib")
```

```{r}
litr::add_readme("../xmap-source-files/README.Rmd")
litr::add_vignettes("../xmap-source-files/xmap.Rmd")
litr::add_vignettes("../xmap-source-files/making-xmaps.Rmd")
litr::add_vignettes("../xmap-source-files/using-xmaps.Rmd")
litr::add_vignettes("../xmap-source-files/vis-xmaps.Rmd")
```

### Render package

To debug without having to re-render the litr file every time use the `pkg = "."` argument in devtools functions:

``` r
devtools::run_examples('xmap')
devtools::test('xmap')
devtools::build('xmap')
devtools::install('xmap')
devtools::check('xmap', document = FALSE)
```

We finish by running commands that will document, build, and install the package. It may also be a good idea to check the package from within this file.

```{r}
rm(list = ls())
litr::document() # <-- use instead of devtools::document()
litr::add_pkgdown()
# devtools::run_examples()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```

---
title: "Creating the ``r params$package_name`` R package"
author: "Cynthia Huang"
date: 2022-12-21
output: 
  litr::litr_html_document:
    toc: true
params:
  package_name: "xmap" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

```{=html}
<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->
```
## Package Setup

### DESCRIPTION file

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9019",
    Title = "xmap: A data-structure for extending crosswalks",
    Description = "Provides 'xmap' S3 classes (the 'Crossmap') for use in {conformr} package.",
    `Authors@R` = person(
      given = "Cynthia",
      family = "Huang",
      email = "cynthiahqy@gmail.com",
      role = c("aut", "cre")
    ),
    `Config/testthat/edition` = 3
  )
)
usethis::use_mit_license(copyright_holder = "C. Huang")
```

### Dependencies

```{r}
# Imports for Validation
usethis::use_package("R", min_version = "4.1")
usethis::use_package("rlang", min_version = "1.0.0")
usethis::use_package("cli")

# Imports for Construction and verification helpers
usethis::use_package("tibble")
usethis::use_package("tidyr")
usethis::use_package("dplyr")

# Suggests for Vignettes and Tests
usethis::use_package("Matrix", type = "Suggests") ## for sparse matrices
usethis::use_package("matlib", type = "Suggests")
usethis::use_package("testthat", type = "Suggests")
```

### Utilities

```{r}
## retain for interactive
library(rlang)
```

```{r send_to="R/utils.R"}
#' Defaults for NULL values
#' @name op-null-default
#' @keywords internal
`%||%` <- function(x, y) if (is.null(x)) y else x
```

### Package Level Documentation

``` {package-doc}
#' xmap: A data-structure for extending crosswalks
#'
#' @description
#' Provides 'xmap' S3 class (the 'Crossmap') for use in {conformr} package.
#'
#' @keywords internal
#' @import rlang
"_PACKAGE"
```

## Package Design Notes

### Function Types and Naming conventions

This should correspond to `@keywords` and `send_to=` arguments.

#### Internal Helpers

Errors and Messages:

-   `abort_*`: should raise a `cli::cli_abort()` message

Properties:

-   `.get_<attrs>`: should always retrieve attributes (usually of `xmap_df`)
-   `.calc_<property>`: calculates something based on object and/or its attributes (usually of `xmap_df`)
-   `vhas_`: takes in vectors, returns boolean

Construction:

-   `*_xmap_df()`: class construction functions
-   `new_xmap_df()`
-   `validate_xmap_df()` -- internal, quick!
-   `as_xmap_df()`

#### Data

-   `mock_` are input objects:
    -   `mock_named`
    -   `mock_pairs`
    -   `mock_links`
    -   `mock_xmaps`

#### Non-`xmap_df` inputs

Candidate Links:

-   `as_pairs()` to generate crosswalks

    -   `as_pairs_from_list()`
    -   `as_pairs_from_named_vector()`

-   `add_weights_*` to attach weights and return links

-   `as_links()`: could be a generic that calls different (internal?) methods and adds/extracts weights like:

    -   `as_links_from_matrix()`
    -   `as_links_from_igraph()`

-   `verify_links_as_xmap()`, takes tidyselect?

Coerce:

-   `as_xmap()` wraps construction functions, takes tidyselect
-   `is_xmap()`

#### `xmap_df` inputs

Describe:

-   `xmap_has`
    -   single input variants of `vhas` fncs
-   `verify_xmap_as_*` special types of xmaps;

Modify:

-   `xmap_<verb>` returns an `xmap_df`

Convert:

-   `xmap_to`: returns non-`xmap` outputs

#### ARCHIVED: `xmap` subclasses

-   functions specific to subclass end with the `_<subclass>` suffix, and/or named as S3 dispatch method (i.e. `<generic>.<subclass>`). For example `validate_xmap_df()` and `xmap_validate.xmap_df()`

-   "internal" construction and validation functions take string arguments for column selection

-   user helpers take expression arguments (NSE) for column selection

-   functions should probably never end in `_xmap()` because it's not clear which subclass they act on.

For functions accepting `xmap` as inputs:

-   any function that accepts any subclass of `xmap` should be named using the `xmap_` prefix convention -- e.g. `xmap_validate()`

-   generics that will form part of a user workflow should follow the `xmap_` prefix convention (e.g. `xmap_validate()`). This makes reduces ambiguity when using these functions in a conformr workflow.

For functions return `xmap` subclasses as output:

-   any function that returns a specific subclass of `xmap` should end with the suffice `_<subclass>`. For example `as_xmap_df()` and `new_xmap_df()`

### Reference Index

Draft [pkgdown function reference](https://pkgdown.r-lib.org/articles/pkgdown.html#reference) to be placed in `_pkgdown.yml`

``` yml
reference:
- title: "Overview"
  - "xmap-package"
  - "xmap_df-class"
- title: "Creation and Coercion"
  desc: >
    Functions for constructing a `xmap_df`.
  - xmap
  - as_xmap_df
- title: "Helpers and Validation"
  - new_xmap
  - validate_xmap
  - starts_with("has", internal = TRUE)
```

### Toy Examples

```{r ideal-xmap}
## define some test data here

input_df <- tibble::tribble(
  ~from, ~to, ~weights,
  "A1", "B01", 1,
  "A2", "B02", 1,
  "A3", "B02", 1,
  "A4", "B03", 0.25,
  "A4", "B04", 0.75
)

int_dat <- list("input_df" = input_df)

usethis::use_data(int_dat, internal = TRUE, overwrite = TRUE)

```

```{r simple-xmap}
simple_xmap <- tibble::tribble(~f, ~t, ~w,
                                "x1111", "A1", 1,
                                "x2222", "B2", 0.5,
                                "x2222", "B3", 0.5,
                                "x3333", "C5", 1,
                                "x4444", "C5", 1,
                                "x5555", "D6", 0.4,
                                "x5555", "D7", 0.6,
                                "x6666", "D6", 0.3,
                                "x6666", "D7", 0.7,
                                "x7777", "D6", 1
)
```

### API Design & Functionality

[Issue #67 Comment](https://github.com/cynthiahqy/conformr-project/issues/67#issuecomment-1436365643):

I'm not sure offering helpers for modifying crossmaps is necessary or even desirable.

-   Lists of maps make more sense from a "using xmaps" perspective,
-   Combining multiple crossmaps into a single table add a flexible quality to xmaps that goes against the purpose of the structure as a data-provenance object.
-   Users can still manipulate and store multiple sets of weights or other xmap variants in a "parent table", from which they create multiple xmap.
-   Manipulation of xmaps creates risk around invalidating the map -- i.e. modifying values in the weights column is technically possible for an xmap (since it is just a data.frame column), but not desirable since the map is not revalidated after the manipulation -- i.e. `xmap |> dplyr::mutate()` should probably return a tibble rather than an xmap.

[Issue #93: 14 Apr 2023](https://github.com/cynthiahqy/conformr-project/issues/93#issuecomment-1508073958)

-   Rather than classes, I think it makes the most sense to have a single xmap class (i.e. xmap_df), and everything else be "candidate links" -- which can be input into the as_xmap() generic.
-   Candidate links can also be validated as crossmaps, without coercion, allowing users to validate transformation objects in existing workflows. Coercion into xmap classes should be reserved for facilitating "advanced" or "extension" tasks --- i.e. visualisation, perturbation, multi-map transformations.
-   Some xmap class variants could include:
    -   "long" or "short" formats for ggplot;
    -   recode/collapse variants which drop the weights columns (since it is implied);
    -   igraph objects for spatial aggregation/transformation -- noting the similarity between spatial weighting matrices and crossmaps (see this Vignette from [SpatialReg](https://r-spatial.github.io/spatialreg/articles/nb_igraph.html).

## Mock Data

```{r export-mock-objects}
mock <- list()

mock$recode_vect <- c(AUS = "Australia",
                 NZD = "New Zealand",
                 JPN = "Japan")
mock$collapse_list <- list(MAMM = c("elephant", "whale", "monkey"),
                      REPT = c("lizard", "turtle"),
                      CRUS = c("crab"))

#mock$xmap_iso2_iso3 <-  
#mock$xmap_mixed <-

usethis::use_data(mock)
```

```{r document-mock-objects, send_to="R/data.R"}
#' Mock objects for the `xmap` package
#' 
#' A list of mock objects for experimenting with functions
#' in the `xmap` package.
#' 
#' @format ## `mock`
#' A list with :
#' \describe{
#'  \item{recode_vect, collapse_list}{Named vector and list for conversion into node pairs}
#'  \item{xmap}
#'  }
#' @source Package authors
```

## Candidate Links

### Convert: List to Links Data Frame

One-to-one and many-to-one mappings could easily be encoded as list objects, where each element of the list is a member of the target set, and contains a vector of all the source nodes that link to it. For instance:

```{r}
link_list <- list(AA = c("x3", "x4", "x6"),
                  BB = c("x1", "x5"),
                  CC = c("x2")
                  )
```

Convert to tibble:

```{r}
col_from = "source"
col_to = "target"
col_weights = "weights"

link_list |> 
  tibble::enframe(name = col_to, value = col_from) |>
  tidyr::unnest_longer(col=c(col_from)) |>
  dplyr::mutate("{col_weights}" := 1)
```

Convert to dataframe: -- how to unnest???

```{r}
# convert list to data.frame
links <- as.matrix(link_list) |>
  as.data.frame()

# convert row names to column
from_name <- "source"
to_name <- "target"
links[[to_name]] = row.names(links)
names(links)[1] = from_name
```

``` r
xmap::pairs_from_named(list = link_list,
                      col_from = "source",
                      col_to = "target",
                      col_weights = "weights")
```

#### Helper: Node pairs from Named List or Vector

```{r fnc-pairs-from-named}
#' Make candidate node pairs from named list or vector
#' 
#' Convert a named list of one-to-one (named vector) or many-to-one (named list) relations 
#' into a two-column table of node pairs.
#' It extracts the vector or list element names and the values, unnesting where necessary.
#'
#' @param x named list or vector. Each item contains a vector or value of source node(s) which map to
#' the target node named.
#' @param names_to,values_to character vector specify the new columns to pass the information in `x` into.
#'
#' @return tibble containing .
#' @export
#'
#' @examples
#' veg_vec <- c(eggplant = "aubergine", zucchini = "courgette")
#' as_pairs_from_named(veg_vec, "au_eng", "uk_eng")
#' 
#' animal_list <- list(MAMM = c("elephant", "whale", "monkey"),
#'                  REPT = c("lizard", "turtle"),
#'                  CRUS = c("crab"))
#' as_pairs_from_named(animal_list, "class", "animal")
as_pairs_from_named <- function(x, names_to = "name", values_to = "value"){
  stopifnot(is.vector(x))
  node_pairs <- x |>
    tibble::enframe(name = names_to, value = values_to) |>
    tidyr::unnest_longer(col=tidyr::all_of(values_to))
  return(node_pairs)
}
```

#### TODO: test for pairs_from_named()

```{r}

```

#### Helper: Add weights to pairs

```{r fnc-add-weights-unit}
#' Add unit weights to node pairs table
#'
#' Attaches column of unit weights to pairs of source-target nodes.
#' The resultant weighted links can be verified or coerced into `xmap`.
#'
#' @param pairs data.frame or tibble containing node pairs
#' @param weights_into character string naming new column to store link weights in
#'
#' @return `pairs` with additional column of ones
#' @export
#'
#' @examples
#' AUS_list <- list(AUS = c("NSW", "QLD", "SA", "TAS", "VIC", "WA", "ACT", "NT"))
#'   as_pairs_from_named(AUS_list, names_to = "ctr", values_to = "state") |>
#'   add_weights_unit(weights_into = "weights")
add_weights_unit <- function(pairs, weights_into = "weights"){
  pairs[,weights_into] <- 1
  return(pairs)
}
```

### Link Properties: `vhas_*(x_)`

`vhas_*(v_)` functions take in vector arguments only, and are designed to be able to validate the graph features of non-data.frame xmaps (so long as the links can be decomposed into from,to,weight vectors).

```{r send_to="R/vhas.R"}
#' Boolean flags for properties of candidate and validated xmap links
#'
#' @description
#' `vhas_*()` functions check properties of xmap links and/or candidate links.
#' The functions only accepts equal length vector inputs to support multiple link formats,
#' but does not check if the inputs are from the same xmap.
#' @param v_from,v_to,v_weights equal length vectors containing the source-target node pairs
#' 
#' @return TRUE or FALSE
#' 
#' @name vhas
NULL
```

#### Crossmap Property Flags

A valid Crossmap satisfies the following conditions:

1.  There is at most one link between each distinct source and target node (`has_dup_pairs()`)
2.  For each source node, the sum of weights attached to all outgoing links sums to one. (`has_complete_weights()`)

```{r send_to="R/vhas.R"}
#' @describeIn vhas Returns TRUE if xmap does not have 
#' duplicate pairs of source-target nodes (irrespective of weights)
#'
vhas_no_dup_pairs <- function(v_from, v_to) {
  stopifnot(is.vector(v_from))
  stopifnot(is.vector(v_to))
  stopifnot(identical(length(v_from), length(v_to)))
  links <- data.frame(v_from, v_to)
  dup_idx <- anyDuplicated(links)
  !as.logical(dup_idx)
}
```

```{r send_to="R/vhas.R"}
#' @describeIn vhas Returns TRUE if all weights for a given `from` label
#' sum to one (approximately)
#' @param tol Tolerance of comparison. Passed through to the `tolerance` arg of
#' `base::all.equal()`.
vhas_complete_weights <- function(v_from, v_weights, tol = .Machine$double.eps^0.5) {
  stopifnot(is.vector(v_from))
  stopifnot(is.vector(v_weights))
  stopifnot(identical(length(v_from), length(v_weights)))
  sum_w <- tapply(
    X = v_weights,
    INDEX = v_from,
    FUN = sum,
    simplify = TRUE
  ) |> as.vector()
  names(sum_w) <- NULL
  ones <- rep(1, length(sum_w))
  all(isTRUE(all.equal(sum_w, ones, tolerance = tol)))
}
```

```{r send_to="R/vhas.R"}
.calc_vector_lens <- function(...){
  v_list <- list(...)
  v_lens <- sapply(v_list, length)
  return(v_lens)
}
```

```{r send_to="R/vhas.R"}
#' @describeIn vhas Returns TRUE if links have no duplicate pairs and complete weights
vhas_xmap_props <- function(v_from, v_to, v_weights){
  ## check vectors are equal length
  v_lengths <- .calc_vector_lens(v_from, v_to, v_weights)
  stopifnot(length(unique(v_lengths)) == 1)
  
  ## check properties
  v_props <- c(
    pairs = vhas_no_dup_pairs(v_from, v_to),
    weights = vhas_complete_weights(v_from, v_weights)
  ) 
  all(v_props)
}
```

```{r test-has-flags}
testthat::test_that(
  "vhas_* xmap validation helpers work as expected on valid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.67,
      "A4", "B04", 0.33
    )
    testthat::expect_true(vhas_no_dup_pairs(df$from, df$to))
    testthat::expect_true(vhas_complete_weights(df$from, df$weights))
    testthat::expect_true(vhas_xmap_props(df$from, df$to, df$weights))
  }
)

testthat::test_that(
  "vhas_* xmap validation helpers catch invalid df",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A2", "B02", 0.3,
      "A2", "B02", 0.5
    )
    testthat::expect_false(vhas_complete_weights(df$from, df$weights))
    testthat::expect_false(vhas_no_dup_pairs(df$from, df$to))
  }
)

testthat::test_that(
  "vhas_complete_weights() works on recurring fractional weights",
  {
    df <- data.frame(key1 = rep("A1", 3),
                     key2 = c("B01", "B02", "B03"),
                     share = rep(1/3, 3))

    testthat::expect_true(vhas_complete_weights(df$key1, df$share))
  }
)
```

#### Relation Type Flags

-   used for print methods, reverse

```{r print-helpers, send_to="R/vhas.R"}
#' @describeIn vhas Return TRUE if xmap recodes labels between `from` and `to`
vhas_1to1 <- function(v_weights) {
  stopifnot(is.vector(v_weights))
  any(v_weights == 1)
}
#'
vhas_recode <- vhas_1to1

#' @describeIn vhas Return TRUE if xmap has splitting links between `from` and `to`
vhas_1toM <- function(v_weights) {
  stopifnot(is.vector(v_weights))
  any(v_weights < 1)
}
#'
vhas_split <- vhas_1toM

#' @describeIn vhas Return TRUE if xmap has collapsing links between `from` and `to`
vhas_1fromM <- function(v_to){
  stopifnot(is.vector(v_to))
  as.logical(anyDuplicated(v_to))
}
#'
vhas_collapse <- vhas_1fromM
```

```{r}
testthat::test_that(
  "vhas_* relation type flag functions work as expected",
  {
    w_1to1 <- rep(1, 10)
    w_1toM <- rep(1/6, 6)
    to_1fromM <- rep("country", 4)
    testthat::expect_true(vhas_recode(w_1to1))
    testthat::expect_false(vhas_recode(w_1toM))
    testthat::expect_true(vhas_split(w_1toM))
    testthat::expect_false(vhas_split(w_1to1))
    testthat::expect_true(vhas_collapse(to_1fromM))
  }
)
```

### Helper: df property checks

#### Abort Missing Columns

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if named columns can't be found in df
#'
abort_missing_cols <- function(df, cols) {
  missing_cols <- setdiff(cols, names(df))
  if (length(missing_cols) != 0) {
    cli::cli_abort(
      message = "The column{?s} {.var {missing_cols}} {?was/were} not found.",
      class = "abort_missing_cols"
    )
  }
  invisible(df)
}
```

#### Abort Missing Values

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if xmap_df has missing values
#'
abort_any_na <- function(df) {
  if (base::anyNA(df)) {
    cli::cli_abort(
      message = "NA values found. Please enter missing `from` or `to` node labels and/or convert NA weights",
      class = "abort_na"
    )
  }
  invisible(df)
}
```

### Verify: Named

```{r send_to="R/verify_named.R"}
#' Verify crossmap properties of named vectors
#'
#' @param x a named vector
#' @param ref_names,ref_values a vector of character strings 
#'
#' @return `x` or throw error
#' @name verify_named
#' @examples
#' ## check each fruit has a unique color
#' fruit_color <- c(apple = "green", strawberry = "red", banana = "yellow")
#' verify_named_all_1to1(fruit_color)
#' 
#' ## check no student is assigned to multiple groups
#' student_groups <- list(GRP1 = c("kate", "jane", "peter"),
#'                       GRP2 = c("terry", "ben", "grace"),
#'                       GRP3 = c("cindy", "lucy", "alex" ))
#' verify_named_no_dup_names(student_groups)
#' 
#' ## check 
NULL
```

Verify pairwise properties:

```{r send_to="R/verify_named.R"}
#' @describeIn verify_named Verify named vector or list has only one-to-one relations
#' @export
#' @examples
#' 
verify_named_all_pairs_1to1 <- function(x){
  stopifnot(is.vector(x))
  unique_names <- unique(names(x))
  unique_values <- unique(unlist(unname(x)))
  stopifnot(length(unique_names) == length(unique_values))
  invisible(x)
}

#' @describeIn verify_named Verify name-value pairs of named vector or list are not duplicated
#' @export
verify_named_all_pairs_unique <- function(x){
  stopifnot(is.vector(x))
  pairs <- as_pairs_from_named(x)
  stopifnot(!as.logical(anyDuplicated(pairs)))
  invisible(x)
}
```

Verify name or value sets

```{r send_to="R/verify_named.R"}
#' @describeIn verify_named Verify names of named vector or list are not duplicated
#' @export
verify_named_all_names_unique <- function(x){
  stopifnot(is.vector(x))
  dup_idx <- anyDuplicated(names(x))
  stopifnot(!as.logical(dup_idx))
  invisible(x)
}

#' @describeIn verify_named Verify values in named vector or list are not duplicated (after unnesting)
#' @export
verify_named_all_values_unique <- function(x){
  stopifnot(is.vector(x))
  dup_idx <- anyDuplicated(unlist(unname(x)))
  stopifnot(!as.logical(dup_idx))
  #stopifnot(unlist(unname(x)) == unique(unlist(unname(student_groups))))
  invisible(x)
}

#' @describeIn verify_named Verify names of named vector or list **exactly** match an expected set of name values
#' @export
verify_named_match_names_exact <- function(x, ref_names){
  stopifnot(is.vector(x))
  unique_names <- unique(names(x))
  stopifnot(setequal(ref_names, unique_names))
  invisible(x)
}

#' @describeIn verify_named Verify names of named vector or list **contain** an expected set of name values
#' @export
verify_named_match_names_contain <- function(x, ref_names){
  stopifnot(is.vector(x))
  unique_names <- unique(names(x))
  stopifnot(ref_names %in% unique_names)
  invisible(x)
}

#' @describeIn verify_named Verify names of named vector or list are **within** an expected set of name values
#' @export
verify_named_match_names_within <- function(x, ref_names){
  stopifnot(is.vector(x))
  unique_names <- unique(names(x))
  stopifnot(unique_names %in% ref_names)
  invisible(x)
}
```

Tests:

```{r}
testthat::test_that("verify_named_match fncs work as expected", {
  v_1to1 <- c(x1 = 1, x2 = 2, x3 = 3)
  refn_exact_1to1 <- c("x1", "x2", "x3")
  refn_subset_1to1 <- c("x1", "x2")
  refn_superset_1to1 <- c("x1", "x2", "x3", "x4")
  testthat::expect_equal(verify_named_match_names_exact(v_1to1, refn_exact_1to1), v_1to1)
  testthat::expect_error(verify_named_match_names_exact(v_1to1, c("not", "right")))
  testthat::expect_equal(verify_named_match_names_contain(v_1to1, refn_subset_1to1), v_1to1)
  testthat::expect_equal(verify_named_match_names_contain(v_1to1, refn_exact_1to1), v_1to1)
  testthat::expect_error(verify_named_match_names_contain(v_1to1, refn_superset_1to1))
  testthat::expect_equal(verify_named_match_names_within(v_1to1, refn_superset_1to1), v_1to1)
  testthat::expect_equal(verify_named_match_names_within(v_1to1, refn_exact_1to1), v_1to1)
  testthat::expect_error(verify_named_match_names_within(v_1to1, refn_subset_1to1))
})
```

Aliases:

```{r verify-named-aliases, send_to="R/verify_named.R"}
#' @describeIn verify_named (alias) verify named vector or list has only one-to-one relations
#' @export
verify_named_as_recode_unique <- verify_named_all_pairs_1to1

#' @describeIn verify_named (alias)
#' @export
verify_named_no_dup_values <- verify_named_all_values_unique

#' @describeIn verify_named (alias)
#' @export
verify_named_no_dup_names <- verify_named_all_names_unique

#' @describeIn verify_named (alias)
#' @export
verify_named_match_exact_names <- verify_named_match_names_exact
```

### Verify: Pairs

```{r send_to="R/verify_pairs.R"}
#' Verify crossmap properties of column pairs
#'
#' @param x a data frame-like object with at least two columns
#' @param from
#' @param to
#'
#' @return `x` or error
#' @name verify_pairs
NULL

#' @describeIn verify_pairs Verify column pairs have only one-to-one relations
#' @export
verify_pairs_all_1to1 <- function(x, from, to){
  stopifnot(is.dataframe(x))
  set_from <- unique(x[[rlang::englue("{{from}}")]])
  set_to <- unique(x[[rlang::englue("{{to}}")]])
  stopifnot(length(set_from) == length(set_to))
  invisible(x)
}

#' @describeIn verify_pairs Verify columnn pairs are all unique
#' @export
verify_pairs_all_unique <- function(x, from, to){
  stopifnot
}

#' @describeIn verify_pairs (alias) Verify column pairs have only one-to-one relations
#' @export
verify_pairs_as_recode_unique <- verify_pairs_all_1to1

#' @describeIn verify_pairs Verify column pairs outgoing link degree
verify_pairs_out <- function(x, from, to, max_out, min_out){
  # TODO: FINISH THIS!
  dplyr::group_by(x, {{from}}) |>
  dplyr::summarise()
}
```

### Verify: Links

`abort_*(df,...)` all take an data.frame for first argument, and character values or vectors for the remaining arguments. They throw an error if the validation condition does not pass, and `NULL` otherwise.

```{r send_to="R/abort.R"}
#' Validation messages for xmap or candidate links
#'
#' @description
#' Checks issues with data.frame like objects containing validated `xmap` or candidate links.
#'
#' @param df a data.frame-like object containing links
#' @param col_from, col_to, col_weights character vector or values naming columns from `df`
#'
#' @returns An error if the validation condition fails,
#' and invisibly returns `df` otherwise.
#'
#' @name abort
NULL
```

#### Column Type Check

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if xmap_df has wrong column types
#'
abort_weights_col_type <- function(df, col_weights) {
  if (!is.numeric(df[[col_weights]])) {
    cli::cli_abort(
      message = "The column `{col_weights}` should be of type numeric",
      class = "abort_col_type"
    )
  }
  invisible(df)
}
```

#### No Duplicate Node Pairs (links)

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if duplicate source-target pairs are found
#'
abort_dup_pairs <- function(df, col_from, col_to) {
  if (!vhas_no_dup_pairs(df[[col_from]], df[[col_to]])) {
    cli::cli_abort(
      message = "Duplicate `from`-`to` links were found.
      Please remove or collapse duplicates.",
      class = "abort_dup_pairs"
    )
  }
  invisible(df)
}
```

#### Complete Mapping Weights

```{r fnc-check-weights, send_to="R/abort.R"}
#' @describeIn abort Abort if invalid mapping weights are found
#'
abort_bad_weights <- function(df, col_from, col_weights) {
  if (!vhas_complete_weights(df[[col_from]], df[[col_weights]])) {
    cli::cli_abort(
      message = "Incomplete mapping weights found. Check sum of weights for each `from` group sums to 1",
      class = "abort_bad_weights"
    )
  }
  invisible(df)
}
```

### `verify_links_as_xmap()`

```{r fnc-verify-links-as-xmap}
#' Check if candidate links meet crossmap properties
#' 
#' @param df data.frame like object containing candidate links 
#' @inheritParams as_xmap_df
#' 
#' @export
#' @examples
#' # For a well formed crossmap:
#' links <- data.frame(
#'   a = "AUS",
#'   b = c("VIC", "NSW", "WA", "OTHER"),
#'   w = c(0.1, 0.15, 0.25, 0.5)
#' )
#' verify_links_as_xmap(links, from = a, to = b, weights = w)
verify_links_as_xmap <- function(df, from, to, weights){
  col_from <- deparse(substitute(from))
  col_to <- deparse(substitute(to))
  col_weights <- deparse(substitute(weights))
  col_attrs <- c(col_from, col_to, col_weights)
  abort_missing_cols(df, col_attrs)
  abort_any_na(df)
  abort_weights_col_type(df, col_weights)
  abort_dup_pairs(df, col_from, col_to)
  abort_bad_weights(df, col_from, col_weights)
  
  invisible(df)
}
```

## `xmap` Class Structure

The package uses the class `xmap` as the superclass for all representations of a crossmaps, and subclasses: `xmap_df`

### `xmap` parent class properties

`xmap` is a virtual parent class indicating the object is a "crossmap", and satisfies the mathematical properties of a "crossmap" shared by all representations.

Let `g` be an object of class `xmap`. Then `g`:

-   has only one weighted link between each source-target pair of form:
-   `{source: "A1", target: "B01", weight: 1}`
-   for every source node, the weights on all (outgoing) links sum to 1 (subject to some floating point tolerance?)

### `xmap_df` subclass properties

`xmap_df` is a concrete subclass for encoding crossmaps as lists of graph edges with attributes indicating the node sets and direction of the map.

Let `X` be an **validated** object of class `xmap_df`. Then:

-   `X` inherits from the class `xmap_df`
-   `X` is a data.frame-like object and:
    -   contains the columns named in the `col_from`, `col_to`, `col_weights` attributes
    -   has no missing values - the character vector of all unique values in the `col_from` variable exactly match the `from_set` attribute - the `col_weights` column is a numeric vector - `X` inherits from the class `xmap`
    -   (each row represents a single weighted link)

## Construction

The naming convention for constructors is: `new_<subclass>()`. For example: `new_xmap_df()`

### Helper for subclass attributes

Eventually support matrix, graph, and data.frame?

```{r send_to="R/new_xmap.R"}
#'
.calc_xmap_subclass_attr <- function(subclass = c("xmap_df")){
  subclass <- rlang::arg_match(subclass)

  class_attr <- switch(subclass,
         xmap_df = c("xmap_df", "xmap", "data.frame"),
         stop("Unknown xmap subclass"))
  
  return(class_attr)
}
```

```{r}
testthat::test_that(".calc_xmap_subclass_attr() rejects unknown subclass",
                    {
                      testthat::expect_error(.calc_xmap_subclass_attr("unknown"))
                    })
```

### Construct From Links Data Frame

The low-level constructor takes in:

-   one data argument (`x`), accepts base objects of type data.frames (and subclasses)
-   three required descriptor arguments (`from`, `to`, `weights`) which are stored as attributes, and must be character strings only.
-   one optional descriptor argument (`from_set`) which is stored as an attribute, and must be a character vector.

The constructor does the following:

-   checks base object and attribute types.
-   checks the descriptor argument types.
-   if `from_set` is not provided, naively generates the `from_set` of unique `from` values
-   appends the class attributes: `xmap_df` and `xmap`

It assumed, but not checked that:

-   (`x` contains the column named in `from`, `to`, `weights` arguments?)
-   (the `from_set` vector attributes contains all unique values of `from` column in `x`)
-   (the `weights` column contains numeric weights)

The constructor returns an object of class `xmap_df` which:

-   inherits from classes: `data.frame`, `xmap_df`, `xmap`
-   has additional attributes named using graph terminology:
    -   `col_from`: source nodes
    -   `col_to`: target nodes
    -   `col_weights`: link weights
    -   `from_set`: source node set

```{r xmap-constructor, send_to="R/xmap_df.R"}
#' Low Level Constructors for xmap subclasses
#' @param x data-frame object containing candidate links.
#' @param col_from,col_to,col_weights character strings naming columns containing source nodes, target nodes and numeric weights.
#' @return xmap_df object. Note that this function unclasses tibbles.
#' @name new_xmap
NULL

#' @describeIn new_xmap Construct xmap_df from data.frame
new_xmap_df <- function(x, col_from, col_to, col_weights, from_set = NULL) {
  #' checks argument types
  stopifnot(is.data.frame(x))
  stopifnot(length(col_from) == 1 && is.character(col_from))
  stopifnot(length(col_to) == 1 && is.character(col_to))
  stopifnot(length(col_weights) == 1 && is.character(col_weights))

  #' naively generates `from_set` if it is missing
  from_set <- from_set %||% as.character(unique(x[[col_from]]))
  stopifnot(is.vector(from_set, mode = "character"))

  #' @return `x` with additional subclasses `xmap_df` and `xmap`

  class(x) <- .calc_xmap_subclass_attr("xmap_df")
  structure(x,
    col_from = col_from,
    col_to = col_to,
    col_weights = col_weights,
    from_set = from_set
  )
}
```

Tests:

```{r test-constructor-success}
testthat::test_that(
  "new_xmap_df() accepts arbitrary data.frames with correct from argument",
  {
    df <- data.frame(
      x = letters[1:5],
      y = 1:5,
      z = runif(5)
    )
    xmap <- new_xmap_df(x = df, "x", "y", "z")
    xmap_attrs <- attributes(xmap)
    testthat::expect_s3_class(xmap, .calc_xmap_subclass_attr("xmap_df"))
    testthat::expect_identical(xmap_attrs$col_from, "x")
    testthat::expect_identical(xmap_attrs$col_to, "y")
    testthat::expect_identical(xmap_attrs$col_weights, "z")
    testthat::expect_identical(xmap_attrs$from_set, unique(df$x))
  }
)
```

Snapshot tests don't work in litr

``` r
testthat::test_that(
  "new_xmap_df() rejects incorrect object types",
  {
    testthat::local_edition(3)
    testthat::expect_snapshot(error = TRUE, new_xmap_df(x = "not a data.frame"))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = 33))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = expression(5 + 9)))
    testthat::expect_snapshot(error = TRUE, new_xmap_df(from = "chr", to = "char", weights = c("dsf", "3925")))
  }
)
```

### Class Tests

```{r send_to="R/is_xmap.R"}
#' Test if object is a crossmap
#'
#' This function returns `TRUE` for crossmaps `xmap` or subclasses thereof (`xmap_df`), and `FALSE` for all other objects, including regular data.frames or tibbles.
#' @export
#' @rdname as_xmap
is_xmap <- function(x) {
  base::inherits(x, "xmap")
}

#' Test if object is `xmap_df`
#' @export
#' @rdname as_xmap
is_xmap_df <- function(x) {
  rlang::inherits_all(x, c("xmap_df", "xmap"))
}
```

## Validation: `xmap_df`

### Diagnostic Helpers (`validate-helpers.R`)

The conventions for validation helpers:

#### Column Order Check

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if xmap_df columns are not in order
abort_col_order <- function(df, col_from, col_to, col_weights){
  correct_order <- c(col_from, col_to, col_weights)
  first_three <- names(df[1:3])
  if(!identical(first_three, correct_order)){
    rlang::abort(
      message = "columns are not sorted in order `from`, `to`, `weights`",
      class = "abort_col_order"
    )
  }
  invisible(df)
}
```

```{r}
testthat::test_that("abort_col_order() works as expected",
                    {
                      df <- data.frame(a = 1, b = 2, c = 3)
                      testthat::expect_invisible(abort_col_order(df, "a", "b", "c"))
                      testthat::expect_identical(abort_col_order(df, "a", "b", "c"), df)
                      testthat::expect_error(abort_col_order(df, "b", "a", "c"),
                                             class = "abort_col_order")
                    })
```

#### From Set Check

```{r send_to="R/calc.R"}
#'
.calc_unique_sets.xmap_df <- function(x){
  stopifnot(is_xmap_df(x))
  df <- data.frame(x)
  x_attrs <- attributes(x)
  uniq_sets <- list()
  uniq_sets$from_set <- as.character(unique(df[[x_attrs$col_from]]))
  uniq_sets$to_set <- as.character(unique(df[[x_attrs$col_to]]))
  return(unique_sets)
}
```

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if from_set attribute doesn't match xmap_df values
#'
abort_from_set <- function(df, col_from, from_set) {
  col_from_set <- as.character(unique(df[[col_from]]))
  stopifnot(identical(col_from_set, from_set))

  invisible(df)
}
```

#### Tests

`df_check*` fncs are currently checked as part of the master validator `validate_xmap_df()`.

### Internal: `validate_xmap_df()`

-   order checks from cheapest to most expensive
-   validates data.frame properties:
    -   contains columns named in attributes
        -   (implies df has at least `3` columns) -- ncol3 check removed as discussed in [conformr-project #57](https://github.com/cynthiahqy/conformr-project/issues/57#issuecomment-1401239494)
    -   has no missing values in ANY column
    -   from_set attributes matches unique values in `from` column
    -   weights column is `numeric`
-   checks graph properties:
    -   A: duplicate source-target rows (weights should be collapsed into a single row)
    -   B: no missing weights (checked above with missing values)
    -   C: `sum()` of values in weights column by source-code is `1` (or subject to floating point tolerance)
        -   C will also fail if B fails, but not if A fails.

```{r send_to="R/get-helpers.R"}
#'
.get_col_attrs.xmap_df <- function(x){
  stopifnot(is_xmap_df(x))
  x_attrs <- attributes(x)
  col_attrs <- x_attrs[startsWith(names(x_attrs), "col")]
  return(col_attrs)
}
```

```{r xmap-validator}
#' Validator for `xmap_df` objects
#'
validate_xmap_df <- function(x) {
  stopifnot(is_xmap_df(x))

  df <- data.frame(x) # unclass(x)
  x_attrs <- attributes(x)
  col_attrs <- c(x_attrs$col_from, x_attrs$col_to, x_attrs$col_weights) 

  ## ---- df attributes ----
  abort_missing_cols(df, col_attrs)
  abort_any_na(df)
  
  ## ---- xmap_df attributes ---
  abort_col_order(df, x_attrs$col_from, x_attrs$col_to, x_attrs$col_weights)
  abort_from_set(df, x_attrs$col_from, x_attrs$from_set)

  ## ---- xmap graph properties ----
  abort_weights_col_type(df, x_attrs$col_weights)
  abort_dup_pairs(df, x_attrs$col_from, x_attrs$col_to)
  abort_bad_weights(df, x_attrs$col_from, x_attrs$col_weights)

  ## return original object
  invisible(x)
}
```

#### Tests for `validate & verify()`

```{r test-validator-success}
testthat::test_that(
  "validate & verify xmap fncs accept well-formed xmaps",
  {
    df <- tibble::tribble(
      ~node_A, ~node_B, ~w_AB,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    x <- new_xmap_df(df, "node_A", "node_B", "w_AB")
    out <- testthat::expect_invisible(validate_xmap_df(x))
    testthat::expect_identical(out, x)
    testthat::expect_identical(df, verify_links_as_xmap(df, node_A, node_B, w_AB))
  }
)
```

```{r test-validator-malformed}
## columns present
testthat::test_that(
  "validate & verify fncs reject missing columns",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1
    )
    x <- new_xmap_df(df, "from", "missing_col", "weights")
    testthat::expect_error(abort_missing_cols(df, c("from", "missing_col", "weights")),
      class = "abort_missing_cols"
    )
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_missing_cols"
    )
    testthat::expect_error(verify_links_as_xmap(df, node_A, node_B, w_AB),
                           class = "abort_missing_cols")
  }
)

## any NA values
testthat::test_that(
  "validate & verify xmap fncs reject missing values",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B2", NA,
      NA, "B2", NA,
      "A3", "B1", 1
    )
    x <- new_xmap_df(df, "from", "to", "weights")
    testthat::expect_error(validate_xmap_df(x), class = "abort_na")
    testthat::expect_error(verify_links_as_xmap(df, from, to, weights),
                           class = "abort_na")
  }
)


## column type
testthat::test_that(
  "validate & verify xmap fncs reject non-numeric weight columns",
  {
    df <- tibble::tribble(
      ~f, ~t, ~w,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    ) |>
      dplyr::mutate(w = as.character(w))
    testthat::expect_error(abort_weights_col_type(df, "weights"),
      class = "abort_col_type"
    )
    x <- new_xmap_df(df, "f", "t", "w")
    testthat::expect_error(validate_xmap_df(x),
      class = "abort_col_type"
    )
    testthat::expect_error(verify_links_as_xmap(df, f, t, w),
                           class = "abort_col_type")
  }
)

## from set check
testthat::test_that(
  "validate_xmap_df() rejects mismatching from_set",
  {
    df <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    )
    bad_set <- c("bad set", "of", "nodes")
    testthat::expect_error(abort_from_set(df, "from", bad_set))
    x <- new_xmap_df(df, "from", "to", "weights", from_set = bad_set)
    testthat::expect_error(validate_xmap_df(x))
  }
)

## duplicate links
testthat::test_that(
  "validate and verify xmap fncs reject duplicate from-to links",
  {
    df <- tibble::tribble(
      ~f, ~t, ~w,
      "A1", "B02", 0.3,
      "A1", "B02", 1
    )
    testthat::expect_error(abort_dup_pairs(df, "f", "t"), class = "abort_dup_pairs")
    x <- new_xmap_df(df, "f", "t", "w")
    testthat::expect_error(validate_xmap_df(x), class = "abort_dup_pairs")
    testthat::expect_error(verify_links_as_xmap(df, f, t, w),
                           class = "abort_dup_pairs")
  }
)

## complete weights
testthat::test_that(
  "validate & verify xmap fncs rejects invalid weights",
  {
    df <- tibble::tribble(
      ~f, ~t, ~w,
      "A1", "B01", 0.4,
      "A1", "B02", 0.59
    )
    testthat::expect_error(abort_bad_weights(df, "f", "w"),
      class = "abort_bad_weights"
    )
    x <- new_xmap_df(df, "f", "t", "w")
    testthat::expect_error(validate_xmap_df(x), class = "abort_bad_weights")
    testthat::expect_error(verify_links_as_xmap(df, f, t, w),
                           class = "abort_bad_weights")
  }
)
```

## Coercion

### Generic: `as_xmap_df()`

```{r send_to="R/as_xmap.R"}
#' Coerce objects to xmap_df
#' 
#' Validates and creates a valid crossmap `xmap_df` object.
#' 
#' @param x
#'  * For `as_xmap_df()`: An object to coerce
#'  * For `is_xmap_df()`: An object to test.
#' @param from,to Columns in `x` specifying the source and target nodes
#' @param weights Column in `x` specifying the weight applied to data passed along the directed link between source and target node
#' @param subclass Which xmap subclass to return. Defaults to `xmap_df` for `data.frame` and `tibble`
#' @param .drop_extra Drop columns other than `from`, `to` and `weights`. Defaults to `TRUE`
#' 
#' @return A validated `xmap` object.
#' 
#' @export
as_xmap_df <- function(x, from, to, weights, subclass = c("xmap_df"), ...) {
  UseMethod("as_xmap_df")
}
```

### `as_xmap_df.data.frame()`

-   checks for:
    -   [x] existence of columns via `validate_xmap_df()`
-   warns for:
    -   [x] dropping extra columns (anything other than `from`, `to`, `weights`) as controlled by `.drop` argument
-   throws errors for:
    -   [x] any validation failures via `validate_xmap_df()`

```{r send_to="R/as_xmap.R"}
#' @describeIn as_xmap_df Coerce a `data.frame` to `xmap`
#'
#' @export
#' @examples
#' # For a well formed crossmap:
#' links <- data.frame(
#'   a = "AUS",
#'   b = c("VIC", "NSW", "WA", "OTHER"),
#'   w = c(0.1, 0.15, 0.25, 0.5)
#' )
#' as_xmap_df(links, from = a, to = b, weights = w)
#'
#' # extra columns are dropped,
#' links$extra <- c(2, 4, 5, 6)
#' as_xmap_df(links, from = a, to = b, weights = w)
as_xmap_df.data.frame <- function(x, from, to, weights, subclass = "xmap_df", .drop_extra = TRUE) {
  ## coercion & checks
  stopifnot(is.data.frame(x))

  # get string names for columns
  col_from <- deparse(substitute(from))
  col_to <- deparse(substitute(to))
  col_weights <- deparse(substitute(weights))
  col_strings <- c(col_from, col_to, col_weights)
  ## check columns exist
  abort_missing_cols(x, col_strings)

  ## drop additional columns
  if (.drop_extra) {
    df <- x[col_strings]
  } else {
    df <- x
  }
  if (ncol(df) < ncol(x)) {
    cli::cli_inform("Dropped additional columns in {.arg {deparse(substitute(x))}}")
  }

  ## rearrange columns
  col_order <- c(col_strings, setdiff(names(df), col_strings))
  df <- df[col_order]

  ## construction
  xmap <- switch(subclass,
                 xmap_df = new_xmap_df(df, col_from, col_to, col_weights),
                 stop("Unknown xmap subclass"))

  ## validation
  validate_xmap_df(xmap)

  return(xmap)
}
```

```{r}
testthat::test_that(
  "as_xmap() is returns expected xmap subclasses",
  {
     tbl_links <- tibble::tribble(
      ~f, ~t, ~w,
      "A1", "B01", 1,
      "A2", "B02", 1,
      "A3", "B02", 1,
      "A4", "B03", 0.67,
      "A4", "B04", 0.33
      )
     df_links <- as.data.frame(tbl_links)
     
     ## default subclasses work as expected
     testthat::expect_s3_class(as_xmap_df(df_links, f, t, w),
                               .calc_xmap_subclass_attr("xmap_df"))
     
     ## override subclass works as well
     testthat::expect_s3_class(as_xmap_df(tbl_links, f, t, w, subclass = "xmap_df"),
                               .calc_xmap_subclass_attr("xmap_df"))
  }
)
```

## Conversion

### to Matrix

#### Generic: `xmap_to_matrix()`

```{r send_to="R/xmap_to.R"}
#' Extract incidence matrix from xmap objects
#' 
#' Transforms `xmap` objects into incidence matrix where the rows are indexed by the `from` values
#' and the columns are indexed by `to` values. Drops any additional variables.
#' 
#' @param x an xmap object
#' @param sparse logical specifying if the result should be a sparse matrix. Defaults to TRUE.
#' @param ... Unused
#' 
#' @return A matrix or sparse matrix object
#' 
#' @export
xmap_to_matrix <- function(x, sparse, ...) {
  UseMethod("xmap_to_matrix")
}
```

#### Method: `xmap_to_matrix.xmap_df()`

```{r xmap-matrix, send_to="R/xmap_to.R"}
#' @describeIn xmap_to_matrix Coerce a `xmap_df` to a Matrix
#'
#' @return
#' @export
#'
#' @examples
#' abc_xmap <- data.frame(
#'  stringsAsFactors = FALSE,
#'                  origin = c("a","b","c","d","e",
#'                           "f","g","h","i","i","j","j","j"),
#'                    dest = c("AA","AA","AA","AA",
#'                           "BB","BB","CC","DD","EE","FF","GG","HH","II"),
#'            link = c(1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0.5, 0.3, 0.3, 0.4)
#'  ) |>
#' as_xmap_df(origin, dest, link)
#' xmap_to_matrix(abc_xmap)
xmap_to_matrix.xmap_df <- function(x, sparse = TRUE){
  x_attrs <- attributes(x)
  fm <- paste(x_attrs$col_weights, "~", x_attrs$col_from, "+", x_attrs$col_to,
              collapse = "")
  x_df <- x |>
    as.data.frame(stringsAsFactors = TRUE)
  
  if(sparse){
    x_mtx <- stats::xtabs(as.formula(fm), x_df, sparse = TRUE)
  } else {
    x_mtx <- stats::xtabs(as.formula(fm), x_df, sparse = FALSE)
    attr(x_mtx, "call") <- NULL
    unclass(x_mtx)
  }
  return(x_mtx)
}
```

```{r test-xmap-to-matrix}
testthat::test_that("xmap_to_matrix handles xmaps with different column counts",{
  links <- tibble::tribble(
    ~f, ~t, ~w,
    "A1", "B01", 1,
    "A2", "B02", 1,
    "A3", "B02", 1,
    "A4", "B03", 0.25,
    "A4", "B04", 0.75
  ) 
  xmap_small <- new_xmap_df(links, "f", "t", "w")

  links_extra <- links |> 
    dplyr::mutate(ex = "extra")
  xmap_extra <- new_xmap_df(links_extra, "f", "t", "w")
  
  xmap_matrix_small <- xmap_small |> xmap_to_matrix()
  xmap_matrix_extra <- xmap_extra |> xmap_to_matrix()
  
  testthat::expect_identical(xmap_matrix_small, xmap_matrix_extra)
  }
  )
```

### to List: `xmap_to_list()`

```{r send_to="R/xmap_to.R"}
#' Coerce a unit weights `xmap_df` to a List
#'
#' @param x xmap with only unit weights (i.e. all weights should be 1)
#'
#' @return named list. Each item contains a vector of source nodes which map to 
#' the target node named.
#' @export
#'
#' @examples
xmap_to_list <- function(x) {
  x_attrs <- attributes(x)
  # check only unit weights
  w <- x[[x_attrs$col_weights]]
  if (!all(w == 1)) {
    cli::cli_abort("`x` must only have unit weights. Can't convert to list.",
                   class = "abort_weights_not_unit")
  }
  
  # convert
  x |>
    subset(select = c(x_attrs$col_to, x_attrs$col_from)) |>
    tidyr::nest(source = c(x_attrs$col_from)) |>
    tibble::deframe() |>
    sapply(as.matrix) |>
    sapply(as.vector)
}
```

```{r test-xmap-to-list}
testthat::test_that("xmap_to_list works as expected", {
  links <- tibble::tribble(
    ~f, ~t, ~w,
    "A1", "B01", 1,
    "A2", "B02", 1,
    "A3", "B02", 1,
    "A4", "B03", 0.25,
    "A4", "B04", 0.75
  )
  ## works for collapse and recode relations
  xmap_unit <- new_xmap_df(links[1:3,], "f", "t", "w")
  unit_list <- list(B01 = c("A1"), B02 = c("A2", "A3"))
  testthat::expect_identical(unit_list, xmap_to_list(xmap_unit))
  ## rejects split relations
  xmap_mixed <- new_xmap_df(links, "f", "t", "w")
  testthat::expect_error(xmap_to_list(xmap_mixed), 
                         class = "abort_weights_not_unit")
})
```

```{r}
testthat::test_that("xmap_to_list() reverses as_pairs_from_named()", {
  link_list <- list(AA = c("x3", "x4", "x6"),
                    BB = c("x1", "x5"),
                    CC = c("x2")
                  )
  link_xmap <-
   as_pairs_from_named(link_list,
                  "capital", "xvars") |>
   add_weights_unit(weights_into = "w") |>
   new_xmap_df("xvars", "capital", "w")
  testthat::expect_identical(xmap_to_list(link_xmap), link_list)
})
```

with dplyr:

```{r}
pairs_df <- 
     as_pairs_from_named(link_list,
                  "capital", "xvars") 

pairs_df |> 
  dplyr::group_by(capital) |>
  dplyr::summarise(source = list(xvars)) |>
  tibble::deframe()
```

without dplyr:

```{r}
pairs_df |> 
  subset(select = c("capital", "xvars")) |>
  tidyr::nest(source = c("xvars")) |>
  tibble::deframe() |>
  sapply(as.matrix) |>
  sapply(as.vector)
```

## Description Tools

See [conformr-project #63](https://github.com/cynthiahqy/conformr-project/issues/63)

### Helper: xmap is reversible

```{r send_to="R/abort.R"}
#' @describeIn abort Abort if xmap_df is not reversible without new weights
#'
abort_not_reversible <- function(df, col_to) {
  x_to <- df[[col_to]]
  if (vhas_collapse(x_to)){
    cli::cli_abort("Collapse links in {.var xmap_df} cannot be reversed. Please supply new weights and create a new xmap.")
  }
  invisible(df)
}
  
```

## Modification

See [conformr-project #67](https://github.com/cynthiahqy/conformr-project/issues/67)

### Generic: `xmap_reverse()`

```{r xmap-reverse, send_to="R/xmap_reverse.R"}
#' Reverse xmap direction
#'
#' @param x xmap object to be reversed
#' @param weights_into A string specifying the name of a new or existing column to store reverse weights in. 
#'
#' @return xmap object of same class as `x`, or throws an error if `x` is not reversible
#' @export
#'
#' @examples
xmap_reverse <- function(x, weights_into){
  UseMethod("xmap_reverse")
}

#' @describeIn xmap_reverse Reverse a `xmap_df`
#' 
#' @export
xmap_reverse.xmap_df <- function(x, weights_into = "r_weights"){
  stopifnot(inherits(x, "xmap_df"))
  x_attrs <- attributes(x)
  df <- as.data.frame(x)
  
  ## check xmap can be reversed
  abort_not_reversible(df, x_attrs$col_to)

  ## make new xmap
  df[[weights_into]] <- 1
  new_from <- x_attrs$col_to
  new_to <- x_attrs$col_from
  new_weights <- weights_into
  new_cols <- c(new_from, new_to, new_weights)
  ## rearrange columns
  #col_order <- c(new_cols, setdiff(names(df), new_cols))
  df <- df[new_cols]
  
  ## construction
  xmap <- new_xmap_df(df, new_from, new_to, new_weights)
  
  ## validation
  validate_xmap_df(xmap)
  
  return(xmap)
}
```

```{r}
testthat::test_that("xmap_reverse.xmap_df() works as expected",             {
  df_x <- tibble::tribble(
      ~from, ~to, ~weights,
      "A1", "B01", 1,
      "A4", "B03", 0.25,
      "A4", "B04", 0.75
    ) |> as.data.frame() |> 
    new_xmap_df("from", "to", "weights")
  
  df_x_rev <- data.frame(
    to = df_x$to,
    from = df_x$from,
    r_weights = 1
  ) |>
    new_xmap_df("to", "from", "r_weights")
  
  # class checks
  testthat::expect_s3_class(xmap_reverse.xmap_df(df_x), class(df_x_rev))
  testthat::expect_s3_class(xmap_reverse(df_x), class(df_x_rev))
  
  # output checks
  testthat::expect_identical(xmap_reverse.xmap_df(df_x), df_x_rev)
  testthat::expect_identical(abort_not_reversible(df_x,"to"), df_x)
}
)
```

### Helper: `xmap_drop_extra()`

```{r}
#' Drop extra columns from `xmap` objects
#'
#' @export
xmap_drop_extra <- function(x){
  UseMethod("xmap_drop_extra")
}

#' @export
xmap_drop_extra.xmap_df <- function(x){
  stopifnot(is_xmap_df(x))
  
  col_strings <- simplify2array(.get_col_attrs.xmap_df(x))
  
  z_attrs <- attributes(x)
  z_attrs$names <- unname(col_strings)
  
  z <- as.data.frame(x)
  z <- z[,col_strings]
  attributes(z) <- z_attrs
  
  return(z)
}
```

```{r test-drop-extra, render='as-is'}
testthat::test_that('xmap_drop_extra works as expected', {
  links <- tibble::tribble(
  ~f, ~t, ~w,
  "A1", "B01", 1,
  "A2", "B02", 1,
  "A3", "B02", 1,
  "A4", "B03", 0.25,
  "A4", "B04", 0.75
  ) 
  xmap_small <- new_xmap_df(links, "f", "t", "w")

  links_extra <- links |> 
    dplyr::mutate(ex = "extra")
  xmap_extra <- new_xmap_df(links_extra, "f", "t", "w")
  
  xmap_drop_df <- xmap_extra |> xmap_drop_extra.xmap_df()
  xmap_drop <- xmap_extra |> xmap_drop_extra()
  
  testthat::expect_identical(xmap_small, xmap_drop_df)
  testthat::expect_identical(xmap_small, xmap_drop)
})
```

## Visualisation

Adding in more dependencies

```{r vis-depend}
usethis::use_package("dplyr", type = "suggests")
usethis::use_package("tibble", type = "suggests")
usethis::use_package("ggplot2", type = "suggests")
usethis::use_package("ggbump", type = "suggests")
```

### Planned Generic: `xmap_viz_*()`

This section is left in for future reference, when I get around to properly developing visualisation functions for crossmaps.

#### `xmap_viz_bigraph()`

Doc-string for future reference

``` r
#' Visualise `xmap` as bigraph
#' 
#' Plot crossmap as bigraph using sigmoid curves from ggbump.
#'
#' @param x object to plot
#' @param ... reserved for future plot customisation options
#'
#' @return ggplot2 object
#' @export
#'
#' @examples
#' library(ggplot2)
#' library(dplyr)
#' simple_xmap <- tibble::tribble(~f, ~t, ~w,
#'                              "x1111", "A1", 1,
#'                              "x2222", "B2", 0.5,
#'                              "x2222", "B3", 0.5,
#'                              "x3333", "C5", 1,
#'                              "x4444", "C5", 1,
#'                              "x5555", "D6", 0.4,
#'                              "x5555", "D7", 0.6,
#'                              "x6666", "D6", 0.3,
#'                              "x6666", "D7", 0.7,
#'                              "x7777", "D6", 1)  |> 
#'                 as_xmap_df(from = f, to = t, weights = w)
#' xmap_viz_bigraph(simple_xmap)
xmap_viz_bigraph <- function(x, ...){
  UseMethod("xmap_viz_bigraph")
}

#' @describeIn xmap_viz_bigraph Plot `xmap_df` as sigmoid bigraph
#' @export
#'
#' xmap_viz_bigraph.xmap_df <- function(x, ...) {
```

#### `xmap_viz_matrix()`

```{r xmap-viz-matrix}

```

### Example Plots

See `vis-xmaps.Rmd` vignette

## S3 Enhancements

See discussion [here](https://github.com/cynthiahqy/conformr-project/issues/43#issuecomment-1396445724)

### Printing

[conformr-project #60](https://github.com/cynthiahqy/conformr-project/issues/60)

#### Method: `xmap_df`

```{r print-xmap-df, send_to="R/print.R", results='asis', paged.print=FALSE}
#'
.calc_link_types.xmap_df <- function(xmap_df){
  x_attrs <- attributes(xmap_df)
  x_weights <- xmap_df[[x_attrs$col_weights]]
  x_to <- xmap_df[[x_attrs$col_to]]
  
  flags <- c(
      "recode" = vhas_recode(x_weights),
      "split" = vhas_split(x_weights),
      "collapse" = vhas_collapse(x_to)
    )
  types <- names(flags[flags == TRUE])
  type <- cli::pluralize("{types} {? }")

  return(type)
}

#'
.calc_link_direction.xmap_df <- function(xmap_df){
  x_attrs <- attributes(xmap_df)
  direction <- paste0("(", x_attrs$col_from, " -> ", x_attrs$col_to, ") ", 
                      "BY " ,x_attrs$col_weights)
  return(direction)
}

#' Print an `xmap` object
#' 
#' @name print.xmap
NULL

#' @describeIn print.xmap Print an `xmap_df`
#'
#' @export
print.xmap_df <- function(x){
  x_direction <- .calc_link_direction.xmap_df(x)
  x_type <- .calc_link_types.xmap_df(x)
  x_links <- as.data.frame(x)

  ## print headers and links
  cat(paste0("xmap_df:\n",  x_type, "\n", x_direction, "\n"))
  print(x_links)
}
```

Test Prints:

```{r paged.print=FALSE}
valid_xmap_df <-
  tibble::tribble(
    ~new_sec, ~sector, ~weight,
    "mining", "MINE", 1,
    "agri", "AGRI", 1,
    "agri", "FISH", 1,
    "text", "MANU", 0.25,
    "food", "MANU", 0.25,
    "chem", "MANU", 0.25,
    "elec", "MANU", 0.25,
    "build", "CONS", 1 / 3,
    "roads", "CONS", 1 / 3,
    "civil", "CONS", 1 / 3,
  ) |>
  dplyr::mutate(extra_col = "stuff") |>
  as_xmap_df(from = sector, to = new_sec, weight)

print(valid_xmap_df)
```

### Read / Write Methods

Discussed here: [conformr-project #62](https://github.com/cynthiahqy/conformr-project/issues/62)

### Plot Method

Suggested in [confomr-project #43](https://github.com/cynthiahqy/conformr-project/issues/43#issuecomment-1396445724)

## Package Creation

### Add Vignettes

``` r
## doesn't work???
vignette_images <- paste0("../",
                          list.files("xmap-source-files", pattern = "plot", full.names = TRUE))
add_vignettes(vignette_images)
```

```{r}
litr::add_readme("../xmap-source-files/README.Rmd")
litr::add_vignettes("../xmap-source-files/xmap.Rmd")
litr::add_vignettes("../xmap-source-files/making-xmaps.Rmd")
litr::add_vignettes(c("../xmap-source-files/using-xmaps.Rmd",
                      "../xmap-source-files/using-xmaps.bib",
                      "../xmap-source-files/plot-coverage-matrix.png",
                      "../xmap-source-files/plot-missing-val-bigraph.png"
                    ))
litr::add_vignettes(c("../xmap-source-files/vis-xmaps.Rmd",
                      "../xmap-source-files/plot-weight-sum-matrix.png"))
```

### Render package

To debug without having to re-render the litr file every time use the `pkg = "."` argument in devtools functions:

``` r
devtools::run_examples('xmap')
devtools::test('xmap')
devtools::build('xmap')
devtools::install('xmap')
devtools::check('xmap', document = FALSE)
```

We finish by running commands that will document, build, and install the package. It may also be a good idea to check the package from within this file.

```{r}
rm(list = ls())
litr::document() # <-- use instead of devtools::document()
litr::add_pkgdown()
#pkgdown_yml <- file.path("..", "xmap-source-files", "_pkgdown.yml")
#litr::add_pkgdown(pkgdown_yml)
# devtools::run_examples()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```

---
title: "Creating the ``r params$package_name`` R package"
author: "Cynthia Huang"
date: 2022-12-21
output: litr::litr_html_document
params:
  package_name: "xmap" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

```{=html}
<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->
```
## Package Setup

### DESCRIPTION file

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9005",
    Title = "Extended Schema Crosswalks",
    Description = "Provides a 'xmap' S3 class (the 'Crossmap') based on 'tbl_df' class for use in {conformr} package.",
    `Authors@R` = person(
      given = "Cynthia",
      family = "Huang",
      email = "cynthiahqy@gmail.com",
      role = c("aut", "cre")
      ),
    `Config/testthat/edition` = 3
  )
)
usethis::use_mit_license(copyright_holder = "C. Huang")
```

### Dependencies

```{r}
usethis::use_package("rlang")
usethis::use_package("cli")
```

## Package Design Notes

### Crossmap and Crosswalk tables

<!--# define crosswalks -->

Crosswalks are used in many different applications and domains, and generally refer to a table showing equivalent or related elements in two distinct nomenclature, schema or standards. Crosswalks are used to encode one-to-one, one-to-many, many-to-one, and many-to-many relations. Except for cases where there are only one-to-one relations, Crosswalks are "lateral" (one-way) mappings.

<!--# define crossmaps -->

Crossmaps extends the standard Crosswalk format to explictly encode the weights used when mapping data from one scheme to another. A crosswalk table generally consists of two columns, one each for the two schemes, and each row specifies a relation between elements of the disjoint schemes. A crossmap adds an additional column specifying transition weights for mapping data belonging to class elements in the source (initial) scheme into class elements in target scheme.

<!--# insert image of crosswalk & crossmap TABLES (generate ggxmap/gt?) -->

### Graph and Matrix Representations

<!--# relation to graph & incidence matrix representation -->

Crosswalked datasets are often visualised using Sankey flow diagrams. These diagrams hint at the fact that, when considered independently of the data they are applied to, crosswalks can be represented as directed acyclic bipartite graphs. Recall that for a bipartite graph, the nodes $N$ can be subdivided into two disjoint sets ($N_1, N_2$), and links are only allowed between these two sets. The class elements of the source and target classifications naturally form two disjoint sets of nodes.

<!--# INSERT image of crosswalk GRAPH (generate using ggxmap) -->

Noting that crossmaps are essentially lateral crosswalks with weights attached to each relation, we find that crossmaps can be represented as weighted acyclic bipartite digraphs. A crossmap fully captures all the information needed to "transition" or "translate" numeric and/or categorical data between the source and target classes (nodes).

<!--# INSERT image of crossmap as graph (generate using ggxmap) -->

Furthermore, the explicit weights make clear why mappings are generally "lateral". Consider the case <!--# above? --> where you have a many-to-one relation between source and target schemes.

### Application to Ex-Post Data Harmonisation

<!--# define ex-post data harmonisation -->

Crossmaps have features which are especially useful when using a Crosswalk approach to ex-post data harmonisation requiring one-to-many splits. Ex-post data harmonisation refers to the integration of data from ....

Continuing with the graph representation, we can attach arbitary numeric values (such as counts, or monetary amounts) to each source node as additional properties of each node. <!--# brings us back to sankey diagram representation -->

<!--# related but distinct requirements compared to crosswalks in metadata / data mapping -->

Although both processes use crosswalks, the requirements of an ex-post harmonisation workflow have some important differences to crosswalking between database schemas ("metadata translation using schema crosswalks [(Wikipedia)](https://en.wikipedia.org/wiki/Schema_crosswalk)")[^1], and are more specific than "data mapping" [(Wikipedia)](https://en.wikipedia.org/wiki/Data_mapping) between distinct data models. In particular, for the latter two cases, there are often more obvious constraints on candidate crosswalks (agreed upon standards etc., translation between legacy systems etc., more obvious connection between the two databases, harmonising data flows), and fewer classes (fields).

[^1]: Schema crosswalks show equivalent elements or "fields" between database schema, and are used to "translate" data from one format into another in "metadata mapping".

On the other hand, ex-post harmonisation is often a "last resort" attempt to bring together data from different sources to answer difficult questions (social sciences). The data is often scarce, expensive to collect, and as a result the semantic ties between the datasets are not so obvious, and much more subjective opinion is applied when designing crosswalks (and the implicit weights).

### Crosswalk vs. Crossmap Transformation

<!--# applying crosswalks vs. crossmaps -->

A crossmap transformation can be performed by passing a valid crossmap table and validated input data can be passed as inputs into "generic" transformation function, which implements a (left join, mutate, and aggregate), to produce the target dataset without generating any additional code. The specific conditions for source data are discussed in `{conformr}`.

<!--# insert image of transformation -- JOIN -->

On the other hand, crosswalks need to be translated into procedural code (ETL, graphical manuals, for-loops). <!--# short list of drawbacks -->. The drawbacks and limitation of these approaches are discussed in more detail in `{conformr}`.

<!--# ETL, graphical methods not so relevant (because we're not generally looking at data stored in database schema) -->

<!--# common practice is for-loops; drawbacks // maybe point people to conformr pkg -->

For-loops must be coded from either the source-code or target-code perspective (i.e. you iterate over the source classes or target classes, dealing with each set of relations one by one). The most obvious drawback to this approach is the number of lines of code grows with the number of classes in the classifications, decreasing the readability of the code.

For-loops are often used when generating data-driven weights <!--# (are they? they are natural fit for it, especially for social science data) -->. However,

<!--# benefits of crosswalks for ex-post harmonisation -->

Crossmaps provide a systematic structure for validating candidate mappings, and can enable tractable experimentation with different processes for generating mappings[^2] and conducting sensitivity analysis.

[^2]: e.g. using data-driven mapping ([Wikipedia, no reference](https://en.wikipedia.org/wiki/Data_mapping))

## Toy Examples

```{r ideal-xmap}
## define some test data here

input_df <- tibble::tribble(~from, ~to, ~weights,
                           "A1", "B01", 1,
                           "A2", "B02", 1,
                           "A3", "B02", 1,
                           "A4", "B03", 0.25,
                           "A4", "B04", 0.75)

int_dat <- list("input_df" = input_df)

usethis::use_data(int_dat, internal = TRUE, overwrite = TRUE)
```

## Class Constructor

Following the advice given in [13.3 of Advanced R](https://adv-r.hadley.nz/s3.html#s3-classes) & Tidyverse Design Guide

### `xmap_df` properties

-   has class attributes: `data.frame`, `xmap_df`
-   has additional attributes named using graph terminology:
    -   `col_from` source key/codes column
    -   `col_to` target codes/labels
    -   `col_weights`
    -   `from_set`
-   has exactly non-empty `3` columns.

The low-level constructor takes in:

-   one data argument (`x`), accepts base objects of type data.frames (and subclasses)
-   three descriptor arguments (`from`, `to`, `weights`) which are stored as attributes, and must be character strings only.

It does the following:

-   checks base object and attribute types.
-   checks column type restrictions. `from` should be coercible into character (from factor, numeric etc.), and `weights` should be numeric. This is also an implicit check that the columns `from` and `weights` exist in `x`.
-   naively generates the `from_set` of unique `from` values
-   returns an S3 object with the class `xmap_df`

```{r xmap-constructor}
#' Low Level Constructor for xmap
new_xmap <- function(x = data.frame(), from, to, weights) {
  ## argument type checks
  stopifnot(is.data.frame(x))
  stopifnot(ncol(x) == 3) ## validate
  stopifnot(length(from) == 1 && is.character(from))
  stopifnot(length(to) == 1 && is.character(to))
  stopifnot(length(weights) == 1 && is.character(weights))
  
  ## column type checks
  from_set <- unique(x[[from]])
  stopifnot(is.vector(from_set, mode = "character"))   ## validate 
  stopifnot(is.vector(x[[weights]], mode = "numeric")) ## validate

  ## class constructor
  class(x) <- append("xmap_df", class(x))
  structure(x, 
            col_from = from,
            col_to = to,
            col_weights = weights,
            from_set = from_set)
}
```

Tests:

```{r test-constructor-success}
testthat::test_that(
  "new_xmap() accepts arbitrary data.frames with correct from argument",
  {
    df <- data.frame(x = letters[1:5],
                     y = 1:5,
                     z = runif(5))
    xmap <- new_xmap(x = df, from = "x", to = "y", weights = "z")
    xmap_attrs <- attributes(xmap)
    testthat::expect_s3_class(xmap, "xmap_df")
    testthat::expect_identical(xmap_attrs$col_from, "x")
    testthat::expect_identical(xmap_attrs$col_to, "y")
    testthat::expect_identical(xmap_attrs$col_weights, "z")
    testthat::expect_identical(xmap_attrs$from_set, unique(df$x))
  }
)
```

```{r test-constructor-snapshot}
testthat::test_that(
  "new_xmap() rejects incorrect object types",
  {
    testthat::local_edition(3)
    testthat::expect_snapshot(error = TRUE, new_xmap(x = "not a data.frame"))
    testthat::expect_snapshot(error = TRUE, new_xmap(from = 33))
    testthat::expect_snapshot(error = TRUE, new_xmap(from = "chr", to = expression(5 + 9)))
    testthat::expect_snapshot(error = TRUE, new_xmap(from = "chr", to = "char", weights = c("dsf", "3925")))
  }
)
```

## Class Validation

-   order checks from cheapest to most expensive
-   validates data.frame element types:
    -   source/target columns are / can be coerced into factors
    -   weights is `numeric`
-   checks for:
    -   A: duplicate source-target rows (weights should be collapsed into a single row)

    -   B: `NA` values in the weights column

        -   precondition for C, independent of A

    -   C: `sum()` of values in weights column by source-code is `1` (or close..?)

        -   will also fail if B fails, but not if A fails.

### Validation Helpers

#### No missing values

```{r}
#' df has no missing values
#' 
has_no_NA <- function(df){
  !anyNA(df)
}
```

#### No Duplicate Node Pairs

```{r}
#' df has no duplicate links
has_no_dup_links <- function(df, from, to){
  links <- df[c(from, to)]
  dup_idx <- anyDuplicated(links)

  !as.logical(dup_idx)
}
```

#### Complete Mapping Weights

```{r fnc-flag-weights}
#' df has complete weights
#'
has_complete_weights <- function(df, from, weights){
  sum_w <- tapply(df[[weights]], df[[from]], sum, simplify = TRUE)

  all(sum_w == 1)
}
```

#### Tests

```{r}
testthat::test_that(
  "xmap validation helpers work as expected on valid df",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                           "A1", "B01", 1,
                           "A2", "B02", 1,
                           "A3", "B02", 1,
                           "A4", "B03", 0.67,
                           "A4", "B04", 0.33)
    testthat::expect_true(has_no_NA(df))
    testthat::expect_true(has_no_dup_links(df, "from", "to"))
    testthat::expect_true(has_complete_weights(df, "from", "weights"))
  }
)

testthat::test_that(
  "xmap validation helpers catch invalid df",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                          "A1", "B01", 1,
                          "A2", "B02", 0.3,
                          "A2", "B02", 0.5)
    testthat::expect_false(has_complete_weights(df, "from", "weights"))
    testthat::expect_false(has_no_dup_links(df, "from", "to"))
    df <- tibble::add_row(df, from = "A3", to = NA, weights = NA)
    testthat::expect_false(has_no_NA(df))
  }
)
```

### Master Validator

```{r xmap-validator}
#' A Validator for `xmap` objects
#'
#' @param x An `xmap` to be validated
#'
#' @return `x` if validation passes. Throws error otherwise.
#' @export
#'
#' @examples
validate_xmap <- function(x){
  df <- data.frame(x) # unclass(x)
  x_attrs <- attributes(x)
  col_attrs <- simplify2array(x_attrs[startsWith(names(x_attrs), "col")])
  
  ## ---- df attributes ----
  ## dimension check
  if (ncol(df) != 3) {
    rlang::abort(
      message = "`x` must only have the three columns: from, to, weights",
      class = "xmap_ncol"
    )
  }

  ## cols present
  missing_cols <- setdiff(names(df), col_attrs)
  if (length(missing_cols) != 0){
    cli::cli_abort(
      message = "The column{?s} `{missing_cols}` {?was/were} not found in `x`.",
      class = "xmap_col_not_found"
    )
  }

  ## col type validation
  if (!is.numeric(df[, x_attrs$col_weights])) {
    rlang::abort(
      message = "`col_weights` column in `x` should be numeric",
      class = "xmap_col_type"
    )
  }

  ## ---- xmap graph properties ----

  ## no missingness
  if (!has_no_NA(df)){
    cli::cli_abort(
      message = "NA values found. Please enter missing data and/or convert NA weights",
      class = "xmap_missing"
    )
  }

  ## no duplicate links
  if (!has_no_dup_links(df, x_attrs$col_from, x_attrs$col_to)){
    cli::cli_abort(
      message = "Duplicate `from`-`to` links were found. Please remove or collapse duplicates.",
      class = "xmap_dup"
    )
  }

  ## complete weight check
  if(!has_complete_weights(df, x_attrs$col_from, x_attrs$col_weights)){
    cli::cli_abort(
      message = "Incomplete mapping weights found. Check sum of weights for each `from` group sums to 1",
      class = "xmap_weights"
    )
  }
}
```

Tests go here:

```{r test-validator-success}
testthat::test_that(
  "validate_xmap() accepts well-formed xmaps",
  {
    df <- tibble::tribble(~node_A, ~node_B, ~w_AB,
                           "A1", "B01", 1,
                           "A2", "B02", 1,
                           "A3", "B02", 1,
                           "A4", "B03", 0.25,
                           "A4", "B04", 0.75)
    x <- new_xmap(df, from = "node_A", to = "node_B", weights = "w_AB")
    testthat::expect_invisible(validate_xmap(x))
  }
)
```

```{r test-validator-malformed}
## dimension check
testthat::test_that(
  "validate_xmap() rejects too few/many columns",
  {
    big_x <- data.frame(matrix(data = 1, nrow = 3, ncol = 4))
    little_x <- data.frame(matrix(data = 1, nrow = 3, ncol = 2))

    testthat::expect_error(validate_xmap(big_x), class = "xmap_ncol")
    testthat::expect_error(validate_xmap(little_x), class = "xmap_ncol")
  }
)

## columns present
testthat::test_that(
  "validate_xmap() rejects missing columns",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                           "A1", "B01", 1)
    x <- new_xmap(df,
                  from = "from",
                  to = "missing_col",
                  weights = "weights")
    testthat::expect_error(validate_xmap(x),
                           class = "xmap_col_not_found")
  }
)

## column type
testthat::test_that(
  "validate_xmap() rejects non-numeric weight columns",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                           "A1", "B01", 1,
                           "A4", "B03", 0.25,
                           "A4", "B04", 0.75)
    x <- new_xmap(df,from = "from",to = "to",weights = "weights") |>
      dplyr::mutate(weights = as.character(weights))
    testthat::expect_error(validate_xmap(x),
                           class = "xmap_col_type")
  }
)

## any NA values
testthat::test_that(
  "validate_xmap() rejects missing values",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                          "A1", "B2", NA,
                          NA, "B2", NA,
                          "A3", "B1", 1)
    x <- new_xmap(df,from = "from",to = "to",weights = "weights")
    testthat::expect_error(validate_xmap(x), class = "xmap_missing")
  }
)

## duplicate links
testthat::test_that(
  "validate_xmap() rejects duplicate from-to links",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                          "A1", "B02", 0.3,
                          "A1", "B02", 1)
    x <- new_xmap(df, from="from", to="to", weights="weights")
    testthat::expect_error(validate_xmap(x), class = "xmap_dup")
  }
)

## complete weights
testthat::test_that(
  "validate_xmap() rejects invalid weights",
  {
    df <- tibble::tribble(~from, ~to, ~weights,
                          "A1", "B01", 0.4,
                          "A1", "B02", 0.59)
    x <- new_xmap(df, from="from", to="to", weights="weights")
    testthat::expect_error(validate_xmap(x), class = "xmap_weights")
  }
)
```

### Helpers

#### User Friendly Constructor

-   checks for:
    -   existence of columns
-   warns for:
    -   dropping extra columns (anything other than `from`, `to`, `weights`)
    -   coercing `from` and `to` columns into factor
-   throws errors for:
    -   any validation failures

```{r}
#' `xmap` data.frame
#' 
#' This creates a valid crossmap which can be used to map numeric values `from` a set of source nodes `to` a set of target nodes.
#' 
#' @param x
#'  * For `xmap()`: A data.frame or data.frame-like object
#'  * For `is_xmap()`: An object to test.
#' @param from,to Columns in `.df` specifying the source and target nodes
#' @param weights Column in `.df` specifying the weight applied to data passed along the directed link between source and target node
#' 
#' @return An `xmap` S3 object.
#' 
xmap <- function(x) {
  ## coercions
  
  ## construction
  
  ## validation
}
```

#### Class Test

```{r}
#' @export
#' @rdname xmap
is_xmap <- function(x) {
  inherits(x, "crossmap_xmap")
}
```

## Class: Grouped Crossmap

A grouped variant of `xmap` is needed to facilitate multi-map workflows. However, it is not obvious how such a class should be implemented. Any implemented experiments should go here, otherwise discussion lives in this [GitHub Issue](https://github.com/cynthiahqy/conformr-project/issues/53).

## S3 Methods

### print.xmap()

Can I make it print like?

    src_node -- weights --> target_node

## Package Creation

We finish by running commands that will document, build, and install the package. It may also be a good idea to check the package from within this file.

```{r}
rm(list = ls())
litr::document() # <-- use instead of devtools::document()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```

[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 C. Huang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/making-xmaps.html","id":"nomenclature-crossmaps","dir":"Articles","previous_headings":"","what":"Nomenclature Crossmaps","title":"Making Valid Crossmaps","text":"(Nomenclature) Crossmap encodes complete redistribution values source target classifications directed, bipartite, weighted graph. Numeric values transformed using valid Crossmap sum total source target classifications. valid Crossmap satisfies following conditions: one link distinct source target node source node, sum weights attached outgoing links sums one.","code":""},{"path":"/articles/making-xmaps.html","id":"types-of-crossmap-transformations","dir":"Articles","previous_headings":"","what":"Types of Crossmap Transformations","title":"Making Valid Crossmaps","text":"outgoing incoming properties graph links determine type data transformation encoded given crossmap. Recode: Maps one--one relations recode category labels, leaving attached values untouched Split: Maps least one set fractional (one--many) links involve redistribution source values. Collapse: Maps least one set many--one/one--many links (.e. multiple source categories collapsed single target category) involve kind aggregation source values.","code":""},{"path":"/articles/making-xmaps.html","id":"crossmap-tables-xmap_df","dir":"Articles","previous_headings":"Types of Crossmap Transformations","what":"Crossmap tables: xmap_df","title":"Making Valid Crossmaps","text":"xmap_df data.frame representation Crossmap, row represents weighted link source target classifications. can create xmap_df data.frame tibble weighted edges using as_xmap_df(). input table x needs least 3 complete (.e. NA) columns: : source classification labels. : target classification labels weights: applied values source classification Additional columns (e.g. label descriptions etc.) can retained using .keep_all argument. as_xmap_df() validate x: duplicates -pairs, Every group weights associated distinct value sums 1 (subject minor floating point errors).","code":""},{"path":[]},{"path":"/articles/making-xmaps.html","id":"row-wise-creation","dir":"Articles","previous_headings":"Creating Crossmaps Tables","what":"Row-wise creation","title":"Making Valid Crossmaps","text":"following example shows encode one--one, many--one one--many links coerce xmap_df. method suitable simple crossmaps.","code":"library(xmap)  simple_x <- tibble::tribble(   ~source, ~target, ~share,   \"equal\", \"EQUAL\", 1,       # one-to-one   \"member_1\", \"GROUP\", 1,    # many-to-one   \"member_2\", \"GROUP\", 1,   \"whole\", \"PART_1\", 0.3,    # one-to-many   \"whole\", \"PART_2\", 0.6,   \"whole\", \"PART_3\", 0.1 )  simple_xmap <- simple_x |>   as_xmap_df(from = source, to = target, weights = share)  simple_xmap ## xmap_df: ## recode, split, and collapse   ## (source -> target) BY share ##     source target share ## 1    equal  EQUAL   1.0 ## 2 member_1  GROUP   1.0 ## 3 member_2  GROUP   1.0 ## 4    whole PART_1   0.3 ## 5    whole PART_2   0.6 ## 6    whole PART_3   0.1"},{"path":"/articles/making-xmaps.html","id":"coercion-from-crosswalks","dir":"Articles","previous_headings":"Creating Crossmaps Tables","what":"Coercion from Crosswalks","title":"Making Valid Crossmaps","text":"common want convert existing correspondence crossmap. conversions require attaching appropriate weights existing crosswalk table.","code":""},{"path":"/articles/making-xmaps.html","id":"recode-maps","dir":"Articles","previous_headings":"Creating Crossmaps Tables > Coercion from Crosswalks","what":"Recode maps","title":"Making Valid Crossmaps","text":"Consider first five country codes ISO 3166 international standard one--one correspondence 2-digit, 2-digit numeric codes. create crossmap ISONumeric ISO2, simply add weights columns coerce xmap_df: Notice as_xmap_df() always place , weights columns order drops additional columns passed . can also easily generate crossmaps nomenclature table:","code":"iso_codes <- tibble::tribble(               ~country, ~ISO2, ~ISO3, ~ISONumeric,          \"Afghanistan\",          \"AF\",         \"AFG\",    \"004\",              \"Albania\",          \"AL\",         \"ALB\",    \"008\",              \"Algeria\",          \"DZ\",         \"DZA\",    \"012\",       \"American Samoa\",          \"AS\",         \"ASM\",    \"016\",              \"Andorra\",          \"AD\",         \"AND\",    \"020\"       ) iso_xmap <- iso_codes |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = ISONumeric, to = ISO2, weights = link) ## Dropped additional columns in `dplyr::mutate(iso_codes, link = 1)` print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY link ##   ISONumeric ISO2 link ## 1        004   AF    1 ## 2        008   AL    1 ## 3        012   DZ    1 ## 4        016   AS    1 ## 5        020   AD    1 iso_codes |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = ISO2, to = ISO3, weights = link) ## Dropped additional columns in `dplyr::mutate(iso_codes, link = 1)` ## xmap_df: ## recode  ## (ISO2 -> ISO3) BY link ##   ISO2 ISO3 link ## 1   AF  AFG    1 ## 2   AL  ALB    1 ## 3   DZ  DZA    1 ## 4   AS  ASM    1 ## 5   AD  AND    1"},{"path":"/articles/making-xmaps.html","id":"collapse-maps-aggregation","dir":"Articles","previous_headings":"Creating Crossmaps Tables > Coercion from Crosswalks","what":"Collapse maps: Aggregation","title":"Making Valid Crossmaps","text":"Now consider aggregating data collected using ISO 3166-2 Subdivisions Australia Canada: Recall need one row per relation source (adm1) target (ctr) nomenclature. Thus split string list vector, unnest values country. Since aggregation involves one--one transfer values adm1 ctr prior collapsing ctr groups, simple add weights one form valid crossmap:","code":"adm1_list <- tibble::tribble(   ~ctr, ~adm1,   \"AU\", \"AU-NSW, AU-QLD, AU-SA, AU-TAS, AU-VIC, AU-WA, AU-ACT, AU-NT\",   \"CA\", \"CA-AB, CA-BC, CA-MB, CA-NB, CA-NL, CA-NS, CA-ON, CA-PE, CA-QC, CA-SK, CA-NT, CA-NU, CA-YT\" ) agg_x <- adm1_list |>    dplyr::mutate(adm1 = stringr::str_split(adm1, \", \")) |>   tidyr::unnest(cols = c(adm1))  agg_x ## # A tibble: 21 × 2 ##    ctr   adm1   ##    <chr> <chr>  ##  1 AU    AU-NSW ##  2 AU    AU-QLD ##  3 AU    AU-SA  ##  4 AU    AU-TAS ##  5 AU    AU-VIC ##  6 AU    AU-WA  ##  7 AU    AU-ACT ##  8 AU    AU-NT  ##  9 CA    CA-AB  ## 10 CA    CA-BC  ## # … with 11 more rows agg_xmap <- agg_x |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = adm1, to = ctr, weights = link)  agg_xmap ## xmap_df: ## recode and collapse   ## (adm1 -> ctr) BY link ##      adm1 ctr link ## 1  AU-NSW  AU    1 ## 2  AU-QLD  AU    1 ## 3   AU-SA  AU    1 ## 4  AU-TAS  AU    1 ## 5  AU-VIC  AU    1 ## 6   AU-WA  AU    1 ## 7  AU-ACT  AU    1 ## 8   AU-NT  AU    1 ## 9   CA-AB  CA    1 ## 10  CA-BC  CA    1 ## 11  CA-MB  CA    1 ## 12  CA-NB  CA    1 ## 13  CA-NL  CA    1 ## 14  CA-NS  CA    1 ## 15  CA-ON  CA    1 ## 16  CA-PE  CA    1 ## 17  CA-QC  CA    1 ## 18  CA-SK  CA    1 ## 19  CA-NT  CA    1 ## 20  CA-NU  CA    1 ## 21  CA-YT  CA    1"},{"path":"/articles/making-xmaps.html","id":"split-maps-disaggregation","dir":"Articles","previous_headings":"Creating Crossmaps Tables > Coercion from Crosswalks","what":"Split maps: Disaggregation","title":"Making Valid Crossmaps","text":"Conversely, might aggregate level data want disaggregate. Continuing example, involve incorporating country level data analysis 3166-2 Subdivisions level. example, imagine population figures Australia 3166-2 level 9 10 years, country level figures missing year. simple example, reasonable harmonisation design involve splitting country level figure subdivision level population proportions year preceding following missing year. Alternatively, might want compare aggregate disaggregate statistics identify discrepancies. Using Australian population statistics 30 Jun 20221","code":"state_data <- tibble::tribble(                               ~state,    ~adm1,    ~Pop,                    \"New South Wales\", \"AU-NSW\", 8153600,                           \"Victoria\", \"AU-VIC\", 6613700,                         \"Queensland\", \"AU-QLD\", 5322100,                    \"South Australia\",  \"AU-SA\", 1820500,                  \"Western Australia\",  \"AU-WA\", 2785300,                           \"Tasmania\", \"AU-TAS\",  571500,                 \"Northern Territory\",  \"AU-NT\",  250600,       \"Australian Capital Territory\", \"AU-ACT\",  456700 )  state_xmap <- state_data |>   dplyr::mutate(ctr = \"AU\",                 adm1,                 share = Pop / sum(Pop)) |>   as_xmap_df(from = ctr, to = adm1, weights = share) ## Dropped additional columns in `dplyr::mutate(state_data, ctr = \"AU\", adm1, ## share = Pop/sum(Pop))` state_xmap ## xmap_df: ## split  ## (ctr -> adm1) BY share ##   ctr   adm1      share ## 1  AU AU-NSW 0.31391391 ## 2  AU AU-VIC 0.25462770 ## 3  AU AU-QLD 0.20490105 ## 4  AU  AU-SA 0.07008932 ## 5  AU  AU-WA 0.10723416 ## 6  AU AU-TAS 0.02200277 ## 7  AU  AU-NT 0.00964811 ## 8  AU AU-ACT 0.01758297"},{"path":"/articles/making-xmaps.html","id":"mixed-maps","dir":"Articles","previous_headings":"Creating Crossmaps Tables","what":"Mixed Maps","title":"Making Valid Crossmaps","text":"Now consider following mixed transformation using selected correspondences NAICS Canada 1997 ISIC Revision 3. Imagine numeric data (e.g. gross output CAD) collected NAICS Canada nomenclature want harmonise ISIC Revision 3. correspondence two nomenclature contains mixture one--one, one--many, many--one many--many relations. Luckily, need deal two cases forming crossmap: links unit weights (recode collapse) , links fractional weights (split). Let’s first define example correspondences.2 first example, one NAICS Canada class relates exactly one ISIC class. second example, one ISIC class equivalent one NAICS Canada class. asterisk (Partial Flag) indicates part ISIC D1543 equivalent NAICS Canada class. ISIC activities corresponding NAICS Canada class listed column labelled “Link”. third example, one NAICS Canada class equivalent one ISIC class.","code":"canada_recode <- tibble::tibble(   NAICS1997      = \"212210\",    NAICS1997_desc = \"Iron Ore Mining\",   ISIC3          = \"C1310\",   ISIC3_desc    = \"Mining of iron ores\" ) canada_agg <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"311320\", \"Chocolate and Confectionery Manufacturing from Cacao Beans\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Chocolate and confectionery, made from cacao beans\",   \"311330\", \"Confectionery Manufacturing from Purchased Chocolate\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Confectionery, made from purchased chocolate\",   \"311340\", \"Non-Chocolate Confectionery Manufacturing\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Non-chocolate confectionery, manufacturing\" ) ## # A tibble: 3 × 5 ##   NAICS1997 NAICS1997_desc                                   ISIC3 ISIC3…¹ Link  ##   <chr>     <chr>                                            <chr> <chr>   <chr> ## 1 311320    Chocolate and Confectionery Manufacturing from … D154… Manufa… Choc… ## 2 311330    Confectionery Manufacturing from Purchased Choc… D154… Manufa… Conf… ## 3 311340    Non-Chocolate Confectionery Manufacturing        D154… Manufa… Non-… ## # … with abbreviated variable name ¹​ISIC3_desc canada_split <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6110 *\", \"Sea and coastal water transport\", \"Intracoastal water transportation\",   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6120 *\", \"Inland water transport\", \"Inland water transportation (except ferries)\" ) ## # A tibble: 2 × 5 ##   NAICS1997 NAICS1997_desc                                  ISIC3  ISIC3…¹ Link  ##   <chr>     <chr>                                           <chr>  <chr>   <chr> ## 1 483213    Inland Water Transportation (except by Ferries) I6110… Sea an… Intr… ## 2 483213    Inland Water Transportation (except by Ferries) I6120… Inland… Inla… ## # … with abbreviated variable name ¹​ISIC3_desc"},{"path":"/articles/making-xmaps.html","id":"unit-weight-links","dir":"Articles","previous_headings":"Creating Crossmaps Tables > Mixed Maps","what":"Unit weight links","title":"Making Valid Crossmaps","text":"Notice recode collapse category relations, values attached source category directly modified “transfer” source target nomenclature. Instead, source values either retained, summarised category collapse (value aggregation) performed. Thus, shown , recode collapse links weight one. Let’s clean recode collapse links defined :","code":"canada_unit <- canada_agg |>   # remove the partial flag (*)   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   # bind the links together and add weights   dplyr::bind_rows(canada_recode) |>   dplyr::mutate(share = 1)  canada_unit ## # A tibble: 4 × 5 ##   NAICS1997 NAICS1997_desc                                   ISIC3 ISIC3…¹ share ##   <chr>     <chr>                                            <chr> <chr>   <dbl> ## 1 311320    Chocolate and Confectionery Manufacturing from … D1543 Manufa…     1 ## 2 311330    Confectionery Manufacturing from Purchased Choc… D1543 Manufa…     1 ## 3 311340    Non-Chocolate Confectionery Manufacturing        D1543 Manufa…     1 ## 4 212210    Iron Ore Mining                                  C1310 Mining…     1 ## # … with abbreviated variable name ¹​ISIC3_desc"},{"path":"/articles/making-xmaps.html","id":"fractional-weight-links","dir":"Articles","previous_headings":"Creating Crossmaps Tables > Mixed Maps","what":"Fractional weight links","title":"Making Valid Crossmaps","text":"Now remains prepare split links. Similar disaggregation example , need design weights allocate “pool” numeric value associated NAICS class 483213 corresponding ISIC classes I6110 I6120. Assume illustration purposes Canadian “Inland water transport” industry (I6120) twice big “Sea coastal water transport” industry (I6110). suggests weight 483213 I6120 twice I6110. Now let’s combine unit fractional links crossmap:","code":"canada_frac <- canada_split |>   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   dplyr::mutate(share = dplyr::case_when(ISIC3 == \"I6110\" ~ 0.33,                                   ISIC3 == \"I6120\" ~ 0.67,                                   T ~ NA_real_)) canada_xmap <- dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = NAICS1997, to = ISIC3, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` print(canada_xmap) ## xmap_df: ## recode, split, and collapse   ## (NAICS1997 -> ISIC3) BY share ##   NAICS1997 ISIC3 share ## 1    311320 D1543  1.00 ## 2    311330 D1543  1.00 ## 3    311340 D1543  1.00 ## 4    212210 C1310  1.00 ## 5    483213 I6110  0.33 ## 6    483213 I6120  0.67"},{"path":"/articles/making-xmaps.html","id":"one-way-crossmaps","dir":"Articles","previous_headings":"","what":"One-Way Crossmaps","title":"Making Valid Crossmaps","text":"Except case recoding, crossmaps generally lateral (one-way). Weights collapse split links longer valid reverse direct link. Notice as_xmap_df() throws error try naively swap arguments: However, can swap arguments recode map. Recall ISO country code crossmap created : Imagine instead converting country codes ISO Numeric ISO-2 digit, wanted convert ISO-2 digit ISO Numeric. can take existing crossmap invert without editing weights:","code":"dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = ISIC3, to = NAICS1997, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` ## Error in `df_check_weights()`: ## ! Incomplete mapping weights found. Check sum of weights for each `from` ##   group sums to 1 print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY link ##   ISONumeric ISO2 link ## 1        004   AF    1 ## 2        008   AL    1 ## 3        012   DZ    1 ## 4        016   AS    1 ## 5        020   AD    1 iso_xmap |>   xmap_reverse() ## xmap_df: ## recode  ## (ISO2 -> ISONumeric) BY r_weights ##   ISO2 ISONumeric r_weights ## 1   AF        004         1 ## 2   AL        008         1 ## 3   DZ        012         1 ## 4   AS        016         1 ## 5   AD        020         1"},{"path":[]},{"path":"/articles/using-xmaps.html","id":"table-joins-single-variable","dir":"Articles","previous_headings":"Nomenclature Transformation","what":"Table Joins (single variable)","title":"Using Crossmaps to Transform Data","text":"vignette illustrates simple examples crossmaps can used complete recode, split collapse transformation.","code":""},{"path":"/articles/using-xmaps.html","id":"aggregation","dir":"Articles","previous_headings":"Nomenclature Transformation > Table Joins (single variable)","what":"Aggregation","title":"Using Crossmaps to Transform Data","text":"Let’s consider simple case disaggregated population figures want aggregate. First, define crossmap aggregation. Second, load state-level figures Now, assuming crossmap fully covers data transformation involves two steps: Joining aggregate group row state_data Summarising values group using apply_xmap() conformr package: also checks nomenclature data_in fully covered xmap – .e. don’t lose rows join.","code":"library(xmap)  agg_map <- data.frame(ctr = \"AU\",                       adm1 = c(\"AU-NSW\", \"AU-QLD\", \"AU-SA\", \"AU-TAS\", \"AU-VIC\", \"AU-WA\", \"AU-ACT\", \"AU-NT\"),                       link = 1) |>   as_xmap_df(adm1, ctr, link) state_data <- tibble::tribble(                               ~state,    ~adm1,    ~Pop,                    \"New South Wales\", \"AU-NSW\", 8153600,                           \"Victoria\", \"AU-VIC\", 6613700,                         \"Queensland\", \"AU-QLD\", 5322100,                    \"South Australia\",  \"AU-SA\", 1820500,                  \"Western Australia\",  \"AU-WA\", 2785300,                           \"Tasmania\", \"AU-TAS\",  571500,                 \"Northern Territory\",  \"AU-NT\",  250600,       \"Australian Capital Territory\", \"AU-ACT\",  456700 ) dplyr::left_join(state_data, agg_map, by = c(\"adm1\")) |>   dplyr::mutate(x_pop = Pop * link) |>   dplyr::group_by(ctr) |>   dplyr::summarise(agg_pop = sum(x_pop)) ## # A tibble: 1 × 2 ##   ctr    agg_pop ##   <chr>    <dbl> ## 1 AU    25974000 conformr::apply_xmap(data_in = state_data, xmap = agg_map,                      in_codes = adm1, in_values = Pop,                      out_codes = NULL, out_values = NULL)"},{"path":"/articles/using-xmaps.html","id":"disaggregation","dir":"Articles","previous_headings":"Nomenclature Transformation > Table Joins (single variable)","what":"Disaggregation","title":"Using Crossmaps to Transform Data","text":"can reverse aggregation (assuming retained appropriate weights) using:","code":"apply_xmap(data_in = ctr_data, xmap = disagg_map, in_codes = ctr, in_values = Pop, out_codes = NULL, out_values = NULL)"},{"path":"/articles/using-xmaps.html","id":"complex-maps","dir":"Articles","previous_headings":"Nomenclature Transformation > Table Joins (single variable)","what":"Complex Maps","title":"Using Crossmaps to Transform Data","text":"Using crossmaps recoding, aggregation disaggregation can seem bit tedious given can achieve transformation simple join mutate statements, coupled ad-hoc validation. However, crossmpas best suited cases multiple types transformations applied .","code":""},{"path":[]},{"path":"/articles/vis-xmaps.html","id":"alternative-representations-of-crossmaps","dir":"Articles","previous_headings":"","what":"Alternative representations of Crossmaps","title":"Visualising Crossmap Transformations","text":"Crossmaps aim encode dataset integration harmonisation choices separately code used apply designs data. follows visualisations plots candidate crossmaps useful design process. instance, Sankey diagrams sometimes used visualise schema crosswalks. article provides ggplot2 code examples visualising crossmaps. code eventually live ggplot2 extension package.","code":"library(ggplot2) library(dplyr) library(ggbump) library(xmap)"},{"path":"/articles/vis-xmaps.html","id":"table","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Table","title":"Visualising Crossmap Transformations","text":"Let’s start visualising section ANZSCO22 ISCO8 crosswalk published Australian Bureau Statistics: included print() method xmap_df objects:","code":"anzsco_cw <- tibble::tribble(       ~anzsco22,                        ~anzsco22_descr, ~isco8, ~partial,                                         ~isco8_descr,        \"111111\", \"Chief Executive or Managing Director\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111111\", \"Chief Executive or Managing Director\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111111\", \"Chief Executive or Managing Director\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111211\",            \"Corporate General Manager\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111211\",            \"Corporate General Manager\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111211\",            \"Corporate General Manager\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111212\",         \"Defence Force Senior Officer\", \"0110\",      \"p\",                 \"Commissioned armed forces officers\",        \"111311\",          \"Local Government Legislator\", \"1111\",      \"p\",                                        \"Legislators\",        \"111312\",                 \"Member of Parliament\", \"1111\",      \"p\",                                        \"Legislators\",        \"111399\",                      \"Legislators nec\", \"1111\",      \"p\",                                        \"Legislators\"       )  links <- anzsco_cw |>   dplyr::group_by(anzsco22) |>   dplyr::summarise(n_dest = dplyr::n_distinct(isco8)) |>   dplyr::ungroup() |>   dplyr::transmute(anzsco22, weight = 1/n_dest) |>   dplyr::left_join(anzsco_cw, by = \"anzsco22\")  ## get code tables table_anzsco <- anzsco_cw |>   dplyr::distinct(anzsco22, anzsco22_descr) table_isco8 <- anzsco_cw |>   dplyr::distinct(isco8, isco8_descr)  ## make xmap anzsco_xmap <- links |>   as_xmap_df(anzsco22, isco8, weight) ## Dropped additional columns in `links` print(anzsco_xmap) ## xmap_df: ## recode, split, and collapse   ## (anzsco22 -> isco8) BY weight ##    anzsco22 isco8    weight ## 1    111111  1112 0.3333333 ## 2    111111  1114 0.3333333 ## 3    111111  1120 0.3333333 ## 4    111211  1112 0.3333333 ## 5    111211  1114 0.3333333 ## 6    111211  1120 0.3333333 ## 7    111212  0110 1.0000000 ## 8    111311  1111 1.0000000 ## 9    111312  1111 1.0000000 ## 10   111399  1111 1.0000000"},{"path":"/articles/vis-xmaps.html","id":"bigraph","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Bigraph","title":"Visualising Crossmap Transformations","text":"Visualisation bigraph particularly useful seeing relations two nomenclature.  visualisation also benefits traditionally used Sankey diagram. Sankey diagrams often used illustrated “flows” nodes. However, variable link widths can actually clutter visualisation crosswalks. Consider simple crossmap might used harmonise national accounts data (e.g. GDP) across two time periods.  hand, bigraph visualisation shows clearly data modified () harmonising nomenclature. solid lines show link modify source values, whilst dotted line style indicates data split . Furthermore, using fixed width links, room place labels -top curve indicated transformation weights.","code":"plt_xmap_bigraph <- function(x, ...) {   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_short <- tibble::as_tibble(x)      ## generate out link type   style_out_case <- tibble::tribble(     ~out_case, ~line_type, ~font_type,     \"unit_out\", \"solid\", \"bold\",     \"frac_out\", \"dashed\", \"italic\")   df_out_style <- edges_short |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"unit_out\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"frac_out\")) |>     dplyr::left_join(style_out_case,               by = \"out_case\") |>     dplyr::ungroup()      ## attach node positions   from_nodes <- tibble::tibble(from_set = x_attrs$from_set) |>     dplyr::mutate(from_y = dplyr::row_number())   to_nodes <- tibble::tibble(to_set = unique(x[[x_attrs$col_to]])) |>     dplyr::mutate(to_y = dplyr::row_number() - 1 + 0.5)   df_gg <- df_out_style |>     dplyr::left_join(from_nodes, by = setNames(\"from_set\", x_attrs$col_from)) |>     dplyr::left_join(to_nodes, by = setNames(\"to_set\", x_attrs$col_to)) |>     dplyr::mutate(from_x = 0,                   to_x = 5) |>     dplyr::mutate(idx = dplyr::row_number())      ## build ggplot   ggplot2::ggplot(data = df_gg,                   aes(x = from_x, xend = to_x,                       y = from_y, yend = to_y,                       group = idx)) +     ## edges     ggbump::geom_sigmoid(aes(linetype = I(line_type))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"unit_out\"),              aes(x = (from_x + to_x) / 4,                  y = from_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"frac_out\"),              aes(x = (((from_x + to_x) / 2) + to_x) / 2,                  y = to_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ## from nodes     ggplot2::geom_text(aes(x = from_x - 0.5, y = from_y,                            label = .data[[x_attrs$col_from]],                            fontface=I(font_type)),                       ## drop idx groups to avoid duplicate labels                       stat = \"unique\", inherit.aes = FALSE) +     ## to nodes     ggplot2::geom_label(aes(x = to_x + 0.5, y = to_y,                              label = .data[[x_attrs$col_to]]),                         fill = \"black\",                         alpha = 0.1) +     ggplot2::scale_y_reverse() +     ggplot2::theme_minimal() +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank(),         axis.text.y = element_blank(),         axis.text.x = element_blank(),         plot.background = element_rect(fill = \"white\")) +     labs(x = NULL, y = NULL) } edges <- tribble(~ctr, ~ctr2, ~split,                  \"BLX\", \"BEL\", 0.5,                  \"BLX\", \"LUX\", 0.5,                  \"E.GER\", \"DEU\", 1,                  \"W.GER\", \"DEU\", 1)"},{"path":"/articles/vis-xmaps.html","id":"matrix","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Matrix","title":"Visualising Crossmap Transformations","text":"Another useful visualisation representation crossmap incidence matrix source nomenclature indexed along rows target nomenclature indexed columns: Notice requirement valid crossmap outgoing weights sum 1 source node equivalent requirement total weights across row sums 1.","code":"plt_xmap_ggmatrix <- function(x, ...){   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_complete <- tibble::as_tibble(x) |>      tidyr::complete(.data[[x_attrs$col_from]], .data[[x_attrs$col_to]])      ## add link-out type   gg_df <- edges_complete |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"one-to-one\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"one-to-many\",                                               is.na(.data[[x_attrs$col_weights]]) ~ \"none\")                   )      ## make plot   gg_df |> ggplot(aes(x=.data[[x_attrs$col_to]],                       y=.data[[x_attrs$col_from]])) +     geom_tile(aes(fill=out_case), col=\"grey\") +     scale_y_discrete(limits=rev) +     scale_x_discrete(position='top') +     scale_fill_brewer() +     coord_fixed()  +     labs(x = x_attrs$col_to, y = x_attrs$col_from, fill=\"Outgoing Link Type\") +     theme_minimal() +     geom_text(data = dplyr::filter(gg_df, !is.na(.data[[x_attrs$col_weights]])), aes(label=round(.data[[x_attrs$col_weights]], 2))) +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()     ) } plt_xmap_ggmatrix(anzsco_xmap)"},{"path":"/articles/xmap.html","id":"creating-an-xmap-object","dir":"Articles","previous_headings":"","what":"Creating an xmap object","title":"Crossmaps for Data Transformation in R","text":"already valid crossmap table, turn xmap object specifying source () nodes, target () nodes, weights (weights): See vignette(\"making-xmaps.Rmd\") details validation conditions creating custom weights.","code":"links |>   as_xmap(from = ISIC2, to = ISIC3, weights = shares)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cynthia Huang. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huang C (2023). xmap: xmap: data-structure extending crosswalks. R package version 0.0.0.9014.","code":"@Manual{,   title = {xmap: xmap: A data-structure for extending crosswalks},   author = {Cynthia Huang},   year = {2023},   note = {R package version 0.0.0.9014}, }"},{"path":"/index.html","id":"xmap-crossmaps-for-data-integration-in-r","dir":"","previous_headings":"","what":"xmap: A data-structure for extending crosswalks","title":"xmap: A data-structure for extending crosswalks","text":"xmap provides tools creating, validating modifying Nomenclature Crossmaps use Data Integration Harmonisation workflows (.e. {conformr}).","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"xmap: A data-structure for extending crosswalks","text":"install latest development version xmap:","code":"remotes::install_github(\"cynthiahqy/conformr-project\", subdir = \"xmap\")"},{"path":"/reference/as_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if object is a crossmap — as_xmap_df.data.frame","title":"Test if object is a crossmap — as_xmap_df.data.frame","text":"function returns TRUE crossmaps xmap subclasses thereof (xmap_df), FALSE objects, including regular data.frames tibbles.","code":""},{"path":"/reference/as_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if object is a crossmap — as_xmap_df.data.frame","text":"","code":"# S3 method for data.frame as_xmap_df(x, from, to, weights, subclass = \"xmap_df\", .keep_all = FALSE)  is_xmap(x)  is_xmap_df(x)"},{"path":"/reference/as_xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Test if object is a crossmap — as_xmap_df.data.frame","text":"as_xmap_df(data.frame): Coerce data.frame xmap","code":""},{"path":"/reference/as_xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if object is a crossmap — as_xmap_df.data.frame","text":"","code":"# For a well formed crossmap: links <- data.frame(   a = \"AUS\",   b = c(\"VIC\", \"NSW\", \"WA\", \"OTHER\"),   w = c(0.1, 0.15, 0.25, 0.5) ) as_xmap_df(links, from = a, to = b, weights = w) #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50  # extra columns are dropped, links$extra <- c(2, 4, 5, 6) as_xmap_df(links, from = a, to = b, weights = w) #> Dropped additional columns in `links` #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50"},{"path":"/reference/as_xmap_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce objects to xmap — as_xmap_df","title":"Coerce objects to xmap — as_xmap_df","text":"Validates creates valid crossmap xmap object type input.","code":""},{"path":"/reference/as_xmap_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce objects to xmap — as_xmap_df","text":"","code":"as_xmap_df(x, from, to, weights, subclass = c(\"xmap_df\"), ...)"},{"path":"/reference/as_xmap_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce objects to xmap — as_xmap_df","text":"x as_xmap(): object coerce is_xmap(): object test. , Columns x specifying source target nodes weights Column x specifying weight applied data passed along directed link source target node subclass xmap subclass return. Defaults xmap_df data.frame tibble","code":""},{"path":"/reference/as_xmap_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce objects to xmap — as_xmap_df","text":"validated xmap object.","code":""},{"path":"/reference/df_check.html","id":null,"dir":"Reference","previous_headings":"","what":"xmap_df validation helpers — df_check","title":"xmap_df validation helpers — df_check","text":"Checks issues xmap_df object.","code":""},{"path":"/reference/df_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"xmap_df validation helpers — df_check","text":"","code":"df_check_cols(df, col_attrs)  df_check_na(df)  df_check_col_order(df, col_from, col_to, col_weights)  df_check_col_type(df, col_weights)  df_check_from_set(df, col_from, from_set)  df_check_links(df, col_from, col_to)  df_check_weights(df, col_from, col_weights)  df_check_reversible(df, col_to)"},{"path":"/reference/df_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"xmap_df validation helpers — df_check","text":"df data.frame-like object containing crossmap col_* character vector values naming columns df","code":""},{"path":"/reference/df_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"xmap_df validation helpers — df_check","text":"error validation condition fails, invisibly returns df otherwise.","code":""},{"path":"/reference/df_check.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"xmap_df validation helpers — df_check","text":"df_check_cols(): Abort named columns found xmap_df df_check_na(): Abort xmap_df missing values df_check_col_order(): Abort xmap_df columns order df_check_col_type(): Abort xmap_df wrong column types df_check_from_set(): Abort from_set attribute match xmap_df values df_check_links(): Abort xmap_df duplicate links df_check_weights(): Abort df invalid mapping weights df_check_reversible(): Abort xmap_df wrong column types","code":""},{"path":"/reference/new_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Low Level Constructors for xmap subclasses — new_xmap","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"Low Level Constructors xmap subclasses","code":""},{"path":"/reference/new_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"","code":"new_xmap_df(x, col_from, col_to, col_weights, from_set = NULL)"},{"path":"/reference/new_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"x data-frame like object. col_from, col_to, col_weights character strings naming columns containing source nodes, target nodes numeric weights.","code":""},{"path":"/reference/new_xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"xmap_df object. Note function unclasses tibbles. x additional subclasses xmap_df xmap","code":""},{"path":"/reference/new_xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"new_xmap_df(): Construct xmap_df data.frame checks argument types naively generates from_set missing","code":""},{"path":"/reference/op-null-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Defaults for NULL values — op-null-default","title":"Defaults for NULL values — op-null-default","text":"Defaults NULL values","code":""},{"path":"/reference/op-null-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defaults for NULL values — op-null-default","text":"","code":"x %||% y"},{"path":"/reference/print.xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an xmap object — print.xmap","title":"Print an xmap object — print.xmap","text":"Print xmap object","code":""},{"path":"/reference/print.xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an xmap object — print.xmap","text":"","code":"# S3 method for xmap_df print(x)"},{"path":"/reference/print.xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Print an xmap object — print.xmap","text":"print(xmap_df): Print xmap_df","code":""},{"path":"/reference/validate_xmap_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Validator for xmap_df objects — validate_xmap_df","title":"Validator for xmap_df objects — validate_xmap_df","text":"Validator xmap_df objects","code":""},{"path":"/reference/validate_xmap_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validator for xmap_df objects — validate_xmap_df","text":"","code":"validate_xmap_df(x)"},{"path":"/reference/xmap-has.html","id":null,"dir":"Reference","previous_headings":"","what":"Boolean flags for xmap properties — xmap-has","title":"Boolean flags for xmap properties — xmap-has","text":"has_*() is_*() functions check properties used validate /print xmaps. functions accepts equal length vector inputs support subclasses xmap, check inputs xmap.","code":""},{"path":"/reference/xmap-has.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boolean flags for xmap properties — xmap-has","text":"","code":"has_dup_links(x_from, x_to)  has_complete_weights(x_from, x_weights)  has_1to1(x_weights)  has_1toM(x_weights)  has_1fromM(x_to)"},{"path":"/reference/xmap-has.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boolean flags for xmap properties — xmap-has","text":"x_from, x_to, x_weights equal length vectors containing source-target node pairs","code":""},{"path":"/reference/xmap-has.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Boolean flags for xmap properties — xmap-has","text":"has_dup_links(): Returns TRUE xmap duplicate links has_complete_weights(): Returns TRUE xmap valid weights has_1to1(): Return TRUE xmap recodes labels has_1toM(): Return TRUE xmap splitting links has_1fromM(): Return TRUE xmap collapsing links ","code":""},{"path":"/reference/xmap_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse xmap direction — xmap_reverse","title":"Reverse xmap direction — xmap_reverse","text":"Reverse xmap direction","code":""},{"path":"/reference/xmap_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse xmap direction — xmap_reverse","text":"","code":"xmap_reverse(x, weights_into)  # S3 method for xmap_df xmap_reverse(x, weights_into = \"r_weights\")"},{"path":"/reference/xmap_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse xmap direction — xmap_reverse","text":"x xmap object reversed weights_into string specifying name new existing column store reverse weights .","code":""},{"path":"/reference/xmap_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse xmap direction — xmap_reverse","text":"xmap object class x, throws error x reversible","code":""},{"path":"/reference/xmap_reverse.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Reverse xmap direction — xmap_reverse","text":"xmap_reverse(xmap_df): Reverse xmap_df","code":""}]

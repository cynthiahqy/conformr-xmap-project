[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 C. Huang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/making-xmaps.html","id":"introduction-to-crossmaps","dir":"Articles","previous_headings":"","what":"Introduction to Crossmaps","title":"Intro to Crossmaps","text":"(Nomenclature) Crossmap encodes complete redistribution values source target classifications directed, bipartite, weighted graph. Numeric values transformed using valid Crossmap sum total source target classifications. valid Crossmap satisfies following conditions: one link distinct source target node source node, sum weights attached outgoing links sums one. example, mapping occupation codes ANZSCO22 ISCO8 valid crossmap:","code":""},{"path":"/articles/making-xmaps.html","id":"unit-and-fractional-weight-links","dir":"Articles","previous_headings":"Introduction to Crossmaps","what":"Unit and Fractional Weight Links","title":"Intro to Crossmaps","text":"weights associated source-target link encode transformation applied values associated given source node. Let weight source node \\(\\) target node \\(j\\) denoted \\(w_{ij}\\). Weights can range \\([0,1]\\). Note \\(w_{ij} = 0\\) trivial case link source target nodes. non-trivial cases unit weights, \\(w_{ij} = 1\\) fractional weights, \\(w_{ij} \\(0,1)\\). Unit weights indicate source values unmodified passed target nomenclature. Therefore, crosswalks recoding node labels, collapsing multiple sub-category source nodes parent target nodes, can represented crossmaps unit weights. Fractional weights hand indicate source value modified passed target node. example link weight \\(0.7\\) indicates 70% numeric value associated source node “passed ” target node. Now, consider two links source node \\(\\) two different target nodes \\(j\\) \\(k\\), weights \\(w_{ij}\\) \\(w_{ik}\\). Assume source node \\(\\) outgoing links target nomenclature. , follows weights two given links sum one want preserve total value source target nomenclature. instance, \\(w_{ij} = 0.7\\), \\(w_{ik}\\) \\(0.3\\), 70% value associated source node \\(\\) goes target node \\(j\\), remaining 30% distributed target node \\(k\\).","code":""},{"path":"/articles/making-xmaps.html","id":"crossmap-tables","dir":"Articles","previous_headings":"Introduction to Crossmaps","what":"Crossmap tables","title":"Intro to Crossmaps","text":"Crossmap tables extensions crosswalk lookup tables, row represents weighted link source target classifications. can pass data.frame tibble weighted edges verify_links_as_xmap() check input satisfies crossmap properties. input table x needs least 3 complete (.e. NA) columns: : source classification labels. : target classification labels weights: applied values source classification Additional columns (e.g. label descriptions etc.) can retained setting .drop_extra argument FALSE. verify_links_as_xmap as_xmap_df() validate : duplicates -pairs, Every group weights associated distinct value sums 1 (subject floating point tolerance). package also offers experimental xmap_df class facilitate additional functionality graph property calculation printing (.e. relation types crossmap direction) via custom print() method, coercion useful classes (e.g. xmap_to_matrix()), visualisation (see vignette(\"vis-xmaps\") prototypes), multi-step transformations (.e. nomenclature B C). Please note xmap_df class related functions still active development subject breaking changes future releases.","code":""},{"path":"/articles/making-xmaps.html","id":"special-cases-of-crossmaps","dir":"Articles","previous_headings":"","what":"Special Cases of Crossmaps","title":"Intro to Crossmaps","text":"conditions valid nomenclature crossmaps defined sufficient ensure total sum value retained source target nomenclature However, number transformation properties crossmaps can also encode validate. special cases include “degenerate” crossmaps. consider crossmap “degenerate” binary weights possible source-target links. cases weights implied presence absence link.","code":""},{"path":"/articles/making-xmaps.html","id":"types-of-mapping-relations","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Types of Mapping Relations","title":"Intro to Crossmaps","text":"helpful thinking special cases define familiar types relations: one--one: set links pairs source target nodes uniquely linked nodes. links type relation unit weights. one--many: set links single source node linked multiple target nodes. Links “splitting” relation fractional weights. one--many: set links single target node linked multiple source nodes. “collapse” relation commonly known many--one. Links can either unit fractional weights depending whether source nodes part one--one one--many relations. many--many: refers combination relations often used signal correspondence sets one--many splitting relations one--many collapsing relations. Note links crossmap can partitioned subgraphs according number outgoing links (.e. one--one one--many)","code":""},{"path":"/articles/making-xmaps.html","id":"recode-maps","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Recode maps","title":"Intro to Crossmaps","text":"Crossmaps one--one relations recode source labels target labels, leaving attached values untouched. implies weights links always 1. Notice Schema Crosswalks, lookup tables category recoding functions Recode Maps. common way implementing recodings R named vectors pairwise arguments forcats::fct_recode(). Named vectors convenient way store use one--one many--one mappings. general necessary convert mappings crossmaps unless want combine fractional weight links. However, necessary, named vectors can converted xmap first transforming vector two-column table node pairs, attaching implied unit weights. crossmap recode map must binary weights, cardinality source target node sets must equal. words, weights can 0 (.e. link) 1, number unique source target labels . function verify_named_all_1to1() alias verify_named_as_recode_unique() uses cardinality condition verify whether named vector one--one relation: can also identify mistakes accidentally assigning value twice:","code":"# example using the named vector included in `mock` objects: mock$recode_vect  recode_xmap <-   xmap::as_pairs_from_named(mock$recode_vect, names_to = \"iso3\", values = \"ctr_name\") |>   xmap::add_weights_unit(weights_into = \"w\") |>   xmap::as_xmap_df(from = iso3, to = ctr_name, weights = w) fruit_color <- c(apple = \"green\", strawberry = \"red\", banana = \"yellow\") fruit_color |>   verify_named_all_1to1() |>   print() ##      apple strawberry     banana  ##    \"green\"      \"red\"   \"yellow\" fruit_color_mistake <- c(fruit_color, pear = \"green\")  fruit_color_mistake |>   verify_named_as_recode_unique() ## Error in `verify_named_as_recode_unique()`: ## ! Not all relations in `x` are 1-to-1."},{"path":"/articles/making-xmaps.html","id":"collapse-or-aggregation-maps","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Collapse or Aggregation maps","title":"Intro to Crossmaps","text":"Collapse crossmaps similar Recode crossmaps source values unmodified passed target nomenclature. However, name suggests, multiple source nodes can “collapsed” target node, least source values aggregated target nomenclature. Similar Recode crossmap, Collapse crossmap must unit weights, cardinality source node set larger target node set. means least two source nodes must linked target node since fewer target nodes source nodes. Similar recode maps, collapse maps unit weights. Hence, can use named lists store mappings. Consider example assigning students groups. Assume two students share name: can check students assigned multiple groups: every student assigned group: group unique name: Coercion xmap requires adding weights directional. can choose verify conditions return object via verify_links_* functions, coerce xmap use functions package. Aggregation transformations can implemented Collapse maps. Additionally, aggregation size requirements can implemented conditions number incoming links target node. instance, know target node aggregate values least two source nodes, minimum number non-zero incoming links 2 every target node. Notice requirement precludes one--one links since prevents source node recoded “unshared” node target nomenclature.","code":"student_groups <- list(GRP1 = c(\"kate\", \"jane\", \"peter\"),                        GRP2 = c(\"terry\", \"ben\", \"grace\"),                        GRP3 = c(\"cindy\", \"lucy\", \"alex\" )) student_groups |>   verify_named_all_values_unique() ## mistakenly assign kate to another group student_group_mistake <- list(GRP1 = c(\"kate\", \"jane\", \"peter\"),                            GRP2 = c(\"terry\", \"ben\", \"grace\"),                            GRP2 = c(\"cindy\", \"lucy\", \"kate\" ))  student_list <- c(\"kate\", \"jane\", \"peter\", \"terry\", \"ben\", \"grace\", \"cindy\", \"lucy\", \"alex\")  student_group_mistake |>   verify_named_matchset_values_exact(student_list) ## Error in `verify_named_matchset_values_exact()`: ## ! The values of `x` do not exactly match `ref_set` student_group_mistake |>   verify_named_all_names_unique() ## Error in `verify_named_all_names_unique()`: ## ! Duplicated names found in `x`. ## ℹ Use `base::duplicated(names(x))` to identify duplicates. group_links <- student_groups |>   as_pairs_from_named(names_to = \"group\", values_to = \"student\") |>   add_weights_unit()  ## collapse xmap from students to groups group_links |>   verify_links_as_xmap(from = student, to = group, weights = weights)  ## reverse doesn't work without adjusting the weights group_links |>   verify_links_as_xmap(from = group, to = student, weights = weights) ## Error in `verify_links_as_xmap()`: ## ! Incomplete mapping weights found ## ✖ `weights` does not sum to 1 ## ℹ Modify weights or adjust `tol` and try again."},{"path":"/articles/making-xmaps.html","id":"split-or-redistribution-maps-with-equal-weights","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Split or Redistribution maps (with Equal Weights)","title":"Intro to Crossmaps","text":"crossmap least one set fractional weight (one--many) links involve redistribution source value. However, useful special case maps fractional weights split maps, encode disaggregation source values target nomenclature. maps mostly one--many relations, contain one--many relations. can ensured restricting target node one incoming link. Furthermore, can preclude one--one links condition links must fractional weights. Notice set node pairs can generate either split collapse map depending weights added. example, recall student group example , swapping variables longer formed valid crossmap. Now consider allocating budget prizes equally students group. requires adding fractional weights group_links, can verified crossmap. Note first crossmap condition met, .e. one link unique source-node pair, dplyr::n() dplyr::n_distinct() interchangeable generating equal share weights.","code":"group_prize_links <- student_groups |>   as_pairs_from_named(\"group\", \"student\") |>   dplyr::group_by(group) |>   dplyr::mutate(prize_share = 1 / dplyr::n_distinct(student))  group_prize_links |>   verify_links_as_xmap(from = group, to = student, weights = prize_share)"},{"path":"/articles/making-xmaps.html","id":"cheatsheet-for-verifying-mapping-objects","dir":"Articles","previous_headings":"","what":"Cheatsheet for Verifying Mapping Objects","title":"Intro to Crossmaps","text":"Let \\(G = (U,V, E)\\) crossmap \\(U\\) \\(V\\) source target nomenclature sets, \\(E\\) denotes graph edges (.e. links two sets), weights link node \\(\\U\\) \\(j \\V\\) denoted \\(w_{ij}\\). Recall also sets definition don’t contain duplicates. Let us also define corresponding R objects: ,,weights : vectors columns defining non-zero links crossmap (.e edge list). - triplet row represents edge \\({,j}\\) weight \\(w_{ij}\\). vectors can contain duplicates. unique() : set \\(U\\) unique categories source nomenclature unique(): set \\(V\\) unique categories target nomenclature df: data.frame containing ,,weights sum_w : vector length unique() containing sum weights grouped ones: vector ones length sum_w unique() check table links valid crossmap, just check : missing values – .e. explicit link source, target weight one link unique source target node – .e. can’t two links \\(,j\\) different weights. weights links coming source node sum 1 xmap function verify_links_as_xmap(). can also check following base R dplyr conditions: anyNA(df) anyDuplicated(data.frame(, )) == FALSE nrow(distinct(df, , )) = nrow(df) (isTRUE(.equal(sum_w, ones))) dplyr::near(sum_w, ones) Note using == third condition recommended since doesn’t built-tolerance floating point errors. Strict versions special cases can also characterised following additional conditions: every link weight either 1 0 (implied absence) cardinality source target sets link weights binary source categories target categories source category assigned one target category link weights fractional absent target categories source categories source category least two outgoing links target nomenclature verify_named_all_1to1() verify_pairs_all_1to1() … verify_named_all_values_unique() verify_named_matchset … verify_named_all_names_unique() verify_named_matchset … base R conditions (weights == 1) length(unique() == length(unique()) (weights == 1) length(unique() > length(unique()) length(unique()) == length() (weights < 1) length(unique()) < length(unique()) length() > length(unique()) \\(w_{ij} \\\\{0,1\\} \\ \\forall ,j\\) \\(|U| = |V|\\) \\(Out_i = In_j = 1 \\ \\forall ,j\\) \\(w_{ij} \\\\{0,1\\} \\forall ,j\\) \\(|U| > |V|\\) \\(Out_i = 1 \\ \\forall \\U\\) \\(w_{ij} \\[0, 1) \\forall ,j\\) \\(|U| < |V|\\) \\(Out_i > 1 \\ \\forall \\U\\)","code":""},{"path":"/articles/making-xmaps.html","id":"creating-xmap_df-from-pairs-and-links","dir":"Articles","previous_headings":"","what":"Creating xmap_df from Pairs and Links","title":"Intro to Crossmaps","text":"following examples demonstrate coerce various inputs experimental xmap_df class.","code":""},{"path":"/articles/making-xmaps.html","id":"row-wise-links","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links","what":"Row-wise Links","title":"Intro to Crossmaps","text":"following example shows create mixed crossmap encodes one--one, many--one one--many relations coerce xmap_df. method suitable simple crossmaps. exmaple belows shows code sample crossmap: mock$xmap_abc","code":"abc_links <- tibble::tribble(   ~lower, ~upper, ~share,   \"a\", \"AA\", 1,       # one-to-one   \"b\", \"BB\", 1,    # one-FROM-many   \"c\", \"BB\", 1,   \"d\", \"CC\", 0.3,    # one-to-many   \"d\", \"DD\", 0.6,   \"d\", \"EE\", 0.1 )  xmap_abc <- abc_links |>   as_xmap_df(from = lower, to = upper, weights = share)  xmap_abc ## xmap_df: ## recode, split, and collapse   ## (lower -> upper) BY share ##   lower upper share ## 1     a    AA   1.0 ## 2     b    BB   1.0 ## 3     c    BB   1.0 ## 4     d    CC   0.3 ## 5     d    DD   0.6 ## 6     d    EE   0.1"},{"path":"/articles/making-xmaps.html","id":"crosswalklookup-tables","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links","what":"Crosswalk/Lookup Tables","title":"Intro to Crossmaps","text":"common want convert existing correspondence crossmap. conversions require attaching appropriate weights existing crosswalk table.","code":""},{"path":"/articles/making-xmaps.html","id":"recode-pairs","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links > Crosswalk/Lookup Tables","what":"Recode Pairs","title":"Intro to Crossmaps","text":"Consider first five country codes ISO 3166 international standard one--one correspondence 2-digit, 2-digit numeric codes. can verify pairwise combination columns one--one recode maps using verify_pairs_* functions: create crossmap ISONumeric ISO2, simply add weights columns coerce xmap_df: Notice as_xmap_df() always place , weights columns order drops additional columns passed . convert validated xmap named vector: can also easily generate validated crossmaps nomenclature table, keep additional columns:","code":"iso_codes <- tibble::tribble(               ~country, ~ISO2, ~ISO3, ~ISONumeric,          \"Afghanistan\",          \"AF\",         \"AFG\",    \"004\",              \"Albania\",          \"AL\",         \"ALB\",    \"008\",              \"Algeria\",          \"DZ\",         \"DZA\",    \"012\",       \"American Samoa\",          \"AS\",         \"ASM\",    \"016\",              \"Andorra\",          \"AD\",         \"AND\",    \"020\"       ) iso_codes |>   verify_pairs_as_recode_unique(from = country, to = ISO2) |>   print() ## # A tibble: 5 × 4 ##   country        ISO2  ISO3  ISONumeric ##   <chr>          <chr> <chr> <chr>      ## 1 Afghanistan    AF    AFG   004        ## 2 Albania        AL    ALB   008        ## 3 Algeria        DZ    DZA   012        ## 4 American Samoa AS    ASM   016        ## 5 Andorra        AD    AND   020 iso_xmap <- iso_codes |>   add_weights_unit(weights_into = \"weight\") |>   as_xmap_df(from = ISONumeric, to = ISO2, weights = weight) ## Dropped additional columns in `add_weights_unit(iso_codes, weights_into = ## \"weight\")` print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY weight ##   ISONumeric ISO2 weight ## 1        004   AF      1 ## 2        008   AL      1 ## 3        012   DZ      1 ## 4        016   AS      1 ## 5        020   AD      1 iso_xmap |>   xmap_to_named_vector() ##    AF    AL    DZ    AS    AD  ## \"004\" \"008\" \"012\" \"016\" \"020\" iso_codes |>   add_weights_unit(weights_into = \"weight\") |>   as_xmap_df(from = ISO2, to = ISO3, weights = weight, .drop_extra = FALSE) ## xmap_df: ## recode  ## (ISO2 -> ISO3) BY weight ##   ISO2 ISO3 weight        country ISONumeric ## 1   AF  AFG      1    Afghanistan        004 ## 2   AL  ALB      1        Albania        008 ## 3   DZ  DZA      1        Algeria        012 ## 4   AS  ASM      1 American Samoa        016 ## 5   AD  AND      1        Andorra        020"},{"path":"/articles/making-xmaps.html","id":"nested-lists","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links > Crosswalk/Lookup Tables","what":"Nested Lists","title":"Intro to Crossmaps","text":"Now consider aggregating data collected using ISO 3166-2 Subdivisions Australia Canada: Recall need one row per relation source (adm1) target (ctr) nomenclature. Thus split string list vector, unnest values country. Since aggregation involves one--one transfer values adm1 ctr prior collapsing ctr groups, simple add unit weights form valid crossmap:","code":"adm1_list <- tibble::tribble(   ~ctr, ~adm1,   \"AU\", \"AU-NSW, AU-QLD, AU-SA, AU-TAS, AU-VIC, AU-WA, AU-ACT, AU-NT\",   \"CA\", \"CA-AB, CA-BC, CA-MB, CA-NB, CA-NL, CA-NS, CA-ON, CA-PE, CA-QC, CA-SK, CA-NT, CA-NU, CA-YT\" ) agg_x <- adm1_list |>    dplyr::mutate(adm1 = stringr::str_split(adm1, \", \")) |>   tidyr::unnest(cols = c(adm1))  agg_x ## # A tibble: 21 × 2 ##    ctr   adm1   ##    <chr> <chr>  ##  1 AU    AU-NSW ##  2 AU    AU-QLD ##  3 AU    AU-SA  ##  4 AU    AU-TAS ##  5 AU    AU-VIC ##  6 AU    AU-WA  ##  7 AU    AU-ACT ##  8 AU    AU-NT  ##  9 CA    CA-AB  ## 10 CA    CA-BC  ## # ℹ 11 more rows agg_xmap <- agg_x |>   add_weights_unit(weights_into = \"link\") |>   as_xmap_df(from = adm1, to = ctr, weights = link)  agg_xmap ## xmap_df: ## recode and collapse   ## (adm1 -> ctr) BY link ##      adm1 ctr link ## 1  AU-NSW  AU    1 ## 2  AU-QLD  AU    1 ## 3   AU-SA  AU    1 ## 4  AU-TAS  AU    1 ## 5  AU-VIC  AU    1 ## 6   AU-WA  AU    1 ## 7  AU-ACT  AU    1 ## 8   AU-NT  AU    1 ## 9   CA-AB  CA    1 ## 10  CA-BC  CA    1 ## 11  CA-MB  CA    1 ## 12  CA-NB  CA    1 ## 13  CA-NL  CA    1 ## 14  CA-NS  CA    1 ## 15  CA-ON  CA    1 ## 16  CA-PE  CA    1 ## 17  CA-QC  CA    1 ## 18  CA-SK  CA    1 ## 19  CA-NT  CA    1 ## 20  CA-NU  CA    1 ## 21  CA-YT  CA    1"},{"path":"/articles/making-xmaps.html","id":"references-for-custom-weights","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links > Crosswalk/Lookup Tables","what":"References for Custom Weights","title":"Intro to Crossmaps","text":"Conversely, might aggregate level data want disaggregate. Continuing example, involve incorporating country level data analysis 3166-2 Subdivisions level. example, imagine population figures Australia 3166-2 level 9 10 years, country level figures missing year. simple example, reasonable harmonisation design involve splitting country level figure subdivision level population proportions year preceding following missing year. Alternatively, might want compare aggregate disaggregate statistics identify discrepancies. Using Australian population statistics 30 Jun 20221","code":"state_data <- tibble::tribble(                               ~state,    ~adm1,    ~Pop,                    \"New South Wales\", \"AU-NSW\", 8153600,                           \"Victoria\", \"AU-VIC\", 6613700,                         \"Queensland\", \"AU-QLD\", 5322100,                    \"South Australia\",  \"AU-SA\", 1820500,                  \"Western Australia\",  \"AU-WA\", 2785300,                           \"Tasmania\", \"AU-TAS\",  571500,                 \"Northern Territory\",  \"AU-NT\",  250600,       \"Australian Capital Territory\", \"AU-ACT\",  456700 )  state_xmap <- state_data |>   dplyr::mutate(ctr = \"AU\",                 adm1,                 share = Pop / sum(Pop)) |>   as_xmap_df(from = ctr, to = adm1, weights = share) ## Dropped additional columns in `dplyr::mutate(state_data, ctr = \"AU\", adm1, ## share = Pop/sum(Pop))` state_xmap ## xmap_df: ## split  ## (ctr -> adm1) BY share ##   ctr   adm1      share ## 1  AU AU-NSW 0.31391391 ## 2  AU AU-VIC 0.25462770 ## 3  AU AU-QLD 0.20490105 ## 4  AU  AU-SA 0.07008932 ## 5  AU  AU-WA 0.10723416 ## 6  AU AU-TAS 0.02200277 ## 7  AU  AU-NT 0.00964811 ## 8  AU AU-ACT 0.01758297"},{"path":"/articles/making-xmaps.html","id":"piecewise-construction","dir":"Articles","previous_headings":"Creating xmap_df from Pairs and Links","what":"Piecewise Construction","title":"Intro to Crossmaps","text":"Now consider following mixed transformation using selected correspondences NAICS Canada 1997 ISIC Revision 3. Imagine numeric data (e.g. gross output CAD) collected NAICS Canada nomenclature want harmonise ISIC Revision 3. correspondence two nomenclature contains mixture one--one, one--many, one--many relations. Luckily, can split source nomenclature two groups: source nodes one outgoing link (one--one relations unit weights) source nodes multiple outgoing links (one--many relations fractional weights) Let’s first define somed example correspondences.2 first example, one NAICS Canada class relates exactly one ISIC class, forming one--one relation. second example, ISIC target class D1543 equivalent one NAICS Canada source class, forming one--many relation. asterisk (Partial Flag) indicates part ISIC D1543 equivalent NAICS Canada class. ISIC activities corresponding NAICS Canada class listed column labelled “Link”. Notice one--one one--many relations, values attached source category directly modified “transfer” source target nomenclature. Instead, source values either retained, summarised category collapse (value aggregation) performed. Thus, shown , links examples take unit weights. third example, one souce NAICS Canada class equivalent one target ISIC class, forming one--many relation. Let’s clean recode collapse relations shown : Now remains prepare split links. Similar disaggregation example , need design weights allocate “pool” numeric value associated NAICS class 483213 corresponding ISIC classes I6110 I6120. Assume illustration purposes reference data suggest Canadian “Inland water transport” industry (I6120) twice big “Sea coastal water transport” industry (I6110). suggests weight 483213 I6120 twice I6110. Now let’s combine unit fractional links crossmap:","code":"canada_recode <- tibble::tibble(   NAICS1997      = \"212210\",    NAICS1997_desc = \"Iron Ore Mining\",   ISIC3          = \"C1310\",   ISIC3_desc    = \"Mining of iron ores\" ) canada_agg <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"311320\", \"Chocolate and Confectionery Manufacturing from Cacao Beans\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Chocolate and confectionery, made from cacao beans\",   \"311330\", \"Confectionery Manufacturing from Purchased Chocolate\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Confectionery, made from purchased chocolate\",   \"311340\", \"Non-Chocolate Confectionery Manufacturing\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Non-chocolate confectionery, manufacturing\" ) canada_split <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6110 *\", \"Sea and coastal water transport\", \"Intracoastal water transportation\",   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6120 *\", \"Inland water transport\", \"Inland water transportation (except ferries)\" ) canada_unit <- canada_agg |>   # remove the partial flag (*)   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   # bind the links together and add weights   dplyr::bind_rows(canada_recode) |>   dplyr::mutate(share = 1) canada_frac <- canada_split |>   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   dplyr::mutate(share = dplyr::case_when(ISIC3 == \"I6110\" ~ 0.33,                                   ISIC3 == \"I6120\" ~ 0.67,                                   T ~ NA_real_)) canada_xmap <- dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = NAICS1997, to = ISIC3, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` print(canada_xmap) ## xmap_df: ## recode, split, and collapse   ## (NAICS1997 -> ISIC3) BY share ##   NAICS1997 ISIC3 share ## 1    311320 D1543  1.00 ## 2    311330 D1543  1.00 ## 3    311340 D1543  1.00 ## 4    212210 C1310  1.00 ## 5    483213 I6110  0.33 ## 6    483213 I6120  0.67"},{"path":[]},{"path":"/articles/making-xmaps.html","id":"one-way-maps","dir":"Articles","previous_headings":"Reversing Crossmaps","what":"One-Way Maps","title":"Intro to Crossmaps","text":"Except case recoding, crossmaps generally lateral (one-way). Weights collapse split links longer valid reverse direct link. Notice as_xmap_df() throws error try naively swap arguments:","code":"dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = ISIC3, to = NAICS1997, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` ## Error in `as_xmap_df()`: ## ! Incomplete mapping weights found ## ✖ `share` does not sum to 1 ## ℹ Modify weights or adjust `tol` and try again."},{"path":"/articles/making-xmaps.html","id":"reversible-maps","dir":"Articles","previous_headings":"Reversing Crossmaps","what":"Reversible Maps","title":"Intro to Crossmaps","text":"However, can swap arguments recode map. Recall ISO country code crossmap created : Imagine instead converting country codes ISO Numeric ISO-2 digit, wanted convert ISO-2 digit ISO Numeric. can take existing crossmap invert without editing weights: less trivial reversal creating aggregation map disaggregation map. Recall country state level disaggregation map created : Now imagine wanted re-aggregate data, say state-level adjustments:","code":"print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY weight ##   ISONumeric ISO2 weight ## 1        004   AF      1 ## 2        008   AL      1 ## 3        012   DZ      1 ## 4        016   AS      1 ## 5        020   AD      1 iso_xmap |>   xmap_reverse() ## xmap_df: ## recode  ## (ISO2 -> ISONumeric) BY r_weights ##   ISO2 ISONumeric r_weights ## 1   AF        004         1 ## 2   AL        008         1 ## 3   DZ        012         1 ## 4   AS        016         1 ## 5   AD        020         1 state_xmap |>   xmap_drop_extra() ## xmap_df: ## split  ## (ctr -> adm1) BY share ##   ctr   adm1      share ## 1  AU AU-NSW 0.31391391 ## 2  AU AU-VIC 0.25462770 ## 3  AU AU-QLD 0.20490105 ## 4  AU  AU-SA 0.07008932 ## 5  AU  AU-WA 0.10723416 ## 6  AU AU-TAS 0.02200277 ## 7  AU  AU-NT 0.00964811 ## 8  AU AU-ACT 0.01758297 state_xmap |>   xmap_reverse(weights_into = \"agg_w\") |>   xmap_drop_extra() ## xmap_df: ## recode and collapse   ## (adm1 -> ctr) BY agg_w ##     adm1 ctr agg_w ## 1 AU-NSW  AU     1 ## 2 AU-VIC  AU     1 ## 3 AU-QLD  AU     1 ## 4  AU-SA  AU     1 ## 5  AU-WA  AU     1 ## 6 AU-TAS  AU     1 ## 7  AU-NT  AU     1 ## 8 AU-ACT  AU     1"},{"path":"/articles/vis-xmaps.html","id":"alternative-representations-of-crossmaps","dir":"Articles","previous_headings":"","what":"Alternative representations of Crossmaps","title":"Visualising Crossmap Transformations","text":"Crossmaps aim encode dataset integration harmonisation choices separately code used apply designs data. follows visualisations plots candidate crossmaps useful design process. instance, Sankey diagrams sometimes used visualise schema crosswalks. article provides ggplot2 code examples visualising crossmaps. package offer functions generating visualisations xmap objects future releases.","code":"library(ggplot2) library(dplyr) library(stringr) library(patchwork) library(ggbump) library(xmap)"},{"path":"/articles/vis-xmaps.html","id":"table","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Table","title":"Visualising Crossmap Transformations","text":"Let’s start visualising section ANZSCO22 ISCO8 crosswalk published Australian Bureau Statistics: included print() method xmap_df objects:","code":"anzsco_cw <- tibble::tribble(       ~anzsco22,                        ~anzsco22_descr, ~isco8, ~partial,                                         ~isco8_descr,        \"111111\", \"Chief Executive or Managing Director\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111111\", \"Chief Executive or Managing Director\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111111\", \"Chief Executive or Managing Director\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111211\",            \"Corporate General Manager\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111211\",            \"Corporate General Manager\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111211\",            \"Corporate General Manager\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111212\",         \"Defence Force Senior Officer\", \"0110\",      \"p\",                 \"Commissioned armed forces officers\",        \"111311\",          \"Local Government Legislator\", \"1111\",      \"p\",                                        \"Legislators\",        \"111312\",                 \"Member of Parliament\", \"1111\",      \"p\",                                        \"Legislators\",        \"111399\",                      \"Legislators nec\", \"1111\",      \"p\",                                        \"Legislators\"       )  links <- anzsco_cw |>   dplyr::group_by(anzsco22) |>   dplyr::summarise(n_dest = dplyr::n_distinct(isco8)) |>   dplyr::ungroup() |>   dplyr::transmute(anzsco22, weight = 1/n_dest) |>   dplyr::left_join(anzsco_cw, by = \"anzsco22\")  ## get code tables table_anzsco <- anzsco_cw |>   dplyr::distinct(anzsco22, anzsco22_descr) table_isco8 <- anzsco_cw |>   dplyr::distinct(isco8, isco8_descr)  ## make xmap anzsco_xmap <- links |>   as_xmap_df(anzsco22, isco8, weight) ## Dropped additional columns in `links` print(anzsco_xmap) ## xmap_df: ## recode, split, and collapse   ## (anzsco22 -> isco8) BY weight ##    anzsco22 isco8    weight ## 1    111111  1112 0.3333333 ## 2    111111  1114 0.3333333 ## 3    111111  1120 0.3333333 ## 4    111211  1112 0.3333333 ## 5    111211  1114 0.3333333 ## 6    111211  1120 0.3333333 ## 7    111212  0110 1.0000000 ## 8    111311  1111 1.0000000 ## 9    111312  1111 1.0000000 ## 10   111399  1111 1.0000000"},{"path":"/articles/vis-xmaps.html","id":"bigraph","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Bigraph","title":"Visualising Crossmap Transformations","text":"Visualisation bigraph particularly useful seeing relations two nomenclature.  visualisation also benefits traditionally used Sankey diagram. Sankey diagrams often used illustrated “flows” nodes. However, variable link widths can actually clutter visualisation crosswalks. Consider simple crossmap might used harmonise national accounts data (e.g. GDP) across two time periods.  hand, bigraph visualisation shows clearly data modified () harmonising nomenclature. solid lines show link modify source values, whilst dotted line style indicates data split . Furthermore, using fixed width links, room place labels -top curve indicated transformation weights.","code":".bigraph_add_link_style <- function(edges, x_attrs, ...) {   ## generate out link type   style_out_case <- tibble::tribble(     ~out_case, ~line_type, ~font_type,     \"unit_out\", \"solid\", \"bold\",     \"frac_out\", \"dashed\", \"italic\")   edges |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"unit_out\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"frac_out\")) |>     dplyr::left_join(style_out_case,               by = \"out_case\") |>     dplyr::ungroup() }  .bigraph_add_node_positions <- function(edges, x_attrs, pos_from, pos_to, ...) {   ## attach node positions   edges |>     dplyr::left_join(pos_from, by = setNames(\"from_set\", x_attrs$col_from)) |>     dplyr::left_join(pos_to, by = setNames(\"to_set\", x_attrs$col_to)) |>     dplyr::mutate(from_x = 0,                   to_x = 5) |>     dplyr::mutate(idx = dplyr::row_number()) }  plt_xmap_bigraph <- function(x, ...) {   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_short <- tibble::as_tibble(x)      df_out_style <- .bigraph_add_link_style(edges_short, x_attrs)      ## generate node positions   from_nodes <- tibble::tibble(from_set = x_attrs$from_set) |>     dplyr::mutate(from_y = dplyr::row_number())   to_nodes <- tibble::tibble(to_set = unique(x[[x_attrs$col_to]])) |>     dplyr::mutate(to_y = dplyr::row_number() - 1 + 0.5)      df_gg <- .bigraph_add_node_positions(df_out_style, x_attrs,                                        from_nodes, to_nodes)   ## build ggplot   ggplot2::ggplot(data = df_gg,                   aes(x = from_x, xend = to_x,                       y = from_y, yend = to_y,                       group = idx)) +     ## edges     ggbump::geom_sigmoid(aes(linetype = I(line_type))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"unit_out\"),              aes(x = (from_x + to_x) / 4,                  y = from_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"frac_out\"),              aes(x = (((from_x + to_x) / 2) + to_x) / 2,                  y = to_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ## from nodes     ggplot2::geom_text(aes(x = from_x - 0.5, y = from_y,                            label = .data[[x_attrs$col_from]],                            fontface=I(font_type)),                       ## drop idx groups to avoid duplicate labels                       stat = \"unique\", inherit.aes = FALSE) +     ## to nodes     ggplot2::geom_label(aes(x = to_x + 0.5, y = to_y,                              label = .data[[x_attrs$col_to]]),                         fill = \"black\",                         alpha = 0.1) +     ggplot2::scale_y_reverse() +     ggplot2::theme_minimal() +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank(),         axis.text.y = element_blank(),         axis.text.x = element_blank(),         plot.background = element_rect(fill = \"white\")) +     labs(x = NULL, y = NULL) } edges <- tribble(~ctr, ~ctr2, ~split,                  \"BLX\", \"BEL\", 0.5,                  \"BLX\", \"LUX\", 0.5,                  \"E.GER\", \"DEU\", 1,                  \"W.GER\", \"DEU\", 1)"},{"path":"/articles/vis-xmaps.html","id":"matrix","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Matrix","title":"Visualising Crossmap Transformations","text":"Another useful visualisation representation crossmap incidence matrix source nomenclature indexed along rows target nomenclature indexed columns:  Notice requirement valid crossmap outgoing weights sum 1 source node equivalent requirement total weights across row sums 1.","code":"plt_xmap_ggmatrix <- function(x, ...){   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_complete <- tibble::as_tibble(x) |>      tidyr::complete(.data[[x_attrs$col_from]], .data[[x_attrs$col_to]])      ## add link-out type   gg_df <- edges_complete |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"one-to-one\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"one-to-many\",                                               is.na(.data[[x_attrs$col_weights]]) ~ \"none\")                   )      ## make plot   gg_df |> ggplot(aes(x=.data[[x_attrs$col_to]],                       y=.data[[x_attrs$col_from]])) +     geom_tile(aes(fill=out_case), col=\"grey\") +     scale_y_discrete(limits=rev) +     scale_x_discrete(position='top') +     scale_fill_brewer() +     coord_fixed()  +     labs(x = x_attrs$col_to, y = x_attrs$col_from, fill=\"Outgoing Link Type\") +     theme_minimal() +     geom_text(data = dplyr::filter(gg_df, !is.na(.data[[x_attrs$col_weights]])), aes(label=round(.data[[x_attrs$col_weights]], 2))) +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()     ) } plt_xmap_ggmatrix(anzsco_xmap)"},{"path":"/articles/vis-xmaps.html","id":"visualising-types-of-mapping-relations","dir":"Articles","previous_headings":"","what":"Visualising Types of Mapping Relations","title":"Visualising Crossmap Transformations","text":"","code":"library(patchwork)  gg_recode + gg_agg + gg_disagg"},{"path":"/articles/xmap.html","id":"checking-existing-pipelines","dir":"Articles","previous_headings":"","what":"Checking existing pipelines","title":"Getting Started with Crossmaps","text":"xmap offers verification functions mappings encoded named vectors lists well data frames. Many checks seem trivial short mappings, can useful checks longer complex mappings. example, using named list manually recode categorical variables (e.g. using forcats::fct_recode), might want verify properties level mappings – e.g. existing level mapped : Similarly, using named list encode group members, check members reference list. redistributing numeric values categories, see vignette(\"making-xmaps\") details check transformation weights redistribute exactly 100% original data.","code":"library(forcats) library(xmap)  x <- factor(c(\"apple\", \"bear\", \"banana\", \"dear\")) levels <- ## new = \"old\" levels   c(fruit = \"apple\", fruit = \"banana\") |>   verify_named_all_values_unique() forcats::fct_recode(x, !!!levels) ## [1] fruit bear  fruit dear  ## Levels: fruit bear dear mistake_levels <- c(fruit = \"apple\", fruit = \"banana\", veg = \"banana\") |>   verify_named_all_values_unique() ## Error in `verify_named_all_values_unique()`: ## ! Duplicated values found in `x`. ## ℹ Use `base::duplicated(unlist(unname(x)))` to identify duplicates. ## mistakenly assign kate to another group student_group_mistake <- list(GRP1 = c(\"kate\", \"jane\", \"peter\"),                            GRP2 = c(\"terry\", \"ben\", \"grace\"),                            GRP2 = c(\"cindy\", \"lucy\", \"kate\" ))  student_list <- c(\"kate\", \"jane\", \"peter\", \"terry\", \"ben\",                   \"grace\", \"cindy\", \"lucy\", \"alex\")  student_group_mistake |>   verify_named_matchset_values_exact(student_list) ## Error in `verify_named_matchset_values_exact()`: ## ! The values of `x` do not exactly match `ref_set`"},{"path":"/articles/xmap.html","id":"crossmap-transformations","dir":"Articles","previous_headings":"","what":"Crossmap transformations","title":"Getting Started with Crossmaps","text":"crossmaps transformations can decomposed multiple “standard” data manipulation steps. Rename original categories target categories Mutate source node values link weight. Summarise mutated values target node. implement steps use following dplyr pipeline verified links: dplyr::left_join target categories () original data via source labels (). dplyr::mutate source values multiplying link weights (weights) transform original values redistributed values. dplyr::group_by dplyr::summarise values target groups () complete many--1 mappings. example given original data (v19_data) source categories (v19), valid xmap source categories (= version19), target categories (= version18) link weights (weights = w19to18): Note expect multiple matches 1--many relations dplyr warning can safely ignored.","code":"library(xmap) library(tibble) library(dplyr) # original data v19_data <- tibble::tribble(   ~v19, ~count,   \"1120\", 300,   \"1121\", 400,   \"1130\", 200,   \"1200\", 600 )  # valid crossmap xmap_19to18 <- tibble::tribble(   ~version19, ~version18, ~w19to18,   # many-to-1 collapsing   \"1120\", \"A2\", 1,   \"1121\", \"A2\", 1,   # 1-to-1 recoding   \"1130\", \"A3\", 1,   # 1-to-many redistribution   \"1200\", \"A4\", 0.6,   \"1200\", \"A5\", 0.4 ) |>   verify_links_as_xmap(from = version19, to = version18, weights = w19to18)  # transformed data (v18_data <- dplyr::left_join(x = v19_data,                       y = xmap_19to18,                       by = c(v19 = \"version19\")) |>   dplyr::mutate(new_count = count * w19to18) |>   dplyr::group_by(version18) |>   dplyr::summarise(v20_count = sum(new_count)) ) ## # A tibble: 4 × 2 ##   version18 v20_count ##   <chr>         <dbl> ## 1 A2              700 ## 2 A3              200 ## 3 A4              360 ## 4 A5              240"},{"path":"/articles/xmap.html","id":"creating-an-xmap_df-object-experimental","dir":"Articles","previous_headings":"","what":"Creating an xmap_df object (EXPERIMENTAL)","title":"Getting Started with Crossmaps","text":"xmap_df class aims facilitates additional functionality graph property calculation printing (.e. relation types crossmap direction) via custom print() method, coercion useful classes (e.g. xmap_to_matrix()), visualisation (see vignette(\"vis-xmaps\") prototypes), multi-step transformations (.e. nomenclature B C). Please note xmap_df class related functions still active development subject breaking changes future releases. already data frame candidate links, turn valid xmap object specifying source () nodes, target () nodes, weights (weights): Note verification coercion fail without adjusting tolerance tol, specifies differences ignore (.e. counts close enough 1).","code":"uk_shares <- tibble::tribble(   ~key1, ~key2, ~shares,   \"UK, Channel Islands, Isle of Man\", \"Scotland\", 0.1102047,   \"UK, Channel Islands, Isle of Man\", \"Wales\", 0.02720333,   \"UK, Channel Islands, Isle of Man\", \"England\", 0.862592   )  uk_shares |>   as_xmap_df(from = key1, to = key2, weights = shares, tol = 3e-08) |>   print() ## xmap_df: ## split  ## (key1 -> key2) BY shares ##                               key1     key2     shares ## 1 UK, Channel Islands, Isle of Man Scotland 0.11020470 ## 2 UK, Channel Islands, Isle of Man    Wales 0.02720333 ## 3 UK, Channel Islands, Isle of Man  England 0.86259200 uk_shares |>   verify_links_as_xmap(key1, key2, shares) ## Error in `verify_links_as_xmap()`: ## ! Incomplete mapping weights found ## ✖ `shares` does not sum to 1 ## ℹ Modify weights or adjust `tol` and try again."},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cynthia Huang. Author, maintainer. Laura Puzzello. Author, funder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huang C, Puzzello L (2023). xmap: principled approach recoding redistributing data nomenclature. R package version 0.0.1.9002, https://github.com/cynthiahqy/xmap.","code":"@Manual{,   title = {xmap: A principled approach to recoding and redistributing data between nomenclature},   author = {Cynthia Huang and Laura Puzzello},   year = {2023},   note = {R package version 0.0.1.9002},   url = {https://github.com/cynthiahqy/xmap}, }"},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"A principled approach to recoding and redistributing data between\n    nomenclature","text":"lots ways R modify categorical variables redistribution numeric values categories. performing simple recoding category labels, collapsing multiple categories, might use forcats package. However, complex transformations might find writing custom functions scripts including mutating joins, grouped summary operations, case-wise transformation numeric values. Verifying data wrangling scripts pipelines becomes difficult number categories complexity mappings increases. Current solutions issue mostly involve ad hoc data validation data transformed (assertr, validate, pointblank). xmap package offers alternative approach ensuring code performs intended transformations. Instead inspecting data, package provides tools validating mapping objects used transform data. Examples mapping objects available verification functions include: Commonly used reference inputs recoding collapsing categories. Use verify_named() checking properties uniqueness 1--1 relations, verify_named_matchset() checking set names values matches expectations. Also known crosswalks concordance tables Use verify_pairs() checking uniqueness 1--1 relations. new graph-based extension Crosswalk tables also store redistribution weights ambiguous 1--many relations. Use verify_links_as_xmap() check aggregation disaggregation weights desirable properties. See vignette(\"xmap\") get started using verification functions existing workflows. functions based results obtained representing analysing recoding redistribution transformations directed, weighted bipartite graphs (.e. “Crossmaps”). information underlying graph structure, experimental xmap_df class, see vignette(\"making-xmaps\") vignette(\"vis-xmaps\").","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A principled approach to recoding and redistributing data between\n    nomenclature","text":"install latest release xmap: install latest development version xmap:","code":"remotes::install_github(\"cynthiahqy/xmap\") remotes::install_github(\"cynthiahqy/conformr-xmap-project\", subdir = \"xmap\")"},{"path":"/reference/abort.html","id":null,"dir":"Reference","previous_headings":"","what":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","title":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","text":"Checks issues data.frame like objects containing validated xmap candidate links.","code":""},{"path":"/reference/abort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","text":"","code":"abort_missing_cols(df, cols)  abort_any_na(df)  abort_weights_col_type(df, col_weights)  abort_dup_pairs(df, col_from, col_to)  abort_bad_weights(col_weights, call = rlang::caller_env())  abort_col_order(df, col_from, col_to, col_weights)  abort_from_set(df, col_from, from_set)  msg_abort_frac_weights(impact)  abort_not_reversible(df, col_to)  msg_abort_named_matchset(   set_type = c(\"names\", \"values\"),   match_type = c(\"exact\", \"within\", \"contain\") )"},{"path":"/reference/abort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","text":"df data.frame-like object containing links col_from, col_to, col_weights character vector values naming columns df","code":""},{"path":"/reference/abort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","text":"error validation condition fails, invisibly returns df otherwise.","code":""},{"path":"/reference/abort.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Validation functions and messages for xmap or candidate links (Internal) — abort_missing_cols","text":"abort_missing_cols(): Abort named columns found df abort_any_na(): Abort xmap_df missing values abort_weights_col_type(): Abort xmap_df wrong column types abort_dup_pairs(): Abort duplicate source-target pairs found abort_bad_weights(): Abort invalid mapping weights abort_col_order(): Abort xmap_df columns order abort_from_set(): Abort from_set attribute match xmap_df values msg_abort_frac_weights(): Abort message fractional weights abort_not_reversible(): Abort xmap_df reversible without new weights msg_abort_named_matchset(): Abort message verify_named_matchset_* functions","code":""},{"path":"/reference/add_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Add weights to unweighted links — add_weights","title":"Add weights to unweighted links — add_weights","text":"Attach column weights table unweighted source-target links. calculating equal fractional weights, uses distinct -pairs. resultant weighted links can verified coerced xmap.","code":""},{"path":"/reference/add_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add weights to unweighted links — add_weights","text":"","code":"add_weights_unit(df, weights_into = \"weights\")  add_weights_equal(df, from, to, weights_into = \"weights\")  add_weights_prop(df, from, to, prop, weights_into = \"weights\")"},{"path":"/reference/add_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add weights to unweighted links — add_weights","text":"df data frame-like object least two columns weights_into character string naming new column store link weights , Columns x specifying source target nodes prop numeric column containing reference values calculate fractional weights . Weights calculated prop/sum(prop) sum calculated separately set links coming given node.","code":""},{"path":"/reference/add_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add weights to unweighted links — add_weights","text":"df additional column weights","code":""},{"path":"/reference/add_weights.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Add weights to unweighted links — add_weights","text":"add_weights_unit(): Attach column unit weights (.e. ones) add_weights_equal(): Attach equal fractional weights group add_weights_prop(): Attach weights group using proportion reference prop","code":""},{"path":"/reference/add_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add weights to unweighted links — add_weights","text":"","code":"# simple unit weights AUS_pairs <- list(AUS = c(\"NSW\", \"QLD\", \"SA\", \"TAS\", \"VIC\", \"WA\", \"ACT\", \"NT\")) |>   as_pairs_from_named(names_to = \"ctr\", values_to = \"state\") AUS_pairs |>   add_weights_unit(weights_into = \"weights\") #> # A tibble: 8 × 3 #>   ctr   state weights #>   <chr> <chr>   <dbl> #> 1 AUS   NSW         1 #> 2 AUS   QLD         1 #> 3 AUS   SA          1 #> 4 AUS   TAS         1 #> 5 AUS   VIC         1 #> 6 AUS   WA          1 #> 7 AUS   ACT         1 #> 8 AUS   NT          1  # fractional weights animal_pairs <- list(   MAMM = c(\"elephant\", \"whale\", \"monkey\"),   REPT = c(\"lizard\", \"turtle\"),   CRUS = c(\"crab\") ) |>   as_pairs_from_named(\"class\", \"animal\") animal_pairs |>   add_weights_equal(from = class, to = animal) #> # A tibble: 6 × 3 #>   class animal   weights #>   <chr> <chr>      <dbl> #> 1 MAMM  elephant   0.333 #> 2 MAMM  whale      0.333 #> 3 MAMM  monkey     0.333 #> 4 REPT  lizard     0.5   #> 5 REPT  turtle     0.5   #> 6 CRUS  crab       1      # proportional weights data.frame(   recipe = c(rep(\"cake\", 4), rep(\"pasta\", 2)),   ingredients = c(c(\"flour\", \"sugar\", \"eggs\", \"milk\"), c(\"flour\", \"water\")),   grams = c(c(500, 250, 200, 250), c(250, 150)) ) |>   add_weights_prop(recipe, ingredients, grams) #> # A tibble: 6 × 4 #>   recipe ingredients grams weights #>   <chr>  <chr>       <dbl>   <dbl> #> 1 cake   flour         500   0.417 #> 2 cake   sugar         250   0.208 #> 3 cake   eggs          200   0.167 #> 4 cake   milk          250   0.208 #> 5 pasta  flour         250   0.625 #> 6 pasta  water         150   0.375"},{"path":"/reference/add_weights_placeholder.html","id":null,"dir":"Reference","previous_headings":"","what":"Add weights placeholder column to a data frame — add_weights_placeholder","title":"Add weights placeholder column to a data frame — add_weights_placeholder","text":"function adds column character placeholders data frame based values columns. 1--1 links given unit weight placeholders, 1--many links given fractional weight placeholders.","code":""},{"path":"/reference/add_weights_placeholder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add weights placeholder column to a data frame — add_weights_placeholder","text":"","code":"add_weights_placeholder(   df,   from,   to,   weights_into = \"weights_{{from}}\",   frac_symbol = NA,   unit_symbol = 1 )"},{"path":"/reference/add_weights_placeholder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add weights placeholder column to a data frame — add_weights_placeholder","text":"df data frame. name column containing source category values. name column containing target category values. weights_into name use column containing weights placeholders. Default \"weights_from\". frac_symbol placeholder symbol use fractional weights. Default NA. unit_symbol placeholder symbol use unit weights. Default 1.","code":""},{"path":"/reference/add_weights_placeholder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add weights placeholder column to a data frame — add_weights_placeholder","text":"data frame new column containing weights placeholders.","code":""},{"path":"/reference/add_weights_placeholder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add weights placeholder column to a data frame — add_weights_placeholder","text":"","code":"mock$xmap_abc |>   as.data.frame() |>   add_weights_placeholder(from = upper, to = lower) #> # A tibble: 6 × 4 #>   lower upper share weights_upper #>   <chr> <chr> <dbl>         <dbl> #> 1 a     AA      1               1 #> 2 b     BB      1              NA #> 3 c     BB      1              NA #> 4 d     CC      0.3             1 #> 5 d     DD      0.6             1 #> 6 d     EE      0.1             1"},{"path":"/reference/as_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between column pairs and named vector or lists — as_pairs","title":"Convert between column pairs and named vector or lists — as_pairs","text":"Convert named vectors nested lists two-column table node pairs vice versa. as_pairs_from_named extracts vector list element names values, unnesting necessary. pairs_to_named_vector extracts name-value pairs column pairs , whilst pairs_to_named_list() nests values first.","code":""},{"path":"/reference/as_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between column pairs and named vector or lists — as_pairs","text":"","code":"as_pairs_from_named(x, names_to = \"name\", values_to = \"value\")  pairs_to_named_vector(df, names_from = name, values_from = value)  pairs_to_named_list(df, names_from = name, values_from = value)"},{"path":"/reference/as_pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between column pairs and named vector or lists — as_pairs","text":"x Named vector list. Lists values flattened via unlist(). names_to, values_to character vector specify new columns pass information x . df data frame-like object least two columns names_from, values_from two columns x convert names values","code":""},{"path":"/reference/as_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between column pairs and named vector or lists — as_pairs","text":"as_pairs_from_named(): two-column tibble pairs_to_named fncs: named vector list","code":""},{"path":"/reference/as_pairs.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Convert between column pairs and named vector or lists — as_pairs","text":"as_pairs_from_named(): Convert named vector nested list column pairs pairs_to_named_vector(): Convert column pairs named vector pairs_to_named_list(): Convert column pairs nested named list","code":""},{"path":"/reference/as_pairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between column pairs and named vector or lists — as_pairs","text":"","code":"# Coerce named vectors and list to column pairs  veg_vec <- c(eggplant = \"aubergine\", zucchini = \"courgette\") as_pairs_from_named(veg_vec, \"au_eng\", \"uk_eng\") #> # A tibble: 2 × 2 #>   au_eng   uk_eng    #>   <chr>    <chr>     #> 1 eggplant aubergine #> 2 zucchini courgette  animal_list <- list(   MAMM = c(\"elephant\", \"whale\", \"monkey\"),   REPT = c(\"lizard\", \"turtle\"),   CRUS = c(\"crab\") ) as_pairs_from_named(animal_list, \"class\", \"animal\") #> # A tibble: 6 × 2 #>   class animal   #>   <chr> <chr>    #> 1 MAMM  elephant #> 2 MAMM  whale    #> 3 MAMM  monkey   #> 4 REPT  lizard   #> 5 REPT  turtle   #> 6 CRUS  crab      # Convert pairs back to named vector and lists veg_from_pairs <- as_pairs_from_named(veg_vec) |>   pairs_to_named_vector(names_from = name, values_from = value) identical(veg_vec, veg_from_pairs) #> [1] TRUE  animal_from_pairs <- as_pairs_from_named(animal_list, \"class\", \"animal\") |>   pairs_to_named_list(names_from = class, values_from = animal) identical(animal_list, animal_from_pairs) #> [1] TRUE"},{"path":"/reference/as_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce objects to xmap_df — as_xmap","title":"Coerce objects to xmap_df — as_xmap","text":"Validates creates valid crossmap xmap_df object. function returns TRUE crossmaps xmap subclasses thereof (xmap_df), FALSE objects, including regular data.frames tibbles.","code":""},{"path":"/reference/as_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce objects to xmap_df — as_xmap","text":"","code":"as_xmap_df(   x,   from,   to,   weights,   tol = .Machine$double.eps^0.5,   subclass = c(\"xmap_df\"),   ... )  # S3 method for data.frame as_xmap_df(   x,   from,   to,   weights,   tol = .Machine$double.eps^0.5,   subclass = \"xmap_df\",   .drop_extra = TRUE )  is_xmap(x)  is_xmap_df(x)"},{"path":"/reference/as_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce objects to xmap_df — as_xmap","text":"x as_xmap_df(): object coerce is_xmap_df(): object test. , Columns x specifying source target nodes weights Column x specifying weight applied data passed along directed link source target node tol numeric \\(\\ge 0\\). Ignore differences smaller tol. Passed tolerance arg base::.equal(). subclass xmap subclass return. Defaults xmap_df data.frame tibble .drop_extra Drop columns , weights. Defaults TRUE","code":""},{"path":"/reference/as_xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce objects to xmap_df — as_xmap","text":"validated xmap object.","code":""},{"path":"/reference/as_xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Coerce objects to xmap_df — as_xmap","text":"as_xmap_df(data.frame): Coerce data.frame xmap","code":""},{"path":"/reference/as_xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce objects to xmap_df — as_xmap","text":"","code":"# For a well formed crossmap: links <- data.frame(   a = \"AUS\",   b = c(\"VIC\", \"NSW\", \"WA\", \"OTHER\"),   w = c(0.1, 0.15, 0.25, 0.5) ) as_xmap_df(links, from = a, to = b, weights = w) #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50  # extra columns are dropped, links$extra <- c(2, 4, 5, 6) as_xmap_df(links, from = a, to = b, weights = w) #> Dropped additional columns in `links` #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50"},{"path":"/reference/autoplot.xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Autoplot function for xmap_df objects — autoplot.xmap","title":"Autoplot function for xmap_df objects — autoplot.xmap","text":"function generates plot xmap_df object using ggraph ggplot2 packages. visualizes relationships nodes edges xmap_df object, different styles unit weight fractional weight links, prints fractional weights edges.","code":""},{"path":"/reference/autoplot.xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autoplot function for xmap_df objects — autoplot.xmap","text":"","code":"# S3 method for xmap_df autoplot(object, ...)"},{"path":"/reference/autoplot.xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autoplot function for xmap_df objects — autoplot.xmap","text":"object xmap_df object. ... Additional arguments (currently unused).","code":""},{"path":"/reference/autoplot.xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autoplot function for xmap_df objects — autoplot.xmap","text":"ggplot2 object","code":""},{"path":"/reference/autoplot.xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autoplot function for xmap_df objects — autoplot.xmap","text":"","code":"library(ggplot2) library(ggraph) library(tidygraph) #>  #> Attaching package: ‘tidygraph’ #> The following object is masked from ‘package:stats’: #>  #>     filter df <- data.frame(from = c(\"A\", \"A\", \"B\", \"B\", \"B\"),                  to = c(\"X\", \"Y\", \"X\", \"Y\", \"Z\"),                  weights = c(0.6, 0.4, 0.2, 0.7, 0.1)) xmap <- xmap::as_xmap_df(df, from, to, weights) autoplot(xmap)"},{"path":"/reference/mock.html","id":null,"dir":"Reference","previous_headings":"","what":"Mock input objects for the xmap package — mock","title":"Mock input objects for the xmap package — mock","text":"collection mock inputs experimenting functions xmap package. named_ objects either named vectors nested lists. df_ objects may contain source-target pairs (weights), weighted source-target links.","code":""},{"path":"/reference/mock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mock input objects for the xmap package — mock","text":"","code":"mock"},{"path":[]},{"path":"/reference/mock.html","id":"mock","dir":"Reference","previous_headings":"","what":"mock","title":"Mock input objects for the xmap package — mock","text":"list : named_ctr_iso3c named vector 249 elements. Names ISO-3 country codes, values ISO English country names. Retrieved countrycode package: https://github.com/vincentarelbundock/countrycode df_anzsco21 tibble 51 rows 4 columns. Contains major submajor occupation codes descriptions ANZSCO21. Retrieved strayr package: https://github.com/runapp-aus/strayr xmap_abc xmap_df: lower -> upper share. Mock crossmap 6 links including one--one, one--many many--one relations. named_aus named list 1 element named \"AUS\" containing codes Australian states df_aus_pop tibble containing 2022 population figures Australia state. Retrieved : https://www.abs.gov.au/statistics/people/population/national-state--territory-population/jun-2022","code":""},{"path":"/reference/mock.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mock input objects for the xmap package — mock","text":"","code":"links_aus_agg <- mock$named_aus |>   as_pairs_from_named(names_to = \"ctr\", values_to = \"state\") |>   add_weights_unit() |>   dplyr::select(ctr, state, weights) |>   verify_links_as_xmap(from = state, to = ctr, weights) links_aus_agg #> # A tibble: 8 × 3 #>   ctr   state  weights #>   <chr> <chr>    <dbl> #> 1 AUS   AU-NSW       1 #> 2 AUS   AU-QLD       1 #> 3 AUS   AU-SA        1 #> 4 AUS   AU-TAS       1 #> 5 AUS   AU-VIC       1 #> 6 AUS   AU-WA        1 #> 7 AUS   AU-ACT       1 #> 8 AUS   AU-NT        1  links_aus_split_equal <- links_aus_agg |>   add_weights_equal(from = ctr, to = state) |>   dplyr::select(ctr, state, weights) |>   verify_links_as_xmap(from = ctr, to = state, weights) links_aus_split_equal #> # A tibble: 8 × 3 #>   ctr   state  weights #>   <chr> <chr>    <dbl> #> 1 AUS   AU-NSW   0.125 #> 2 AUS   AU-QLD   0.125 #> 3 AUS   AU-SA    0.125 #> 4 AUS   AU-TAS   0.125 #> 5 AUS   AU-VIC   0.125 #> 6 AUS   AU-WA    0.125 #> 7 AUS   AU-ACT   0.125 #> 8 AUS   AU-NT    0.125  links_aus_split_pop <- mock$df_aus_pop |>   add_weights_prop(from = ctr, to = state, prop = pop) links_aus_split_pop #> # A tibble: 8 × 5 #>   state_name                   state      pop ctr   weights #>   <chr>                        <chr>    <dbl> <chr>   <dbl> #> 1 New South Wales              AU-NSW 8153600 AUS   0.314   #> 2 Victoria                     AU-VIC 6613700 AUS   0.255   #> 3 Queensland                   AU-QLD 5322100 AUS   0.205   #> 4 South Australia              AU-SA  1820500 AUS   0.0701  #> 5 Western Australia            AU-WA  2785300 AUS   0.107   #> 6 Tasmania                     AU-TAS  571500 AUS   0.0220  #> 7 Northern Territory           AU-NT   250600 AUS   0.00965 #> 8 Australian Capital Territory AU-ACT  456700 AUS   0.0176"},{"path":"/reference/new_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Low Level Constructors for xmap subclasses — new_xmap","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"Low Level Constructors xmap subclasses","code":""},{"path":"/reference/new_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"","code":"new_xmap_df(x, col_from, col_to, col_weights, from_set = NULL)"},{"path":"/reference/new_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"x data-frame object containing candidate links. col_from, col_to, col_weights character strings naming columns containing source nodes, target nodes numeric weights.","code":""},{"path":"/reference/new_xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"xmap_df object. Note function unclasses tibbles. x additional subclasses xmap_df xmap","code":""},{"path":"/reference/new_xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"new_xmap_df(): Construct xmap_df data.frame checks argument types naively generates from_set missing","code":""},{"path":"/reference/op-null-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Defaults for NULL values — op-null-default","title":"Defaults for NULL values — op-null-default","text":"Defaults NULL values","code":""},{"path":"/reference/op-null-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defaults for NULL values — op-null-default","text":"","code":"x %||% y"},{"path":"/reference/print.xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an xmap object — print.xmap","title":"Print an xmap object — print.xmap","text":"Print xmap object","code":""},{"path":"/reference/print.xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an xmap object — print.xmap","text":"","code":"# S3 method for xmap_df print(x)"},{"path":"/reference/print.xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Print an xmap object — print.xmap","text":"print(xmap_df): Print xmap_df","code":""},{"path":"/reference/summary_by_target.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize the composition of target categories. — summary_by_target","title":"Summarize the composition of target categories. — summary_by_target","text":"function summarizes crossmap based target nomenclature, using weighting variable calculate composition target category.","code":""},{"path":"/reference/summary_by_target.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize the composition of target categories. — summary_by_target","text":"","code":"summary_by_target(   links,   from,   to,   weights,   composition_to,   collapse,   frac_formula,   unit_formula )  # S3 method for data.frame summary_by_target(   links,   from,   to,   weights,   composition_to = \"parts_{from}\",   collapse = \"+\",   frac_formula = \"{from}*{weights}\",   unit_formula = \"{from}\" )  # S3 method for xmap_df summary_by_target(   links,   composition_to = \"parts_{{from}}\",   collapse = \"+\",   frac_formula = \"{from}*{weights}\",   unit_formula = \"{from}\" )"},{"path":"/reference/summary_by_target.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize the composition of target categories. — summary_by_target","text":"links data frame xmap_df , Columns x specifying source target nodes weights Column x specifying weight applied data passed along directed link source target node composition_to glue string specifying new column pass summarised composition . Default \"parts_{}\". collapse string specifying separator use collapsing unit values. Default \"+\". frac_formula glue formula specifying calculate fraction target value using weighting variable. Default \"{}*{weights}\". unit_formula glue formula specifying calculate unit target value using weighting variable. Default \"{}\".","code":""},{"path":"/reference/summary_by_target.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize the composition of target categories. — summary_by_target","text":"tibble summarizing composition target value based weighting variable.","code":""},{"path":"/reference/summary_by_target.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize the composition of target categories. — summary_by_target","text":"","code":"df <- data.frame(   group = c(\"x\", \"y\", \"z\", \"x\", \"y\", \"z\"),   parent = c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"),   weights = c(0.5, 0.3, 0.2, 0.7, 0.1, 0.2) ) summary_by_target(df, group, parent, weights) #> # A tibble: 2 × 2 #>   parent `parts_{group}`   #>   <chr>  <glue>            #> 1 A      x*0.5+y*0.3+z*0.2 #> 2 B      x*0.7+y*0.1+z*0.2 mock$xmap_abc |> summary_by_target() #> # A tibble: 5 × 2 #>   upper `parts_{{from}}` #>   <chr> <glue>           #> 1 AA    a                #> 2 BB    b+c              #> 3 CC    d*0.3            #> 4 DD    d*0.6            #> 5 EE    d*0.1"},{"path":"/reference/validate_xmap_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Validator for xmap_df class (INTERNAL) — validate_xmap_df","title":"Validator for xmap_df class (INTERNAL) — validate_xmap_df","text":"checks class attributes, crossmap graph properties. Use verify_links_as_xmap() as_xmap() verify graph properties","code":""},{"path":"/reference/validate_xmap_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validator for xmap_df class (INTERNAL) — validate_xmap_df","text":"","code":"validate_xmap_df(x)"},{"path":"/reference/verify_links_as_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if candidate links meet crossmap properties — verify_links_as_xmap","title":"Check if candidate links meet crossmap properties — verify_links_as_xmap","text":"links must satisfy: missing values one link unique source target node weights links coming source node sum 1","code":""},{"path":"/reference/verify_links_as_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if candidate links meet crossmap properties — verify_links_as_xmap","text":"","code":"verify_links_as_xmap(df, from, to, weights, tol = .Machine$double.eps^0.5)"},{"path":"/reference/verify_links_as_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if candidate links meet crossmap properties — verify_links_as_xmap","text":"df data.frame like object containing candidate links , Columns x specifying source target nodes weights Column x specifying weight applied data passed along directed link source target node tol numeric \\(\\ge 0\\). Ignore differences smaller tol. Passed tolerance arg base::.equal().","code":""},{"path":"/reference/verify_links_as_xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if candidate links meet crossmap properties — verify_links_as_xmap","text":"","code":"# For a well formed crossmap: links <- data.frame(   a = \"AUS\",   b = c(\"VIC\", \"NSW\", \"WA\", \"OTHER\"),   w = c(0.1, 0.15, 0.25, 0.5) ) verify_links_as_xmap(links, from = a, to = b, weights = w)"},{"path":"/reference/verify_named.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify crossmap properties of named vectors or lists — verify_named","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"Verify crossmap properties named vectors lists","code":""},{"path":"/reference/verify_named.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"","code":"verify_named_all_1to1(x)  verify_named_all_unique(x)  verify_named_all_names_unique(x)  verify_named_all_values_unique(x)  verify_named_as_recode_unique(x)  verify_named_no_dup_values(x)  verify_named_no_dup_names(x)"},{"path":"/reference/verify_named.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"x Named vector list. Lists values flattened via unlist().","code":""},{"path":"/reference/verify_named.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"x throws error","code":""},{"path":"/reference/verify_named.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"verify_named_all_1to1(): Verify named vector list one--one relations verify_named_all_unique(): Verify name-value pairs named vector list duplicated verify_named_all_names_unique(): Verify names named vector list duplicated verify_named_all_values_unique(): Verify values named vector list duplicated (unnesting) verify_named_as_recode_unique(): Alias verify_named_all_1to1() verify_named_no_dup_values(): Alias verify_named_all_values_unique() verify_named_no_dup_names(): Alias verify_named_all_names_unique()","code":""},{"path":"/reference/verify_named.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Verify crossmap properties of named vectors or lists — verify_named","text":"","code":"## check each fruit has a unique color fruit_color <- c(apple = \"green\", strawberry = \"red\", banana = \"yellow\") verify_named_all_1to1(fruit_color)  ## check no student is assigned to multiple groups student_groups <- list(   GRP1 = c(\"kate\", \"jane\", \"peter\"),   GRP2 = c(\"terry\", \"ben\", \"grace\"),   GRP3 = c(\"cindy\", \"lucy\", \"alex\") ) verify_named_no_dup_names(student_groups)  ## check"},{"path":"/reference/verify_named_matchset.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"Verify unique names values named vector list match expected set","code":""},{"path":"/reference/verify_named_matchset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"","code":"verify_named_matchset_names_exact(x, ref_set)  verify_named_matchset_values_exact(x, ref_set)  verify_named_matchset_names_contain(x, ref_set)  verify_named_matchset_values_contain(x, ref_set)  verify_named_matchset_names_within(x, ref_set)  verify_named_matchset_values_within(x, ref_set)"},{"path":"/reference/verify_named_matchset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"x Named vector list. Lists values flattened via unlist(). ref_set vector character strings","code":""},{"path":"/reference/verify_named_matchset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"x throw error","code":""},{"path":"/reference/verify_named_matchset.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"verify_named_matchset_names_exact(): Names x exactly match ref_set verify_named_matchset_values_exact(): Values x exactly match ref_set verify_named_matchset_names_contain(): Names x contain ref_set verify_named_matchset_values_contain(): Values x contain ref_set verify_named_matchset_names_within(): Names x within ref_set verify_named_matchset_values_within(): Values x within ref_set","code":""},{"path":"/reference/verify_named_matchset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Verify unique names or values of named vector or list match expected set — verify_named_matchset","text":"","code":"fruit_color <- c(apple = \"green\", strawberry = \"red\", banana = \"yellow\") fruit_set <- c(\"apple\", \"strawberry\", \"banana\", \"pear\") fruit_color |>   verify_named_matchset_names_within(ref_set = fruit_set)"},{"path":"/reference/verify_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify crossmap properties of column pairs — verify_pairs","title":"Verify crossmap properties of column pairs — verify_pairs","text":"Verify crossmap properties column pairs","code":""},{"path":"/reference/verify_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify crossmap properties of column pairs — verify_pairs","text":"","code":"verify_pairs_all_1to1(df, from, to)  verify_pairs_all_unique(df, from, to)  verify_pairs_as_recode_unique(df, from, to)"},{"path":"/reference/verify_pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verify crossmap properties of column pairs — verify_pairs","text":"df data frame-like object least two columns , Columns x specifying source target nodes","code":""},{"path":"/reference/verify_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify crossmap properties of column pairs — verify_pairs","text":"df error","code":""},{"path":"/reference/verify_pairs.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Verify crossmap properties of column pairs — verify_pairs","text":"verify_pairs_all_1to1(): Verify column pairs one--one relations verify_pairs_all_unique(): Verify column pairs unique verify_pairs_as_recode_unique(): Alias verify_pairs_all_1to1","code":""},{"path":"/reference/vhas.html","id":null,"dir":"Reference","previous_headings":"","what":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","title":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","text":"vhas_*() functions check properties xmap links /candidate links. functions accepts equal length vector inputs support multiple link formats, check inputs xmap.","code":""},{"path":"/reference/vhas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","text":"","code":"vhas_no_dup_pairs(v_from, v_to)  vhas_complete_weights(v_from, v_weights, tol = .Machine$double.eps^0.5)  vhas_xmap_props(v_from, v_to, v_weights)  vhas_1to1(v_weights)  vhas_1toM(v_weights)  vhas_1fromM(v_to)"},{"path":"/reference/vhas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","text":"v_from, v_to, v_weights equal length vectors containing source-target node pairs tol numeric \\(\\ge 0\\). Ignore differences smaller tol. Passed tolerance arg base::.equal().","code":""},{"path":"/reference/vhas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","text":"TRUE FALSE","code":""},{"path":"/reference/vhas.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Boolean flags for properties of candidate and validated xmap links (internal) — vhas","text":"vhas_no_dup_pairs(): Returns TRUE xmap duplicate pairs source-target nodes (irrespective weights) vhas_complete_weights(): Returns TRUE weights given label sum one (approximately) vhas_xmap_props(): Returns TRUE links duplicate pairs complete weights vhas_1to1(): Return TRUE xmap recodes labels vhas_1toM(): Return TRUE xmap splitting links vhas_1fromM(): Return TRUE xmap collapsing links ","code":""},{"path":"/reference/xmap_drop_extra.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop extra columns from xmap objects — xmap_drop_extra","title":"Drop extra columns from xmap objects — xmap_drop_extra","text":"Drop extra columns xmap objects","code":""},{"path":"/reference/xmap_drop_extra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop extra columns from xmap objects — xmap_drop_extra","text":"","code":"xmap_drop_extra(.xmap)"},{"path":"/reference/xmap_drop_extra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop extra columns from xmap objects — xmap_drop_extra","text":".xmap xmap object","code":""},{"path":"/reference/xmap_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse xmap direction — xmap_reverse","title":"Reverse xmap direction — xmap_reverse","text":"Reverse xmap direction","code":""},{"path":"/reference/xmap_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse xmap direction — xmap_reverse","text":"","code":"xmap_reverse(.xmap, weights_into)  # S3 method for xmap_df xmap_reverse(.xmap, weights_into = \"r_weights\")"},{"path":"/reference/xmap_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse xmap direction — xmap_reverse","text":".xmap xmap object reversed weights_into string specifying name new existing column store reverse weights .","code":""},{"path":"/reference/xmap_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse xmap direction — xmap_reverse","text":"xmap object class x, throws error x reversible","code":""},{"path":"/reference/xmap_reverse.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Reverse xmap direction — xmap_reverse","text":"xmap_reverse(xmap_df): Reverse xmap_df","code":""},{"path":"/reference/xmap_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract incidence matrix from xmap objects — xmap_to_matrix","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"Transforms xmap objects incidence matrix rows indexed values columns indexed values. Drops additional variables.","code":""},{"path":"/reference/xmap_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"","code":"xmap_to_matrix(.xmap, sparse, ...)  # S3 method for xmap_df xmap_to_matrix(.xmap, sparse = TRUE, ...)"},{"path":"/reference/xmap_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":".xmap xmap object sparse logical specifying result sparse matrix. Defaults TRUE. ... Reversed passing arguments stats::xtabs","code":""},{"path":"/reference/xmap_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"matrix sparse matrix object","code":""},{"path":"/reference/xmap_to_matrix.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"xmap_to_matrix(xmap_df): Coerce xmap_df Matrix","code":""},{"path":[]},{"path":"/reference/xmap_to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"","code":"abc_xmap <- data.frame(   stringsAsFactors = FALSE,   origin = c(     \"a\", \"b\", \"c\", \"d\", \"e\",     \"f\", \"g\", \"h\", \"i\", \"i\", \"j\", \"j\", \"j\"   ),   dest = c(     \"AA\", \"AA\", \"AA\", \"AA\",     \"BB\", \"BB\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"   ),   link = c(1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0.5, 0.3, 0.3, 0.4) ) |>   as_xmap_df(origin, dest, link) xmap_to_matrix(abc_xmap) #> 10 x 9 sparse Matrix of class \"dgCMatrix\" #>       dest #> origin AA BB CC DD  EE  FF  GG  HH  II #>      a  1  .  .  . .   .   .   .   .   #>      b  1  .  .  . .   .   .   .   .   #>      c  1  .  .  . .   .   .   .   .   #>      d  1  .  .  . .   .   .   .   .   #>      e  .  1  .  . .   .   .   .   .   #>      f  .  1  .  . .   .   .   .   .   #>      g  .  .  1  . .   .   .   .   .   #>      h  .  .  .  1 .   .   .   .   .   #>      i  .  .  .  . 0.5 0.5 .   .   .   #>      j  .  .  .  . .   .   0.3 0.3 0.4"},{"path":"/reference/xmap_to_named.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":"Checks xmap unit weights, converts values : vector xmap_to_named_vector() nested list xmap_to_named_list()","code":""},{"path":"/reference/xmap_to_named.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":"","code":"xmap_to_named_vector(.xmap)  xmap_to_named_list(.xmap)"},{"path":"/reference/xmap_to_named.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":".xmap xmap unit weights","code":""},{"path":"/reference/xmap_to_named.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":"Named vector list.","code":""},{"path":"/reference/xmap_to_named.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":"Names unique target nodes , element contains source node(s) .","code":""},{"path":[]},{"path":"/reference/xmap_to_named.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce a unit weight xmap_df to a named vector or list — xmap_to_named_vector","text":"","code":"iso_vector <- c(AF = \"004\", AL = \"008\", DZ = \"012\", AS = \"016\", AD = \"020\") iso_xmap <- iso_vector |>   as_pairs_from_named(names_to = \"iso2c\", values_to = \"iso3n\") |>   add_weights_unit() |>   as_xmap_df(from = iso3n, to = iso2c, weights) identical(iso_vector, xmap_to_named_vector(iso_xmap)) #> [1] TRUE animal_list <- list(   MAMM = c(\"elephant\", \"whale\", \"monkey\"),   REPT = c(\"lizard\", \"turtle\"),   CRUS = c(\"crab\") ) animal_xmap <- animal_list |>   as_pairs_from_named(names_to = \"class\", values_to = \"animals\") |>   add_weights_unit() |>   as_xmap_df(from = animals, to = class, weights = weights) identical(xmap_to_named_list(animal_xmap), animal_list) #> [1] TRUE"}]

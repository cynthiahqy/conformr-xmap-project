[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 C. Huang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/making-xmaps.html","id":"nomenclature-crossmaps","dir":"Articles","previous_headings":"","what":"Nomenclature Crossmaps","title":"Making Valid Crossmaps","text":"(Nomenclature) Crossmap encodes complete redistribution values source target classifications directed, bipartite, weighted graph. Numeric values transformed using valid Crossmap sum total source target classifications. valid Crossmap satisfies following conditions: one link distinct source target node source node, sum weights attached outgoing links sums one.","code":""},{"path":"/articles/making-xmaps.html","id":"unit-and-fractional-weight-links","dir":"Articles","previous_headings":"Nomenclature Crossmaps","what":"Unit and Fractional Weight Links","title":"Making Valid Crossmaps","text":"weights associated source-target link encode transformation applied values associated given source node. Let weight source node \\(\\) target node \\(j\\) denoted \\(w_{ij}\\). Weights can range \\([0,1]\\). Note \\(w_{ij} = 0\\) trivial case link source target nodes. non-trivial cases unit weights, \\(w_{ij} = 1\\) fractional weights, \\(w_{ij} \\(0,1)\\). Unit weights indicate source values unmodified passed target nomenclature. Therefore, crosswalks recoding node labels, collapsing multiple sub-category source nodes parent target nodes, can represented crossmaps unit weights. Fractional weights hand indicate source value modified passed target node. example link weight \\(0.7\\) indicates 70% numeric value associated source node “passed ” target node. Now, consider two links source node \\(\\) two different target nodes \\(j\\) \\(k\\), weights \\(w_{ij}\\) \\(w_{ik}\\). Assume source node \\(\\) outgoing links target nomenclature. , follows weights two given links sum one want preserve total value source target nomenclature. instance, \\(w_{ij} = 0.7\\), \\(w_{ik}\\) \\(0.3\\), 70% value associated source node \\(\\) goes target node \\(j\\), remaining 30% distributed target node \\(k\\).","code":""},{"path":"/articles/making-xmaps.html","id":"special-cases-of-crossmaps","dir":"Articles","previous_headings":"","what":"Special Cases of Crossmaps","title":"Making Valid Crossmaps","text":"conditions valid nomenclature crossmaps defined sufficient ensure total sum value retained source target nomenclature However, number transformation properties crossmaps can also encode validate. special cases include “degenerate” crossmaps. consider crossmap “degenerate” binary weights possible source-target links. cases weights implied presence absence link.","code":"library(xmap)"},{"path":"/articles/making-xmaps.html","id":"types-of-mapping-relations","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Types of Mapping Relations","title":"Making Valid Crossmaps","text":"helpful thinking special cases define familiar types relations: one--one: set links pairs source target nodes uniquely linked nodes. links type relation unit weights. one--many: set links single source node linked multiple target nodes. Links relation fractional weights. one--many: set links single target node linked multiple source nodes. Links can either unit fractional weights depending whether source nodes part one--one one--many relations. many--many: ???","code":""},{"path":"/articles/making-xmaps.html","id":"recode-maps","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Recode maps","title":"Making Valid Crossmaps","text":"Crossmaps one--one relations recode source labels target labels, leaving attached values untouched. crossmap recode map must binary weights, cardinality source target node sets must equal. Notice Schema Crosswalks, lookup tables category recoding functions implemented Recode Maps.","code":""},{"path":"/articles/making-xmaps.html","id":"collapse-or-aggregation-maps","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Collapse or Aggregation maps","title":"Making Valid Crossmaps","text":"Collapse crossmaps similar Recode crossmaps source values unmodified passed target nomenclature. However, name suggests, multiple source nodes can “collapsed” target node, least source values aggregated target nomenclature. Similar Recode crossmap, Collapse crossmap must unit weights, cardinality source node set larger target node set. means least two source nodes must linked target node since fewer target nodes source nodes. Aggregation transformations can implemented Collapse maps. Additionally, aggregation size requirements can implemented conditions number incoming links target node. instance, know target node aggregate values least two source nodes, minimum number non-zero incoming links 2 every target node. Notice requirement precludes one--one links since prevents source node recoded “unshared” node target nomenclature.","code":""},{"path":"/articles/making-xmaps.html","id":"split-or-disaggregation-maps","dir":"Articles","previous_headings":"Special Cases of Crossmaps","what":"Split or Disaggregation maps","title":"Making Valid Crossmaps","text":"crossmap least one set fractional weight (one--many) links involve redistribution source value. However, useful special case maps fractional weights split maps, encode disaggregation source values target nomenclature. maps mostly one--many relations, contain one--many relations. can ensured restricting target node one incoming link. Furthermore, can preclude one--one links condition links must fractional weights.","code":""},{"path":"/articles/making-xmaps.html","id":"crossmap-tables-xmap_df","dir":"Articles","previous_headings":"","what":"Crossmap tables: xmap_df","title":"Making Valid Crossmaps","text":"xmap_df data.frame representation Crossmap, row represents weighted link source target classifications. can create xmap_df data.frame tibble weighted edges using as_xmap_df(). input table x needs least 3 complete (.e. NA) columns: : source classification labels. : target classification labels weights: applied values source classification Additional columns (e.g. label descriptions etc.) can retained setting .drop_extra argument FALSE. as_xmap_df() validate : duplicates -pairs, Every group weights associated distinct value sums 1 (subject floating point tolerance).","code":""},{"path":"/articles/making-xmaps.html","id":"row-wise-creation","dir":"Articles","previous_headings":"Crossmap tables: xmap_df","what":"Row-wise creation","title":"Making Valid Crossmaps","text":"following example shows create mixed crossmap encodes one--one, many--one one--many relations coerce xmap_df. method suitable simple crossmaps.","code":"simple_x <- tibble::tribble(   ~source, ~target, ~share,   \"equal\", \"EQUAL\", 1,       # one-to-one   \"member_1\", \"GROUP\", 1,    # one-FROM-many   \"member_2\", \"GROUP\", 1,   \"whole\", \"PART_1\", 0.3,    # one-to-many   \"whole\", \"PART_2\", 0.6,   \"whole\", \"PART_3\", 0.1 )  simple_xmap <- simple_x |>   as_xmap_df(from = source, to = target, weights = share)  simple_xmap ## xmap_df: ## recode, split, and collapse   ## (source -> target) BY share ##     source target share ## 1    equal  EQUAL   1.0 ## 2 member_1  GROUP   1.0 ## 3 member_2  GROUP   1.0 ## 4    whole PART_1   0.3 ## 5    whole PART_2   0.6 ## 6    whole PART_3   0.1"},{"path":"/articles/making-xmaps.html","id":"coercion-from-crosswalks","dir":"Articles","previous_headings":"Crossmap tables: xmap_df","what":"Coercion from Crosswalks","title":"Making Valid Crossmaps","text":"common want convert existing correspondence crossmap. conversions require attaching appropriate weights existing crosswalk table.","code":""},{"path":"/articles/making-xmaps.html","id":"recode-maps-1","dir":"Articles","previous_headings":"Crossmap tables: xmap_df > Coercion from Crosswalks","what":"Recode maps","title":"Making Valid Crossmaps","text":"Consider first five country codes ISO 3166 international standard one--one correspondence 2-digit, 2-digit numeric codes. create crossmap ISONumeric ISO2, simply add weights columns coerce xmap_df: Notice as_xmap_df() always place , weights columns order drops additional columns passed . can also easily generate crossmaps nomenclature table:","code":"iso_codes <- tibble::tribble(               ~country, ~ISO2, ~ISO3, ~ISONumeric,          \"Afghanistan\",          \"AF\",         \"AFG\",    \"004\",              \"Albania\",          \"AL\",         \"ALB\",    \"008\",              \"Algeria\",          \"DZ\",         \"DZA\",    \"012\",       \"American Samoa\",          \"AS\",         \"ASM\",    \"016\",              \"Andorra\",          \"AD\",         \"AND\",    \"020\"       ) iso_xmap <- iso_codes |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = ISONumeric, to = ISO2, weights = link) ## Dropped additional columns in `dplyr::mutate(iso_codes, link = 1)` print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY link ##   ISONumeric ISO2 link ## 1        004   AF    1 ## 2        008   AL    1 ## 3        012   DZ    1 ## 4        016   AS    1 ## 5        020   AD    1 iso_codes |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = ISO2, to = ISO3, weights = link) ## Dropped additional columns in `dplyr::mutate(iso_codes, link = 1)` ## xmap_df: ## recode  ## (ISO2 -> ISO3) BY link ##   ISO2 ISO3 link ## 1   AF  AFG    1 ## 2   AL  ALB    1 ## 3   DZ  DZA    1 ## 4   AS  ASM    1 ## 5   AD  AND    1"},{"path":"/articles/making-xmaps.html","id":"aggregation-map","dir":"Articles","previous_headings":"Crossmap tables: xmap_df > Coercion from Crosswalks","what":"Aggregation map","title":"Making Valid Crossmaps","text":"Now consider aggregating data collected using ISO 3166-2 Subdivisions Australia Canada: Recall need one row per relation source (adm1) target (ctr) nomenclature. Thus split string list vector, unnest values country. Since aggregation involves one--one transfer values adm1 ctr prior collapsing ctr groups, simple add unit weights form valid crossmap:","code":"adm1_list <- tibble::tribble(   ~ctr, ~adm1,   \"AU\", \"AU-NSW, AU-QLD, AU-SA, AU-TAS, AU-VIC, AU-WA, AU-ACT, AU-NT\",   \"CA\", \"CA-AB, CA-BC, CA-MB, CA-NB, CA-NL, CA-NS, CA-ON, CA-PE, CA-QC, CA-SK, CA-NT, CA-NU, CA-YT\" ) agg_x <- adm1_list |>    dplyr::mutate(adm1 = stringr::str_split(adm1, \", \")) |>   tidyr::unnest(cols = c(adm1))  agg_x ## # A tibble: 21 × 2 ##    ctr   adm1   ##    <chr> <chr>  ##  1 AU    AU-NSW ##  2 AU    AU-QLD ##  3 AU    AU-SA  ##  4 AU    AU-TAS ##  5 AU    AU-VIC ##  6 AU    AU-WA  ##  7 AU    AU-ACT ##  8 AU    AU-NT  ##  9 CA    CA-AB  ## 10 CA    CA-BC  ## # … with 11 more rows agg_xmap <- agg_x |>   dplyr::mutate(link = 1) |>   as_xmap_df(from = adm1, to = ctr, weights = link)  agg_xmap ## xmap_df: ## recode and collapse   ## (adm1 -> ctr) BY link ##      adm1 ctr link ## 1  AU-NSW  AU    1 ## 2  AU-QLD  AU    1 ## 3   AU-SA  AU    1 ## 4  AU-TAS  AU    1 ## 5  AU-VIC  AU    1 ## 6   AU-WA  AU    1 ## 7  AU-ACT  AU    1 ## 8   AU-NT  AU    1 ## 9   CA-AB  CA    1 ## 10  CA-BC  CA    1 ## 11  CA-MB  CA    1 ## 12  CA-NB  CA    1 ## 13  CA-NL  CA    1 ## 14  CA-NS  CA    1 ## 15  CA-ON  CA    1 ## 16  CA-PE  CA    1 ## 17  CA-QC  CA    1 ## 18  CA-SK  CA    1 ## 19  CA-NT  CA    1 ## 20  CA-NU  CA    1 ## 21  CA-YT  CA    1"},{"path":"/articles/making-xmaps.html","id":"disaggregation-map","dir":"Articles","previous_headings":"Crossmap tables: xmap_df > Coercion from Crosswalks","what":"Disaggregation map","title":"Making Valid Crossmaps","text":"Conversely, might aggregate level data want disaggregate. Continuing example, involve incorporating country level data analysis 3166-2 Subdivisions level. example, imagine population figures Australia 3166-2 level 9 10 years, country level figures missing year. simple example, reasonable harmonisation design involve splitting country level figure subdivision level population proportions year preceding following missing year. Alternatively, might want compare aggregate disaggregate statistics identify discrepancies. Using Australian population statistics 30 Jun 20221","code":"state_data <- tibble::tribble(                               ~state,    ~adm1,    ~Pop,                    \"New South Wales\", \"AU-NSW\", 8153600,                           \"Victoria\", \"AU-VIC\", 6613700,                         \"Queensland\", \"AU-QLD\", 5322100,                    \"South Australia\",  \"AU-SA\", 1820500,                  \"Western Australia\",  \"AU-WA\", 2785300,                           \"Tasmania\", \"AU-TAS\",  571500,                 \"Northern Territory\",  \"AU-NT\",  250600,       \"Australian Capital Territory\", \"AU-ACT\",  456700 )  state_xmap <- state_data |>   dplyr::mutate(ctr = \"AU\",                 adm1,                 share = Pop / sum(Pop)) |>   as_xmap_df(from = ctr, to = adm1, weights = share) ## Dropped additional columns in `dplyr::mutate(state_data, ctr = \"AU\", adm1, ## share = Pop/sum(Pop))` state_xmap ## xmap_df: ## split  ## (ctr -> adm1) BY share ##   ctr   adm1      share ## 1  AU AU-NSW 0.31391391 ## 2  AU AU-VIC 0.25462770 ## 3  AU AU-QLD 0.20490105 ## 4  AU  AU-SA 0.07008932 ## 5  AU  AU-WA 0.10723416 ## 6  AU AU-TAS 0.02200277 ## 7  AU  AU-NT 0.00964811 ## 8  AU AU-ACT 0.01758297"},{"path":"/articles/making-xmaps.html","id":"mixed-maps","dir":"Articles","previous_headings":"Crossmap tables: xmap_df","what":"Mixed Maps","title":"Making Valid Crossmaps","text":"Now consider following mixed transformation using selected correspondences NAICS Canada 1997 ISIC Revision 3. Imagine numeric data (e.g. gross output CAD) collected NAICS Canada nomenclature want harmonise ISIC Revision 3. correspondence two nomenclature contains mixture one--one, one--many, one--many relations. Luckily, can split source nomenclature two groups: source nodes one outgoing link (one--one relations unit weights) source nodes multiple outgoing links (one--many relations fractional weights) Let’s first define somed example correspondences.2 first example, one NAICS Canada class relates exactly one ISIC class, forming one--one relation. second example, ISIC target class D1543 equivalent one NAICS Canada source class, forming one--many relation. asterisk (Partial Flag) indicates part ISIC D1543 equivalent NAICS Canada class. ISIC activities corresponding NAICS Canada class listed column labelled “Link”. Notice one--one one--many relations, values attached source category directly modified “transfer” source target nomenclature. Instead, source values either retained, summarised category collapse (value aggregation) performed. Thus, shown , links examples take unit weights. third example, one souce NAICS Canada class equivalent one target ISIC class, forming one--many relation. Let’s clean recode collapse relations shown : Now remains prepare split links. Similar disaggregation example , need design weights allocate “pool” numeric value associated NAICS class 483213 corresponding ISIC classes I6110 I6120. Assume illustration purposes reference data suggest Canadian “Inland water transport” industry (I6120) twice big “Sea coastal water transport” industry (I6110). suggests weight 483213 I6120 twice I6110. Now let’s combine unit fractional links crossmap:","code":"canada_recode <- tibble::tibble(   NAICS1997      = \"212210\",    NAICS1997_desc = \"Iron Ore Mining\",   ISIC3          = \"C1310\",   ISIC3_desc    = \"Mining of iron ores\" ) canada_agg <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"311320\", \"Chocolate and Confectionery Manufacturing from Cacao Beans\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Chocolate and confectionery, made from cacao beans\",   \"311330\", \"Confectionery Manufacturing from Purchased Chocolate\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Confectionery, made from purchased chocolate\",   \"311340\", \"Non-Chocolate Confectionery Manufacturing\", \"D1543 *\", \"Manufacture of cocoa, chocolate and sugar confectionery\", \"Non-chocolate confectionery, manufacturing\" ) canada_split <- tibble::tribble(   ~NAICS1997, ~NAICS1997_desc, ~ISIC3, ~ISIC3_desc, ~Link,   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6110 *\", \"Sea and coastal water transport\", \"Intracoastal water transportation\",   \"483213\", \"Inland Water Transportation (except by Ferries)\", \"I6120 *\", \"Inland water transport\", \"Inland water transportation (except ferries)\" ) canada_unit <- canada_agg |>   # remove the partial flag (*)   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   # bind the links together and add weights   dplyr::bind_rows(canada_recode) |>   dplyr::mutate(share = 1) canada_frac <- canada_split |>   dplyr::mutate(ISIC3 = stringr::str_remove(ISIC3, \" \\\\*\")) |>   dplyr::select(-Link) |>   dplyr::mutate(share = dplyr::case_when(ISIC3 == \"I6110\" ~ 0.33,                                   ISIC3 == \"I6120\" ~ 0.67,                                   T ~ NA_real_)) canada_xmap <- dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = NAICS1997, to = ISIC3, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` print(canada_xmap) ## xmap_df: ## recode, split, and collapse   ## (NAICS1997 -> ISIC3) BY share ##   NAICS1997 ISIC3 share ## 1    311320 D1543  1.00 ## 2    311330 D1543  1.00 ## 3    311340 D1543  1.00 ## 4    212210 C1310  1.00 ## 5    483213 I6110  0.33 ## 6    483213 I6120  0.67"},{"path":[]},{"path":"/articles/making-xmaps.html","id":"one-way-maps","dir":"Articles","previous_headings":"Reversing Crossmaps","what":"One-Way Maps","title":"Making Valid Crossmaps","text":"Except case recoding, crossmaps generally lateral (one-way). Weights collapse split links longer valid reverse direct link. Notice as_xmap_df() throws error try naively swap arguments:","code":"dplyr::bind_rows(canada_unit, canada_frac) |>   as_xmap_df(from = ISIC3, to = NAICS1997, weights = share) ## Dropped additional columns in `dplyr::bind_rows(canada_unit, ## canada_frac)` ## Error in `df_check_weights()`: ## ! Incomplete mapping weights found. Check sum of weights for each `from` ##   group sums to 1"},{"path":"/articles/making-xmaps.html","id":"reversible-maps","dir":"Articles","previous_headings":"Reversing Crossmaps","what":"Reversible Maps","title":"Making Valid Crossmaps","text":"However, can swap arguments recode map. Recall ISO country code crossmap created : Imagine instead converting country codes ISO Numeric ISO-2 digit, wanted convert ISO-2 digit ISO Numeric. can take existing crossmap invert without editing weights: less trivial reversal creating aggregation map disaggregation map. Recall country state level disaggregation map created : Now imagine wanted re-aggregate data, say state-level adjustments:","code":"print(iso_xmap) ## xmap_df: ## recode  ## (ISONumeric -> ISO2) BY link ##   ISONumeric ISO2 link ## 1        004   AF    1 ## 2        008   AL    1 ## 3        012   DZ    1 ## 4        016   AS    1 ## 5        020   AD    1 iso_xmap |>   xmap_reverse() ## xmap_df: ## recode  ## (ISO2 -> ISONumeric) BY r_weights ##   ISO2 ISONumeric r_weights ## 1   AF        004         1 ## 2   AL        008         1 ## 3   DZ        012         1 ## 4   AS        016         1 ## 5   AD        020         1 state_xmap |>   xmap_drop_extra() ## xmap_df: ## split  ## (ctr -> adm1) BY share ##   ctr   adm1      share ## 1  AU AU-NSW 0.31391391 ## 2  AU AU-VIC 0.25462770 ## 3  AU AU-QLD 0.20490105 ## 4  AU  AU-SA 0.07008932 ## 5  AU  AU-WA 0.10723416 ## 6  AU AU-TAS 0.02200277 ## 7  AU  AU-NT 0.00964811 ## 8  AU AU-ACT 0.01758297 state_xmap |>   xmap_reverse(weights_into = \"agg_w\") |>   xmap_drop_extra() ## xmap_df: ## recode and collapse   ## (adm1 -> ctr) BY agg_w ##     adm1 ctr agg_w ## 1 AU-NSW  AU     1 ## 2 AU-VIC  AU     1 ## 3 AU-QLD  AU     1 ## 4  AU-SA  AU     1 ## 5  AU-WA  AU     1 ## 6 AU-TAS  AU     1 ## 7  AU-NT  AU     1 ## 8 AU-ACT  AU     1"},{"path":"/articles/using-xmaps.html","id":"nomenclature-variables-and-datasets","dir":"Articles","previous_headings":"","what":"Nomenclature Variables and Datasets","title":"Using Crossmaps to Transform Data","text":"nomenclature variable set name-value pairs, names correspond categories classes particular nomenclature, values measured particular categories classes. instance, consider data population state Australia1 shown . Australian population State (excl. Territories) set name-value pairs state/territory name population estimate given time period form nomenclature variable observation Australia. Furthermore, since values form aggregate pool total population Australia, can consider nomenclature pool variable.","code":""},{"path":"/articles/using-xmaps.html","id":"tidy-nomenclature-datasets","dir":"Articles","previous_headings":"Nomenclature Variables and Datasets","what":"Tidy Nomenclature datasets","title":"Using Crossmaps to Transform Data","text":"Wickham (2007) introduces division dataset variables two types: identifier measured variables: Identifier variables identify unit measurements taken . Measured variables values measured observation unit defined identifier variables. Using additional abstraction step splitting measured variables id-value pairs, extend taxonomy slightly define “tidy nomeclature data” format: Observational Unit Identifier Variables identify variables used index observational units. example, country year variables used index population observations. Dimension Identifier Variables identify dimension, set dimensions, observation unit measurements take place . Measured Variables contain values measured observation unit dimension. dimension id measured variables form name-value pairs particular dimension observational unit. Wickham (2014)’s tidy data (see vignette(\"tidy-data\", package = \"tidyr\")) format describes standard way structuring tabular datasets using following data semantics: dataset collection values, usually either numbers (quantitative) strings (qualitative). Values organised two ways. Every value belongs variable observation. semantics, every value tidy dataset belongs either observational unit identifier variable “simple” dimension variable. However, nomenclature variables name-value pairs split across two columns, one nomenclature “dimension” identifier variable, one associated measured value. Furthermore, semantic role system (Kandel et al. 2011), nomenclature name column semantic role “classification code”, value column standard data type (e.g. integer). Hence, nomenclature variable can also thought pairings classification code value columns. nomenclature dataset consists multiple observations single nomenclature variable. tidy nomenclature dataset, observational unit number rows across shared nomenclature. Hence tidy nomenclature data: Every column either identifier variable, part nomenclature name-value pair Every row observation nomenclature sub-dimension Every cell single value identifier variable, nomenclature node, measured variable. nest nomenclature data, obtain structure analogous standard tidy data format (Wickham (2014)): Every column variable Every row observation Every cell single value nested name-value set. Notice nomenclature datasets blur distinction variable value. example, describe table containing values population variable attached observational units state, rather single observation state-population nomenclature variable (dimension-value pair) observational unit “Australia”. However, concept dimension identifier variable useful defining data structure required use crossmaps. Just wider dataset formats useful data entry, longer formats suited analysis, two-column nomenclature variable format ideal transforming harmonising data nomenclature. format particularly suitable cases original nomenclature: sufficiently many category nodes wider format difficult work , /transformed using crossmap expected change relatively frequently (e.g. occupation product classifications) one layer larger hierarchical nomenclature (e.g. administrative regions geographic areas)","code":""},{"path":[]},{"path":"/articles/using-xmaps.html","id":"crossmap-transformations","dir":"Articles","previous_headings":"Nomenclature Transformations","what":"Crossmap Transformations","title":"Using Crossmaps to Transform Data","text":"utility defining nomenclature variable crossmap format evident look transformation values source nomenclature target nomenclature set matrix operations. demonstrate, use xmap::xmap_to_matrix() function take valid crossmap (abc_xmap) convert incidence matrix (b_mtx): Let \\(\\bf{B}\\) \\(n \\times m\\) incidence matrix describing graph representation valid crossmap. \\(\\bf{B}\\) row indexed source nomenclature, column indexed target nomenclature. two conditions valid crossmap can expressed properties incidence matrix \\(\\bf{B}\\): node source target set indexes one row column respectively, providing one non-zero link nodes source target nomenclature. row contains weights outgoing links given source node. Thus, row matrix sum 1 (.e. \\(\\bf{B1} = \\bf{1}\\) \\(\\bf{1}\\) unit vector length \\(n\\)). Now, let \\(\\bf{x}\\) vector length \\(n\\) containing numeric values transformed. \\(\\bf{x}\\) also row-indexed source nomenclature node, index-value pair forms nomenclature variable. Assume values count variables \\(\\bf{x}\\) nomenclature pool variable. redistribute \\(\\bf{x}\\) source nomenclature target nomenclature, simply take \\(\\bf{y} = \\bf{B}'\\bf{x}\\). Hence, using valid crossmap transform nomenclature variable equivalent matrix transformation \\(\\bf{x}\\) incidence matrix \\(\\bf{B}\\). Given equivalence, clear see two conditions define crossmap guarantee total sum nomenclature transform remains . Moreover, can sure without checking total resultant variable \\(\\bf{y}\\).","code":"library(xmap) ## define crossmap abc_xmap <- tibble::tribble(       ~origin, ~dest, ~link,           \"a\",  \"AA\",     1,           \"b\",  \"AA\",     1,           \"c\",  \"AA\",     1,           \"d\",  \"BB\",     1,           \"e\",  \"CC\",     1,           \"f\",  \"DD\",   0.3,           \"f\",  \"EE\",   0.3,           \"f\",  \"FF\",   0.4       ) |>   as_xmap_df(from = origin, to = dest, link)  ## convert to matrix b_mtx <- xmap_to_matrix(abc_xmap, sparse = FALSE) b_mtx ##       dest ## origin  AA  BB  CC  DD  EE  FF ##      a 1.0 0.0 0.0 0.0 0.0 0.0 ##      b 1.0 0.0 0.0 0.0 0.0 0.0 ##      c 1.0 0.0 0.0 0.0 0.0 0.0 ##      d 0.0 1.0 0.0 0.0 0.0 0.0 ##      e 0.0 0.0 1.0 0.0 0.0 0.0 ##      f 0.0 0.0 0.0 0.3 0.3 0.4 ## define example data x <- matrix(rep_len(100, nrow(b_mtx))) dimnames(x) <- list(row.names(b_mtx), \"x\")  ## apply transformation y <- t(b_mtx) %*% x  ## print matlib::printMatEqn(`B'` = t(b_mtx), x, \"=\", y) ## Warning in rgl.init(initValue, onlyNULL): RGL: unable to open X11 display ## Warning: 'rgl.init' failed, running with 'rgl.useNULL = TRUE'. ##                       B'   x       y ##  1.0 1.0 1.0 0.0 0.0 0.0 100  =  300 ##  0.0 0.0 0.0 1.0 0.0 0.0 100     100 ##  0.0 0.0 0.0 0.0 1.0 0.0 100     100 ##  0.0 0.0 0.0 0.0 0.0 0.3 100      30 ##  0.0 0.0 0.0 0.0 0.0 0.3 100      30 ##  0.0 0.0 0.0 0.0 0.0 0.4 100      40"},{"path":"/articles/using-xmaps.html","id":"comparison-to-existing-appraoches","dir":"Articles","previous_headings":"Nomenclature Transformations","what":"Comparison to Existing Appraoches","title":"Using Crossmaps to Transform Data","text":"Using crossmaps recoding, aggregation disaggregation can seem bit tedious given can achieve transformation simple join mutate statements, coupled ad-hoc validation. However, crossmaps provide assurance transformations multiple mapping relations applied possible ad-hoc validation. particular, circumvent need count number observations merging, hence can insure duplication erroneous drops even cases difficult calculate expected number post-transformations rows (.e. many--many relations split collapse transformations).","code":""},{"path":"/articles/using-xmaps.html","id":"iterative-or-case-wise-transformation","dir":"Articles","previous_headings":"Nomenclature Transformations > Comparison to Existing Appraoches","what":"Iterative or Case-Wise Transformation","title":"Using Crossmaps to Transform Data","text":"illustrate advantages crossmap approach, consider iterative case-wise approach whereby data transformed node node basis. Regardless whether code transformation distribution value source nomenclature nodes collection value target nomenclature nodes, ad-hoc ways validating node--node transformations. instance, one calculate compare sums \\(\\bf{x}\\) \\(\\bf{y}\\). However, even two totals equal, guarantee source value fully redistributed target nomenclature, possible, though highly unlikely, two mistakes offset . Furthermore, case two totals match, obvious identify nodes involved mistake. second issue scales size nomenclature number lines code required execute transformation increases. Consider following imperative code transforming \\(\\bf{x}\\) target nomenclature: Observe following: value attached source node c mistakenly distributed twice (lines 3 4) transformed vector \\(\\bf{y}\\), whilst source value e distributed . source node f origin source nomenclature split three outgoing links DD, EE FF. Notice need check three lines code (6-8) validate weights sum one. fact, weights sum 0.9. total sum \\(\\bf{x}\\) 600, match total sum \\(\\bf{y}\\) 590. However, mismatch can fixed detecting correcting second weights error alone, provides insight first double distribution error.","code":"y <- list()  y$AA = x[\"a\", ] + x[\"b\", ] + x[\"c\", ] y$BB = x[\"d\", ] y$CC = x[\"c\", ] y$DD = 0.3 * x[\"f\", ] y$EE = 0.2 * x[\"f\", ] y$FF = 0.4 * x[\"f\", ]  y |> as.matrix() ##    [,1] ## AA 300  ## BB 100  ## CC 100  ## DD 30   ## EE 20   ## FF 40"},{"path":"/articles/using-xmaps.html","id":"crosswalk-and-lookup-table-approaches","dir":"Articles","previous_headings":"Nomenclature Transformations > Comparison to Existing Appraoches","what":"Crosswalk and Lookup Table approaches","title":"Using Crossmaps to Transform Data","text":"Crosswalk lookup table approaches better still limited comes dealing split relations complex xmaps unambiguous matches left user, supported","code":""},{"path":[]},{"path":"/articles/using-xmaps.html","id":"code-agnostic-dataset-design","dir":"Articles","previous_headings":"Nomenclature Transformations > Additional Benefits","what":"Code-Agnostic Dataset Design","title":"Using Crossmaps to Transform Data","text":"addition circumventing need ad-hoc checks, crossmap format provides code-agnostic method specifying, communicating checking dataset design decisions. means team members fluent R can confidence harmonised integrated datasets match intended design without audit long data wrangling scripts. particularly important cross-disciplinary teams, domain knowledge necessary designing link weights. datasets created integrating data multiple sources, principled methods recording, validating sharing design choices ex-post harmonisation, disaggregation re-aggregation schemes can facilitate trust transparency. maybe add-vignette(\"vis-xmaps\") content ?","code":""},{"path":"/articles/using-xmaps.html","id":"multiple-related-nomenclature-transformations-future-work","dir":"Articles","previous_headings":"Nomenclature Transformations > Additional Benefits","what":"Multiple related nomenclature transformations (FUTURE WORK)","title":"Using Crossmaps to Transform Data","text":"Returning tidy nomenclature format, note nested name-value set analogous \\(\\bf{x}\\), name column indexes measured values. kronecker product multiple observation vectors source nomenclature target nomenclature list/nested approach multiple observation vectors different source noemncalture target nomenclature resolving discrepancies aggregation levels","code":""},{"path":"/articles/using-xmaps.html","id":"apply-xmap-to-data-using-mutating-joins","dir":"Articles","previous_headings":"","what":"Apply xmap to data using Mutating Joins","title":"Using Crossmaps to Transform Data","text":"crossmaps transformations can decomposed multiple “standard” transformation steps: Rename source node labels target nomenclature. can achieved via left-join source data crossmap source node labels. Mutate source node values link weight. can achieved multiplying source value joined link weights. Summarise mutated values target node. can achieved grouping summarising mutated values step 2 joined target node labels.","code":""},{"path":"/articles/using-xmaps.html","id":"transformation-effects-by-relation-type","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins","what":"Transformation effects by relation type","title":"Using Crossmaps to Transform Data","text":"combined effect steps differs depending type relation present given crossmap. types relations, step 1 data modifying step since attaches target nodes links original data via source node labels. recoding relations, step 1 data modifying step. Step 1 effectively “renames” source nodes target nomenclature. remaining steps, multiplying source values unit weights leaves values unchanged, since recoding involves one--one relations summarising target node also leaves values unchanged. number rows original data transformed data remain . collapsing relations, step 3 additional data modifying steps. Similar recoding, source values multiplied unit weights, leaving unchanged. step 3, unmodified source values “modified” via aggregation, reduces number rows data relative original data. split relations, step 1 2 data modifying. Step 1 expands row count compared original data, least one row source label associated multiple target nodes. source values “duplicated” row-wise source-target link. step 2, source values modified according fractional link weights. Step 2 effectively “distributes” value linked target nodes. step 3, modification performed since, definition, split relations contain many--one links. number row remains step 1, rows relative original data. Finally, many--many relations, combination relation types, three steps data modifying. Similar collapsing relations, step 3 modifies via aggregation. However, prior aggregation, source values duplicated modified fractional link weights split relations. overall effect number rows depends many rows collapse relations aggregates relative many rows split relations create.","code":""},{"path":[]},{"path":"/articles/using-xmaps.html","id":"structure-of-original-dataset","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Structure of Original Dataset","title":"Using Crossmaps to Transform Data","text":"depend kind transformation? requirement {conformr} check validity","code":""},{"path":"/articles/using-xmaps.html","id":"recoding-categorical-variables","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Recoding Categorical Variables","title":"Using Crossmaps to Transform Data","text":"getting categorical variables nomenclature variable format bit tedious unnecessary, useful show equivalence? one-hot encoded categorical variables = nomenclature format","code":"baby_pets <- c(\"puppy\", \"kitten\", \"chick\") adult_pets <- c(\"dog\", \"cat\", \"bird\")  pet_xmap <- tibble::tibble(baby = baby_pets,                            adult = adult_pets,                            link = 1)  ## some data on pets pet_df <- tibble::tibble(obs_id = 1:5, pet_type = sample(baby_pets, 5, replace = TRUE), bool = 1)  ## categorical variable format pet_df ## # A tibble: 5 × 3 ##   obs_id pet_type  bool ##    <int> <chr>    <dbl> ## 1      1 chick        1 ## 2      2 puppy        1 ## 3      3 chick        1 ## 4      4 chick        1 ## 5      5 kitten       1 ## the format needed to use apply_xmap() pet_df |> tidyr::pivot_wider(names_from = \"pet_type\", values_from = \"bool\") |>   tidyr::pivot_longer(cols=dplyr::all_of(baby_pets)) |>   tidyr::replace_na(list(value = 0)) ## # A tibble: 15 × 3 ##    obs_id name   value ##     <int> <chr>  <dbl> ##  1      1 puppy      0 ##  2      1 kitten     0 ##  3      1 chick      1 ##  4      2 puppy      1 ##  5      2 kitten     0 ##  6      2 chick      0 ##  7      3 puppy      0 ##  8      3 kitten     0 ##  9      3 chick      1 ## 10      4 puppy      0 ## 11      4 kitten     0 ## 12      4 chick      1 ## 13      5 puppy      0 ## 14      5 kitten     1 ## 15      5 chick      0"},{"path":"/articles/using-xmaps.html","id":"dataset-coverage-requirement","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Dataset Coverage Requirement","title":"Using Crossmaps to Transform Data","text":"source nodes crossmap must fully cover nomenclature data transformed. equivalent saying crossmap contain transformation instructions every single piece data original dataset. figure , name-value pair category x7285! source data (shown purple) associated set relations proposed transformation crossmap (shown blue). Depending transformation implemented, coverage mismatches can result explicit implicit/hidden errors. particular, conformable matrix dimensions sufficient avoid corrupting data unless check indices match.","code":""},{"path":"/articles/using-xmaps.html","id":"only-split-or-collapse-nomenclature-pool-variables","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Only split or collapse nomenclature pool variables","title":"Using Crossmaps to Transform Data","text":"Crossmaps split collapse relations applied nomenclature pool variables measured values counts part aggregate pool. example, crossmap used aggregate disaggregate occupation counts shown : hand, non-count numeric variables averages aggregated disaggregated. case, makes sense use recoding crossmaps, since effectively crosswalks lookup tables leave measured values unmodified. example, beyond recoding industry labels, nomenclature transformation average weekly total cash earnings shown requires knowledge employee counts.","code":"## table 5: https://www.abs.gov.au/statistics/labour/jobs/jobs-australia/2015-16-2019-20 tibble::tribble(                                   ~Occupation, ~`Male.('000.persons)`, ~`Female.('000.persons)`,                                    \"Managers\",                  934.4,                    668.5,                               \"Professionals\",                 1190.9,                   1542.2,              \"Technicians and trades workers\",                 1229.7,                      225,      \"Community and personal service workers\",                    443,                    998.1,         \"Clerical and administrative workers\",                  373.5,                   1203.7,                               \"Sales workers\",                  382.6,                    651.4,             \"Machinery operators and drivers\",                  621.3,                     81.3,                                   \"Labourers\",                  815.5,                      437      ) |> knitr::kable() ## Table: All employees, average weekly total cash earnings - industry ## https://www.abs.gov.au/statistics/labour/earnings-and-working-conditions/employee-earnings-and-hours-australia/may-2021 tibble::tribble(                                               ~industry,  ~avg_weekly_earnings,                                                \"Mining\", \"2,798.40\",                                         \"Manufacturing\", \"1,457.40\",            \"Electricity, gas, water and waste services\", \"2,060.90\",                                          \"Construction\", \"1,600.40\",                                       \"Wholesale trade\", \"1,468.20\",                                          \"Retail trade\",   \"864.50\",                       \"Accommodation and food services\",   \"664.70\",                     \"Transport, postal and warehousing\", \"1,587.70\",              \"Information media and telecommunications\", \"1,797.40\",                        \"Finance and insurance services\", \"1,990.40\",               \"Rental, hiring and real estate services\", \"1,381.70\",       \"Professional, scientific and technical services\", \"1,911.30\",                   \"Administrative and support services\", \"1,234.50\",                      \"Public administration and safety\", \"1,745.40\",                                \"Education and training\", \"1,374.80\",                     \"Health care and social assistance\", \"1,287.40\",                          \"Arts and recreation services\", \"1,032.90\",                                        \"Other services\", \"1,043.10\",                                        \"**All industries**\", \"**1,394.10**\" ) |> knitr::kable()"},{"path":"/articles/using-xmaps.html","id":"handle-missing-values-before-crossmap-transformation","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Handle missing values before crossmap transformation","title":"Using Crossmaps to Transform Data","text":"Missing values dealt prior transformation can silently corrupt data collapse split transformations. figure shows nomenclature variable missing value unambiguously resolved crossmap transformation. missing value belongs source node part split collapse relations.  Naive application crossmap transformation implicitly attempts apply arithmetic operations missing values. However, missing values numbers, , make sense split NA half illustrated outgoing links x5555 node. Similarly, target node D6 receives NA numeric values multiple source nodes combined without additional preprocessing decisions. Handling missing values prior applying crossmap explicitly records decisions. instance, R, function sum() takes argument na.rm TRUE removes missing values sum. equivalent treating missing values 0 collapsing multiple source values target node, hence handled explicitly applying crossmap transformation. Exactly missing values treated vary dataset dataset. involve replace missing values zeroes imputed values, remove completely. Lastly, note crossmaps one--one recode relations avoids “missing value arithmetic” issue since missing values can passed unmodified target nomenclature. Nevertheless, still advisable handle missing values prior applying crossmap missing value decisions nomenclature transformations encoded separate steps.","code":""},{"path":"/articles/using-xmaps.html","id":"avoid-multiple-observations-for-each-source-node","dir":"Articles","previous_headings":"Apply xmap to data using Mutating Joins > xmap Usage Conditions","what":"Avoid multiple observations for each source node","title":"Using Crossmaps to Transform Data","text":"addition tidy structure requirement described , observational unit dataset, can span multiple rows, ideally one name-value pair unique node original nomenclature. ensures one numeric value transformed source-target link. strict requirement applying crossmap transformations mutating joins, avoids hidden aggregation across source nodes. Returning matrix representation, requirement equivalent uniquely indexed source value vector. dataset tidy crossmap subsector source nodes, considered tidy crossmap sector source nodes. solve , simply aggregate sector level, obtain set unique set name-value pairs sector level nomenclature variable.","code":"origin_tidy_sub <- tibble::tribble(   ~country, ~year, ~sector, ~subsector, ~output,   \"AU\", 2012, \"AGR\", \"FISH\", 3983,   \"AU\", 2012, \"AGR\", \"LIVE\", 432,   \"AU\", 2013, \"AGR\", \"FISH\", 3983,   \"AU\", 2013, \"AGR\", \"LIVE\", NA, )  origin_tidy_sub ## # A tibble: 4 × 5 ##   country  year sector subsector output ##   <chr>   <dbl> <chr>  <chr>      <dbl> ## 1 AU       2012 AGR    FISH        3983 ## 2 AU       2012 AGR    LIVE         432 ## 3 AU       2013 AGR    FISH        3983 ## 4 AU       2013 AGR    LIVE          NA origin_tidy_sec <- origin_tidy_sub |>   dplyr::group_by(country, year, sector) |>   dplyr::summarise(output = sum(output, na.rm = TRUE), .groups = \"drop\")  origin_tidy_sec ## # A tibble: 2 × 4 ##   country  year sector output ##   <chr>   <dbl> <chr>   <dbl> ## 1 AU       2012 AGR      4415 ## 2 AU       2013 AGR      3983"},{"path":"/articles/using-xmaps.html","id":"example-xmap-transformations","dir":"Articles","previous_headings":"","what":"Example xmap Transformations","title":"Using Crossmaps to Transform Data","text":"examples want include?","code":""},{"path":"/articles/using-xmaps.html","id":"xmap-aggregation","dir":"Articles","previous_headings":"Example xmap Transformations","what":"xmap Aggregation","title":"Using Crossmaps to Transform Data","text":"Let’s consider simple case disaggregated population figures want aggregate. First, define crossmap aggregation. Second, load state-level figures Now, assuming crossmap fully covers data transformation: Join aggregate groups (state) row state_data via source labels (adm1) Mutate source values (Pop) Summarising values group (state) good place put small-set illustration? using apply_xmap() conformr package: also checks nomenclature data_in fully covered xmap – .e. don’t lose source values step 1 join.","code":"library(xmap)  agg_map <- data.frame(ctr = \"AU\",                       adm1 = c(\"AU-NSW\", \"AU-QLD\", \"AU-SA\", \"AU-TAS\", \"AU-VIC\", \"AU-WA\", \"AU-ACT\", \"AU-NT\"),                       link = 1) |>   as_xmap_df(adm1, ctr, link) state_data <- tibble::tribble(                               ~state,    ~adm1,    ~Pop,                    \"New South Wales\", \"AU-NSW\", 8153600,                           \"Victoria\", \"AU-VIC\", 6613700,                         \"Queensland\", \"AU-QLD\", 5322100,                    \"South Australia\",  \"AU-SA\", 1820500,                  \"Western Australia\",  \"AU-WA\", 2785300,                           \"Tasmania\", \"AU-TAS\",  571500,                 \"Northern Territory\",  \"AU-NT\",  250600,       \"Australian Capital Territory\", \"AU-ACT\",  456700 ) dplyr::left_join(state_data, agg_map, by = c(\"adm1\")) |>   dplyr::mutate(x_pop = Pop * link) |>   dplyr::group_by(ctr) |>   dplyr::summarise(agg_pop = sum(x_pop)) ## # A tibble: 1 × 2 ##   ctr    agg_pop ##   <chr>    <dbl> ## 1 AU    25974000 conformr::apply_xmap(data_in = state_data, xmap = agg_map,                      in_codes = adm1, in_values = Pop,                      out_codes = NULL, out_values = NULL)"},{"path":"/articles/using-xmaps.html","id":"xmap-disaggregation","dir":"Articles","previous_headings":"Example xmap Transformations","what":"xmap Disaggregation","title":"Using Crossmaps to Transform Data","text":"can reverse aggregation (assuming retained appropriate weights) using: add simple example","code":"apply_xmap(data_in = ctr_data, xmap = disagg_map, in_codes = ctr, in_values = Pop, out_codes = NULL, out_values = NULL)"},{"path":"/articles/using-xmaps.html","id":"wild-caught-hierarchical-nomenclature-data","dir":"Articles","previous_headings":"Example xmap Transformations","what":"Wild Caught (Hierarchical) Nomenclature Data","title":"Using Crossmaps to Transform Data","text":"Let’s tidy wild caught dataset: Let’s start standard data import tidying: removing first two rows table notes giving first column sensible name. table unfortunately tidy nomenclature format.","code":"aus_pop <- \"data-raw/abs-population_2022.xlsx\" aus_pop <- readabs::download_abs_data_cube(\"national-state-and-territory-population\", \"31010do001_202206.xlsx\") raw_abs_pop <- readxl::read_xlsx(aus_pop,                                sheet = \"Table_3\", range = \"A6:D23\") raw_abs_pop <-     tibble::tribble(                                        ~...1,     ~X2002,     ~X2012,     ~X2022,                                           NA,      \"no.\",      \"no.\",      \"no.\",                  \"Australia–at 30 September\",         NA,         NA,         NA,                            \"New South Wales\",  \"6580807\",  \"7304244\",  \"8153584\",                                   \"Victoria\",  \"4817774\",  \"5651091\",  \"6613727\",                                 \"Queensland\",  \"3653123\",  \"4568687\",  \"5322058\",                            \"South Australia\",  \"1511567\",  \"1656725\",  \"1820530\",                          \"Western Australia\",  \"1928512\",  \"2425507\",  \"2785312\",                                   \"Tasmania\",   \"474152\",   \"511724\",   \"571517\",                         \"Northern Territory\",   \"202251\",   \"235915\",   \"250635\",               \"Australian Capital Territory\",   \"324627\",   \"376539\",   \"456652\",                          \"Other Territories\",         NA,         NA,         NA,                       \"Jervis Bay Territory\",      \"464\",      \"380\",      \"312\",              \"Territory of Christmas Island\",     \"1365\",     \"2107\",     \"1781\",       \"Territory of Cocos (Keeling) Islands\",      \"568\",      \"546\",      \"614\",                             \"Norfolk Island\",        \"0\",        \"0\",     \"2213\",                    \"Total Other Territories\",     \"2397\",     \"3033\",     \"4920\",                            \"Total Australia\", \"19495210\", \"22733465\", \"25978935\"       ) abs_pop <- raw_abs_pop |>   dplyr::slice(3:dplyr::n()) |>   dplyr::rename(area = `...1`)  knitr::kable(abs_pop)"},{"path":"/articles/using-xmaps.html","id":"issue-1-multiple-nomenclature-variables-in-the-same-table","dir":"Articles","previous_headings":"Example xmap Transformations > Wild Caught (Hierarchical) Nomenclature Data","what":"Issue 1: Multiple Nomenclature Variables in the Same Table","title":"Using Crossmaps to Transform Data","text":"First, table contains values multiple hierarchical levels. particular, aggregate values country level (Australia), sub-group level (Territories). Assume disaggregated values nomenclature variable interested . Now, split table remove totals “Territories” divider row:","code":"abs_split <- split(abs_pop, stringr::str_detect(abs_pop$area, \"Total|Other Territories\", negate = TRUE)) state_pop <- abs_split$`TRUE`  knitr::kable(state_pop)"},{"path":"/articles/using-xmaps.html","id":"issue-2-observation-units-split-across-columns","dir":"Articles","previous_headings":"Example xmap Transformations > Wild Caught (Hierarchical) Nomenclature Data","what":"Issue 2: Observation Units split across columns","title":"Using Crossmaps to Transform Data","text":"notice observational unit want apply aggregation transformation year. Hence, pivot dataset longer:","code":"state_nom <- state_pop |>   tidyr::pivot_longer(cols = -area, names_to = \"year\", values_to = \"population\") |>   dplyr::select(year, dplyr::everything()) |>   dplyr::arrange(year)  knitr::kable(state_nom)"},{"path":[]},{"path":"/articles/vis-xmaps.html","id":"alternative-representations-of-crossmaps","dir":"Articles","previous_headings":"","what":"Alternative representations of Crossmaps","title":"Visualising Crossmap Transformations","text":"Crossmaps aim encode dataset integration harmonisation choices separately code used apply designs data. follows visualisations plots candidate crossmaps useful design process. instance, Sankey diagrams sometimes used visualise schema crosswalks. article provides ggplot2 code examples visualising crossmaps. code eventually live ggplot2 extension package.","code":"library(ggplot2) library(dplyr) library(ggbump) library(xmap)"},{"path":"/articles/vis-xmaps.html","id":"table","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Table","title":"Visualising Crossmap Transformations","text":"Let’s start visualising section ANZSCO22 ISCO8 crosswalk published Australian Bureau Statistics: included print() method xmap_df objects:","code":"anzsco_cw <- tibble::tribble(       ~anzsco22,                        ~anzsco22_descr, ~isco8, ~partial,                                         ~isco8_descr,        \"111111\", \"Chief Executive or Managing Director\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111111\", \"Chief Executive or Managing Director\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111111\", \"Chief Executive or Managing Director\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111211\",            \"Corporate General Manager\", \"1112\",      \"p\",                        \"Senior government officials\",        \"111211\",            \"Corporate General Manager\", \"1114\",      \"p\", \"Senior officials of special-interest organizations\",        \"111211\",            \"Corporate General Manager\", \"1120\",      \"p\",            \"Managing directors and chief executives\",        \"111212\",         \"Defence Force Senior Officer\", \"0110\",      \"p\",                 \"Commissioned armed forces officers\",        \"111311\",          \"Local Government Legislator\", \"1111\",      \"p\",                                        \"Legislators\",        \"111312\",                 \"Member of Parliament\", \"1111\",      \"p\",                                        \"Legislators\",        \"111399\",                      \"Legislators nec\", \"1111\",      \"p\",                                        \"Legislators\"       )  links <- anzsco_cw |>   dplyr::group_by(anzsco22) |>   dplyr::summarise(n_dest = dplyr::n_distinct(isco8)) |>   dplyr::ungroup() |>   dplyr::transmute(anzsco22, weight = 1/n_dest) |>   dplyr::left_join(anzsco_cw, by = \"anzsco22\") ## Warning in dplyr::left_join(dplyr::transmute(dplyr::ungroup(dplyr::summarise(dplyr::group_by(anzsco_cw, : Each row in `x` is expected to match at most 1 row in `y`. ## ℹ Row 1 of `x` matches multiple rows. ## ℹ If multiple matches are expected, set `multiple = \"all\"` to silence this ##   warning. ## get code tables table_anzsco <- anzsco_cw |>   dplyr::distinct(anzsco22, anzsco22_descr) table_isco8 <- anzsco_cw |>   dplyr::distinct(isco8, isco8_descr)  ## make xmap anzsco_xmap <- links |>   as_xmap_df(anzsco22, isco8, weight) ## Dropped additional columns in `links` print(anzsco_xmap) ## xmap_df: ## recode, split, and collapse   ## (anzsco22 -> isco8) BY weight ##    anzsco22 isco8    weight ## 1    111111  1112 0.3333333 ## 2    111111  1114 0.3333333 ## 3    111111  1120 0.3333333 ## 4    111211  1112 0.3333333 ## 5    111211  1114 0.3333333 ## 6    111211  1120 0.3333333 ## 7    111212  0110 1.0000000 ## 8    111311  1111 1.0000000 ## 9    111312  1111 1.0000000 ## 10   111399  1111 1.0000000"},{"path":"/articles/vis-xmaps.html","id":"bigraph","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Bigraph","title":"Visualising Crossmap Transformations","text":"Visualisation bigraph particularly useful seeing relations two nomenclature.  visualisation also benefits traditionally used Sankey diagram. Sankey diagrams often used illustrated “flows” nodes. However, variable link widths can actually clutter visualisation crosswalks. Consider simple crossmap might used harmonise national accounts data (e.g. GDP) across two time periods.  hand, bigraph visualisation shows clearly data modified () harmonising nomenclature. solid lines show link modify source values, whilst dotted line style indicates data split . Furthermore, using fixed width links, room place labels -top curve indicated transformation weights.","code":".bigraph_add_link_style <- function(edges, x_attrs, ...) {   ## generate out link type   style_out_case <- tibble::tribble(     ~out_case, ~line_type, ~font_type,     \"unit_out\", \"solid\", \"bold\",     \"frac_out\", \"dashed\", \"italic\")   edges |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"unit_out\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"frac_out\")) |>     dplyr::left_join(style_out_case,               by = \"out_case\") |>     dplyr::ungroup() }  .bigraph_add_node_positions <- function(edges, x_attrs, pos_from, pos_to, ...) {   ## attach node positions   edges |>     dplyr::left_join(pos_from, by = setNames(\"from_set\", x_attrs$col_from)) |>     dplyr::left_join(pos_to, by = setNames(\"to_set\", x_attrs$col_to)) |>     dplyr::mutate(from_x = 0,                   to_x = 5) |>     dplyr::mutate(idx = dplyr::row_number()) }  plt_xmap_bigraph <- function(x, ...) {   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_short <- tibble::as_tibble(x)      df_out_style <- .bigraph_add_link_style(edges_short, x_attrs)      ## generate node positions   from_nodes <- tibble::tibble(from_set = x_attrs$from_set) |>     dplyr::mutate(from_y = dplyr::row_number())   to_nodes <- tibble::tibble(to_set = unique(x[[x_attrs$col_to]])) |>     dplyr::mutate(to_y = dplyr::row_number() - 1 + 0.5)      df_gg <- .bigraph_add_node_positions(df_out_style, x_attrs,                                        from_nodes, to_nodes)   ## build ggplot   ggplot2::ggplot(data = df_gg,                   aes(x = from_x, xend = to_x,                       y = from_y, yend = to_y,                       group = idx)) +     ## edges     ggbump::geom_sigmoid(aes(linetype = I(line_type))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"unit_out\"),              aes(x = (from_x + to_x) / 4,                  y = from_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ggplot2::geom_label(data = dplyr::filter(df_gg, out_case == \"frac_out\"),              aes(x = (((from_x + to_x) / 2) + to_x) / 2,                  y = to_y,                  label = round(.data[[x_attrs$col_weights]], 2))) +     ## from nodes     ggplot2::geom_text(aes(x = from_x - 0.5, y = from_y,                            label = .data[[x_attrs$col_from]],                            fontface=I(font_type)),                       ## drop idx groups to avoid duplicate labels                       stat = \"unique\", inherit.aes = FALSE) +     ## to nodes     ggplot2::geom_label(aes(x = to_x + 0.5, y = to_y,                              label = .data[[x_attrs$col_to]]),                         fill = \"black\",                         alpha = 0.1) +     ggplot2::scale_y_reverse() +     ggplot2::theme_minimal() +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank(),         axis.text.y = element_blank(),         axis.text.x = element_blank(),         plot.background = element_rect(fill = \"white\")) +     labs(x = NULL, y = NULL) } edges <- tribble(~ctr, ~ctr2, ~split,                  \"BLX\", \"BEL\", 0.5,                  \"BLX\", \"LUX\", 0.5,                  \"E.GER\", \"DEU\", 1,                  \"W.GER\", \"DEU\", 1)"},{"path":"/articles/vis-xmaps.html","id":"matrix","dir":"Articles","previous_headings":"Alternative representations of Crossmaps","what":"Matrix","title":"Visualising Crossmap Transformations","text":"Another useful visualisation representation crossmap incidence matrix source nomenclature indexed along rows target nomenclature indexed columns:  Notice requirement valid crossmap outgoing weights sum 1 source node equivalent requirement total weights across row sums 1.","code":"plt_xmap_ggmatrix <- function(x, ...){   stopifnot(is_xmap_df(x))   x_attrs <- attributes(x)   edges_complete <- tibble::as_tibble(x) |>      tidyr::complete(.data[[x_attrs$col_from]], .data[[x_attrs$col_to]])      ## add link-out type   gg_df <- edges_complete |>     dplyr::mutate(out_case = dplyr::case_when(.data[[x_attrs$col_weights]] == 1 ~ \"one-to-one\",                                               .data[[x_attrs$col_weights]] < 1 ~ \"one-to-many\",                                               is.na(.data[[x_attrs$col_weights]]) ~ \"none\")                   )      ## make plot   gg_df |> ggplot(aes(x=.data[[x_attrs$col_to]],                       y=.data[[x_attrs$col_from]])) +     geom_tile(aes(fill=out_case), col=\"grey\") +     scale_y_discrete(limits=rev) +     scale_x_discrete(position='top') +     scale_fill_brewer() +     coord_fixed()  +     labs(x = x_attrs$col_to, y = x_attrs$col_from, fill=\"Outgoing Link Type\") +     theme_minimal() +     geom_text(data = dplyr::filter(gg_df, !is.na(.data[[x_attrs$col_weights]])), aes(label=round(.data[[x_attrs$col_weights]], 2))) +     theme(legend.position = \"bottom\",         panel.grid.major = element_blank(),         panel.grid.minor = element_blank()     ) } plt_xmap_ggmatrix(anzsco_xmap)"},{"path":"/articles/vis-xmaps.html","id":"visualising-types-of-mapping-relations","dir":"Articles","previous_headings":"","what":"Visualising Types of Mapping Relations","title":"Visualising Crossmap Transformations","text":"","code":"library(patchwork)  gg_recode + gg_agg + gg_disagg"},{"path":"/articles/xmap.html","id":"creating-an-xmap-object","dir":"Articles","previous_headings":"","what":"Creating an xmap object","title":"Crossmaps for Data Transformation in R","text":"already valid crossmap table, turn xmap object specifying source () nodes, target () nodes, weights (weights): See vignette(\"making-xmaps.Rmd\") details validation conditions creating custom weights.","code":"links |>   as_xmap_df(from = ISIC2, to = ISIC3, weights = shares)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Cynthia Huang. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huang C (2023). xmap: xmap: data-structure extending crosswalks. R package version 0.0.0.9017.","code":"@Manual{,   title = {xmap: xmap: A data-structure for extending crosswalks},   author = {Cynthia Huang},   year = {2023},   note = {R package version 0.0.0.9017}, }"},{"path":"/index.html","id":"xmap-crossmaps-for-data-integration-in-r","dir":"","previous_headings":"","what":"xmap: A data-structure for extending crosswalks","title":"xmap: A data-structure for extending crosswalks","text":"xmap provides tools creating, validating modifying Nomenclature Crossmaps use Data Integration Harmonisation workflows (.e. {conformr}).","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"xmap: A data-structure for extending crosswalks","text":"install latest development version xmap:","code":"remotes::install_github(\"cynthiahqy/conformr-project\", subdir = \"xmap\")"},{"path":"/reference/as_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if object is a crossmap — is_xmap","title":"Test if object is a crossmap — is_xmap","text":"function returns TRUE crossmaps xmap subclasses thereof (xmap_df), FALSE objects, including regular data.frames tibbles.","code":""},{"path":"/reference/as_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if object is a crossmap — is_xmap","text":"","code":"is_xmap(x)  is_xmap_df(x)"},{"path":"/reference/as_xmap_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce objects to xmap_df — as_xmap_df","title":"Coerce objects to xmap_df — as_xmap_df","text":"Validates creates valid crossmap xmap_df object.","code":""},{"path":"/reference/as_xmap_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce objects to xmap_df — as_xmap_df","text":"","code":"as_xmap_df(x, from, to, weights, subclass = c(\"xmap_df\"), ...)  # S3 method for data.frame as_xmap_df(x, from, to, weights, subclass = \"xmap_df\", .drop_extra = TRUE)"},{"path":"/reference/as_xmap_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce objects to xmap_df — as_xmap_df","text":"x as_xmap_df(): object coerce is_xmap_df(): object test. , Columns x specifying source target nodes weights Column x specifying weight applied data passed along directed link source target node subclass xmap subclass return. Defaults xmap_df data.frame tibble .drop_extra Drop columns , weights. Defaults TRUE","code":""},{"path":"/reference/as_xmap_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce objects to xmap_df — as_xmap_df","text":"validated xmap object.","code":""},{"path":"/reference/as_xmap_df.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Coerce objects to xmap_df — as_xmap_df","text":"as_xmap_df(data.frame): Coerce data.frame xmap","code":""},{"path":"/reference/as_xmap_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce objects to xmap_df — as_xmap_df","text":"","code":"# For a well formed crossmap: links <- data.frame(   a = \"AUS\",   b = c(\"VIC\", \"NSW\", \"WA\", \"OTHER\"),   w = c(0.1, 0.15, 0.25, 0.5) ) as_xmap_df(links, from = a, to = b, weights = w) #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50  # extra columns are dropped, links$extra <- c(2, 4, 5, 6) as_xmap_df(links, from = a, to = b, weights = w) #> Dropped additional columns in `links` #> xmap_df: #> split  #> (a -> b) BY w #>     a     b    w #> 1 AUS   VIC 0.10 #> 2 AUS   NSW 0.15 #> 3 AUS    WA 0.25 #> 4 AUS OTHER 0.50"},{"path":"/reference/df_check.html","id":null,"dir":"Reference","previous_headings":"","what":"xmap_df validation helpers — df_check","title":"xmap_df validation helpers — df_check","text":"Checks issues xmap_df object.","code":""},{"path":"/reference/df_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"xmap_df validation helpers — df_check","text":"","code":"df_check_cols(df, col_attrs)  df_check_na(df)  df_check_col_order(df, col_from, col_to, col_weights)  df_check_col_type(df, col_weights)  df_check_from_set(df, col_from, from_set)  df_check_links(df, col_from, col_to)  df_check_weights(df, col_from, col_weights)  df_check_reversible(df, col_to)"},{"path":"/reference/df_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"xmap_df validation helpers — df_check","text":"df data.frame-like object containing crossmap col_* character vector values naming columns df","code":""},{"path":"/reference/df_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"xmap_df validation helpers — df_check","text":"error validation condition fails, invisibly returns df otherwise.","code":""},{"path":"/reference/df_check.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"xmap_df validation helpers — df_check","text":"df_check_cols(): Abort named columns found xmap_df df_check_na(): Abort xmap_df missing values df_check_col_order(): Abort xmap_df columns order df_check_col_type(): Abort xmap_df wrong column types df_check_from_set(): Abort from_set attribute match xmap_df values df_check_links(): Abort xmap_df duplicate links df_check_weights(): Abort df invalid mapping weights df_check_reversible(): Abort xmap_df wrong column types","code":""},{"path":"/reference/new_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Low Level Constructors for xmap subclasses — new_xmap","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"Low Level Constructors xmap subclasses","code":""},{"path":"/reference/new_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"","code":"new_xmap_df(x, col_from, col_to, col_weights, from_set = NULL)"},{"path":"/reference/new_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"x data-frame like object. col_from, col_to, col_weights character strings naming columns containing source nodes, target nodes numeric weights.","code":""},{"path":"/reference/new_xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"xmap_df object. Note function unclasses tibbles. x additional subclasses xmap_df xmap","code":""},{"path":"/reference/new_xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Low Level Constructors for xmap subclasses — new_xmap","text":"new_xmap_df(): Construct xmap_df data.frame checks argument types naively generates from_set missing","code":""},{"path":"/reference/op-null-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Defaults for NULL values — op-null-default","title":"Defaults for NULL values — op-null-default","text":"Defaults NULL values","code":""},{"path":"/reference/op-null-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defaults for NULL values — op-null-default","text":"","code":"x %||% y"},{"path":"/reference/print.xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an xmap object — print.xmap","title":"Print an xmap object — print.xmap","text":"Print xmap object","code":""},{"path":"/reference/print.xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an xmap object — print.xmap","text":"","code":"# S3 method for xmap_df print(x)"},{"path":"/reference/print.xmap.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Print an xmap object — print.xmap","text":"print(xmap_df): Print xmap_df","code":""},{"path":"/reference/validate_xmap_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Validator for xmap_df objects — validate_xmap_df","title":"Validator for xmap_df objects — validate_xmap_df","text":"Validator xmap_df objects","code":""},{"path":"/reference/validate_xmap_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validator for xmap_df objects — validate_xmap_df","text":"","code":"validate_xmap_df(x)"},{"path":"/reference/xmap-has.html","id":null,"dir":"Reference","previous_headings":"","what":"Boolean flags for xmap properties — xmap-has","title":"Boolean flags for xmap properties — xmap-has","text":"has_*() is_*() functions check properties used validate /print xmaps. functions accepts equal length vector inputs support subclasses xmap, check inputs xmap.","code":""},{"path":"/reference/xmap-has.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boolean flags for xmap properties — xmap-has","text":"","code":"has_dup_links(x_from, x_to)  has_complete_weights(x_from, x_weights)  has_1to1(x_weights)  has_1toM(x_weights)  has_1fromM(x_to)"},{"path":"/reference/xmap-has.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boolean flags for xmap properties — xmap-has","text":"x_from, x_to, x_weights equal length vectors containing source-target node pairs","code":""},{"path":"/reference/xmap-has.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Boolean flags for xmap properties — xmap-has","text":"has_dup_links(): Returns TRUE xmap duplicate links has_complete_weights(): Returns TRUE xmap valid weights has_1to1(): Return TRUE xmap recodes labels has_1toM(): Return TRUE xmap splitting links has_1fromM(): Return TRUE xmap collapsing links ","code":""},{"path":"/reference/xmap_drop_extra.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop extra columns from xmap objects — xmap_drop_extra","title":"Drop extra columns from xmap objects — xmap_drop_extra","text":"Drop extra columns xmap objects","code":""},{"path":"/reference/xmap_drop_extra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop extra columns from xmap objects — xmap_drop_extra","text":"","code":"xmap_drop_extra(x)"},{"path":"/reference/xmap_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse xmap direction — xmap_reverse","title":"Reverse xmap direction — xmap_reverse","text":"Reverse xmap direction","code":""},{"path":"/reference/xmap_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse xmap direction — xmap_reverse","text":"","code":"xmap_reverse(x, weights_into)  # S3 method for xmap_df xmap_reverse(x, weights_into = \"r_weights\")"},{"path":"/reference/xmap_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse xmap direction — xmap_reverse","text":"x xmap object reversed weights_into string specifying name new existing column store reverse weights .","code":""},{"path":"/reference/xmap_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse xmap direction — xmap_reverse","text":"xmap object class x, throws error x reversible","code":""},{"path":"/reference/xmap_reverse.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Reverse xmap direction — xmap_reverse","text":"xmap_reverse(xmap_df): Reverse xmap_df","code":""},{"path":"/reference/xmap_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract incidence matrix from xmap objects — xmap_to_matrix","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"Transforms xmap objects incidence matrix rows indexed values columns indexed values. Drops additional variables.","code":""},{"path":"/reference/xmap_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"","code":"xmap_to_matrix(x, sparse, ...)  # S3 method for xmap_df xmap_to_matrix(x, sparse = TRUE)"},{"path":"/reference/xmap_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"x xmap object sparse logical specifying result sparse matrix. Defaults TRUE. ... Unused","code":""},{"path":"/reference/xmap_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"matrix sparse matrix object","code":""},{"path":"/reference/xmap_to_matrix.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"xmap_to_matrix(xmap_df): Coerce data.frame xmap","code":""},{"path":"/reference/xmap_to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract incidence matrix from xmap objects — xmap_to_matrix","text":"","code":"abc_xmap <- data.frame(  stringsAsFactors = FALSE,                  origin = c(\"a\",\"b\",\"c\",\"d\",\"e\",                           \"f\",\"g\",\"h\",\"i\",\"i\",\"j\",\"j\",\"j\"),                    dest = c(\"AA\",\"AA\",\"AA\",\"AA\",                           \"BB\",\"BB\",\"CC\",\"DD\",\"EE\",\"FF\",\"GG\",\"HH\",\"II\"),            link = c(1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0.5, 0.3, 0.3, 0.4)  ) |> as_xmap_df(origin, dest, link) xmap_to_matrix(abc_xmap) #> 10 x 9 sparse Matrix of class \"dgCMatrix\" #>       dest #> origin AA BB CC DD  EE  FF  GG  HH  II #>      a  1  .  .  . .   .   .   .   .   #>      b  1  .  .  . .   .   .   .   .   #>      c  1  .  .  . .   .   .   .   .   #>      d  1  .  .  . .   .   .   .   .   #>      e  .  1  .  . .   .   .   .   .   #>      f  .  1  .  . .   .   .   .   .   #>      g  .  .  1  . .   .   .   .   .   #>      h  .  .  .  1 .   .   .   .   .   #>      i  .  .  .  . 0.5 0.5 .   .   .   #>      j  .  .  .  . .   .   0.3 0.3 0.4"}]

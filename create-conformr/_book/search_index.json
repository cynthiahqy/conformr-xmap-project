[["index.html", "Creating the frombookdown R package 1 Introduction", " Creating the frombookdown R package Jacob Bien 2022-11-16 1 Introduction Note: If you are working in RStudio, you can simply press ‚ÄúKnit‚Äù to render this bookdown (and open _book/index.html to see the result). More generally, in a console you can run the following: litr::render(&quot;index.Rmd&quot;, output_format = litr::litr_gitbook()) "],["package-setup.html", "2 Package setup 2.1 Dependencies 2.2 Utilities", " 2 Package setup Every R package needs a DESCRIPTION file, so we start by specifying this information: usethis::create_package( path = &quot;.&quot;, fields = list( Package = params$package_name, Version = &quot;0.0.0.9000&quot;, Title = &quot;A Package Defined in a Bookdown&quot;, Description = &quot;This package uses litr to define an R package through writing a bookdown.&quot;, `Authors@R` = person( given = &quot;Cynthia&quot;, family = &quot;Huang&quot;, email = &quot;cynthia@gmail.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;) ) ) ) usethis::use_mit_license(copyright_holder = &quot;C. Huang&quot;) Although it‚Äôs not required, it can be nice to add some package-level documentation. This is what will show up when someone types package?&lt;your-package-name&gt; in the console. #&#39; A Package Defined in a Bookdown #&#39; #&#39; This package uses `litr` to define an R package through writing a `bookdown`. #&#39; #&#39; @docType package 2.1 Dependencies ## imports usethis::use_package(&quot;dplyr&quot;) ## suggests ## ## ‚úî Adding &#39;dplyr&#39; to Imports field in DESCRIPTION ## ‚Ä¢ Refer to functions with `dplyr::fun()` 2.2 Utilities #&#39; Defaults for NULL values `%||%` &lt;- function(x, y) if (is.null(x)) y else x "],["toy-objects.html", "3 Toy Objects 3.1 Ideal Case 3.2 Basic Panel Map 3.3 Valid Panel Maps 3.4 generate code_dict with weights 3.5 generate panel_map_BA 3.6 generate data_map 3.7 final data // collapse destination codes with multiple transfers", " 3 Toy Objects 3.1 Ideal Case IDEAL CASE code_dict: cover all mapping types data_in: include case variable (country) group_in: data_in grouped by case multiple values 3.2 Basic Panel Map In the most simple case, to make a panel map, we need only a correspondence between a source nomenclature (std_A) and target nomenclature (std_B), which doesn‚Äôt have any duplicate rows. set.seed(1832) ## correspondence/concordance table codes_BA &lt;- dplyr::tribble(~ std_B, ~ std_A, &quot;A1&quot;, &quot;x1111&quot;, # one-to-one &quot;B2&quot;, &quot;x2222&quot;, # many-to-one &quot;B2&quot;, &quot;x3333&quot;, &quot;C3&quot;, &quot;x4444&quot;, # one-to-many (4) &quot;C4&quot;, &quot;x4444&quot;, &quot;C4&quot;, &quot;x6666&quot;, # many-to-many &quot;C5&quot;, &quot;x4444&quot;, &quot;C6&quot;, &quot;x4444&quot;, &quot;C7&quot;, &quot;x5555&quot;, # one-to-many (3) &quot;C8&quot;, &quot;x5555&quot;, &quot;C9&quot;, &quot;x5555&quot; ) ## panel_map weights_BA &lt;- codes_BA |&gt; dplyr::distinct(std_B, std_A) |&gt; dplyr::group_by(std_A) |&gt; dplyr::mutate(n_dest = dplyr::n(), weight = 1 / n_dest) |&gt; dplyr::ungroup() pm_BA &lt;- weights_BA |&gt; dplyr::select(std_B, std_A, weight) Write this data into the package for testing purposes equal_pm &lt;- list(&quot;codes_BA&quot; = codes_BA, &quot;weights_BA&quot; = weights_BA, &quot;pm_BA&quot; = pm_BA) usethis::use_data(equal_pm, internal = TRUE, overwrite = TRUE) ## ‚úî Adding &#39;R&#39; to Depends field in DESCRIPTION ## ‚úî Saving &#39;equal_pm&#39; to &#39;R/sysdata.rda&#39; We can visualise a panel map as the addition of weights to the concordance: library(ggplot2) inc_mtx_long &lt;- tidyr::expand(codes_BA, std_A, std_B) |&gt; dplyr::left_join(pm_BA, by = c(&quot;std_A&quot;, &quot;std_B&quot;)) |&gt; dplyr::transmute(to = std_B, from = std_A, weight = weight) gg_inc_mtx &lt;- inc_mtx_long |&gt; dplyr::mutate(src_case = dplyr::case_when(weight==1 ~ &quot;one-to-one&quot;, is.na(weight) ~ &quot;none&quot;, weight &lt; 1 ~ &quot;one-to-many&quot;)) |&gt; ggplot(aes(x=to, y=from)) + geom_tile(aes(fill=src_case), col=&quot;grey&quot;) + scale_y_discrete(limits=rev) + scale_fill_brewer() + coord_fixed() + labs(x = element_blank(), y = element_blank(), fill=&quot;source-to-target&quot;) + theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle(&quot;Concordance as Incidence Matrix&quot;) gg_pm_mtx &lt;- gg_inc_mtx + geom_text(data = dplyr::filter(inc_mtx_long, !is.na(weight)), aes(label=round(weight, 2))) + ggtitle(&quot;adding equal weights for Valid Panel Map&quot;) 3.2.1 Helper Function: Make an equal weight panel map This is a helper function for making a valid panel map. gg_inc_mtx 3.2.1.1 Tests gg_pm_mtx ## Test passed üéâ 3.3 Valid Panel Maps 3.3.1 Single Source Variable In the most simple case, we have one source variable which we are trying to apply the concordance to. #&#39; Helper to build equal split panel map #&#39; #&#39; Generate panel map using all *distinct* correspondences between two classifications. #&#39; #&#39; @param code_dict Data frame containing correspondence between source and destination codes #&#39; @param code_in Variable in `code_dict` containing source codes to convert from. #&#39; @param code_out Variable in `code_dict` containing destination codes to convert to. #&#39; @param .weights_to (optional) new column name for storing weights that will be applied to #&#39; input values. #&#39; #&#39; @return Returns panel map #&#39; @export #&#39; #&#39; @examples make_pm_equal &lt;- function(code_dict, code_in, code_out, .weights_to = NULL){ ## check for duplicates if (any(duplicated(code_dict))) { message(&quot;Removing duplicate code_in/code_out rows&quot;) code_dict &lt;- code_dict %&gt;% dplyr::distinct({{code_in}}, {{code_out}}) } else { } ## code names as strings ## make column name for weights .weights_to &lt;- .weights_to %||% paste(&quot;split&quot;, deparse(substitute(code_in)), sep = &quot;_&quot;) panel_map &lt;- code_dict |&gt; dplyr::group_by({{code_in}}) |&gt; dplyr::mutate(&quot;n_dest&quot; = dplyr::n(), ## no need for n_distinct after duplicates removed !!.weights_to := 1 / n_dest) |&gt; dplyr::ungroup() |&gt; dplyr::select(-n_dest) return(panel_map) } 3.3.2 Basic Panel Map, Multiple Source Variables data_in &lt;- tidyr::expand_grid(country = c(‚ÄúAUS‚Äù, ‚ÄúJPN‚Äù), std_A = code_in) %&gt;% dplyr::mutate(A_100 = 100, A_prod = abs(rnorm(nrow(.))) * 10000) %&gt;% dplyr::mutate(value_str = stringi::stri_rand_strings(nrow(.), 5)) ## bad value!) 3.4 generate code_dict with weights eps &lt;- 0.001 # small ‚Äúdust‚Äù to mess up weights weights_BA &lt;- codes_BA %&gt;% dplyr::group_by(std_A) %&gt;% dplyr::mutate(n_dest = dplyr::n_distinct(std_B), weight = 1 / n_dest) %&gt;% dplyr::ungroup() %&gt;% # add bad weights dplyr::mutate(weight_more = dplyr::case_when(weight == 1 ~ weight, TRUE ~ weight + eps), weight_less = dplyr::case_when(n_dest == 3 ~ 0.33, n_dest == 4 ~ 0.2, TRUE ~ weight) ) 3.5 generate panel_map_BA panel_map &lt;- weights_BA %&gt;% select(std_B, std_A, weight) 3.6 generate data_map data_map_BA &lt;- dplyr::left_join(data_in, weights_BA, by = ‚Äústd_A‚Äù) 3.7 final data // collapse destination codes with multiple transfers data_AB_out &lt;- data_map_BA %&gt;% dplyr::group_by(country) %&gt;% dplyr::mutate(across(starts_with(‚ÄúA_‚Äù), ~ .x * weight)) %&gt;% dplyr::group_by(std_B, .add = TRUE) %&gt;% dplyr::summarise(dplyr::across(starts_with(‚ÄúA_‚Äù), ~ sum(.x), .names = ‚Äú{.col}_out‚Äù), .groups = ‚Äúdrop_last‚Äù) toy_AB &lt;- list(‚Äúdata_in‚Äù = data_in, ‚Äúcodes_BA‚Äù = codes_BA, ‚Äúweights_BA‚Äù = weights_BA, ‚Äúpm_BA‚Äù = panel_map, ‚Äúdata_map‚Äù = data_map_BA, ‚Äúdata_out‚Äù = data_AB_out) ## Breaking Cases BREAKING CASES for tests [x] data_in: include BAD non-numeric value column [x] code_dict: include BAD weights -- sum &gt; 1 [x] code_dict: include BAD weights -- sum &lt; 1? [&gt;] code_dict: remove mapping for one origin code in TEST [&gt;] code_dict: include duplicate mapping in TEST Let&#39;s define a function for our R package: ```r testthat::test_that( &quot;make_pm_equal() works&quot;, { testthat::expect_identical( make_pm_equal(equal_pm$codes_BA, std_A, std_B, .weights_to = &quot;weight&quot;), equal_pm$pm_BA) } ) Code chunks whose first line starts with #' are added to the package. We can try running it. ## source data code_in &lt;- dplyr::distinct(codes_BA, std_A) data_in &lt;- code_in |&gt; dplyr::mutate(A_100 = 100) ## [1] &quot;Hello Jacob!&quot; That code chunk does not start with #', so it is not added to the package. Let‚Äôs write some tests to make sure the function behaves as desired: #&#39; Say hello to someone #&#39; #&#39; @param name Name of a person #&#39; @param exclamation Whether to include an exclamation mark #&#39; @export say_hello &lt;- function(name, exclamation = TRUE) { paste0(&quot;Hello &quot;, name, ifelse(exclamation, &quot;!&quot;, &quot;.&quot;)) } ## Test passed üåà Code chunks that have one or more lines starting with test_that( (or testthat::test_that() are added to the package as tests. "],["generalization-to-other-greetings.html", "4 Generalization to other greetings", " 4 Generalization to other greetings We can now get fancier and define more functions across as many .Rmd files as we like. Hyperlinks work across different .Rmd files. For example, you can click on say_hello() and it will bring you to the definition in the previous chapter. "],["conclude.html", "5 Conclusion", " 5 Conclusion When you are done defining the package, it remains to convert the Roxygen to documentation. say_hello(&quot;Jacob&quot;) ## ‚Ñπ Updating frombookdown documentation ## ‚Ñπ Loading frombookdown ## Warning: []8;line = 16:col = 1;file:///Users/cynthiahqy/Dropbox/WORK/RA_2022/ ## conformr/frombookdown/R/make_pm_equal.Rmake_pm_equal.R:16]8;;] @examples ## requires a value ## Warning: []8;line = 4:col = 1;file:///Users/cynthiahqy/Dropbox/WORK/RA_2022/conformr/frombookdown/R/`%||%`.R`%||%`.R:4]8;;] Block must have a @name ## ‚Ñπ Either document an existing object or manually specify with @name ## Writing &#39;]8;;file:///Users/cynthiahqy/Dropbox/WORK/RA_2022/conformr/frombookdown/NAMESPACENAMESPACE]8;;&#39; ## Writing &#39;]8;;ide:run:pkgload::dev_help(&#39;frombookdown-package&#39;)frombookdown-package.Rd]8;;&#39; ## Writing &#39;]8;;ide:run:pkgload::dev_help(&#39;make_pm_equal&#39;)make_pm_equal.Rd]8;;&#39; ## Writing &#39;]8;;ide:run:pkgload::dev_help(&#39;say_hello&#39;)say_hello.Rd]8;;&#39; You can also add some extra things to your package here if you like, such as a README, some vignettes, a pkgdown site, etc. See here for an example of how to do this with litr. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

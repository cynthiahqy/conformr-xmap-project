# Functions

## Inbox

IDEAL CASE

- [x] code_dict: cover all mapping types
- [x] data_in: include case variable (country)
- [x] group_in: data_in grouped by case
- [x] multiple values

BREAKING CASES for tests

- [x] data_in: include BAD non-numeric value column
- [x] code_dict: include BAD weights -- sum > 1
- [x] code_dict: include BAD weights -- sum < 1?
- [>] code_dict: remove mapping for one origin code in TEST
- [>] code_dict: include duplicate mapping in TEST

## Basic Panel Map

### Concepts

In the most simple case, to make a panel map, we need only a correspondence between a source nomenclature (`std_A`) and target nomenclature (`std_B`), which doesn't have any duplicate rows.

```{r manual-pm-equal}
## correspondence/concordance table
codes_BA <- dplyr::tribble(~ std_B, ~ std_A,
                                "A1", "x1111", # one-to-one
                                "B2", "x2222", # many-to-one
                                "B2", "x3333",
                                "C3", "x4444", # one-to-many (4)
                                "C4", "x4444",
                                "C4", "x6666", # many-to-many
                                "C5", "x4444",
                                "C6", "x4444",
                                "C7", "x5555", # one-to-many (3)
                                "C8", "x5555",
                           )

## panel_map
weights_BA <- codes_BA |>
  dplyr::distinct(std_B, std_A) |>
  dplyr::group_by(std_A) |>
  dplyr::mutate(n_dest = dplyr::n(),
                weight = 1 / n_dest) |>
  dplyr::ungroup()

pm_BA <- weights_BA |>
  dplyr::select(std_B, std_A, weight)
```

Write this data into the package for testing purposes.
```{r internal-toy-AB, echo=TRUE}
equal_pm <- list("codes_BA" = codes_BA,
                 "weights_BA" = weights_BA,
                 "pm_BA" = pm_BA)

usethis::use_data(equal_pm, internal = TRUE, overwrite = TRUE)
```

We can visualise a panel map as the addition of weights to the concordance:
```{r viz-matrix-pm-equal}
library(ggplot2)

inc_long <- tidyr::expand(codes_BA, std_A, std_B) |>
  dplyr::left_join(pm_BA, by = c("std_A", "std_B")) |>
  dplyr::transmute(to = std_B, from = std_A, weight = weight)

gg_inc_mtx <- inc_long |>
  dplyr::mutate(src_case = dplyr::case_when(weight==1 ~ "one-to-one",
                                     is.na(weight) ~ "none",
                                     weight < 1 ~ "one-to-many")) |>
  ggplot(aes(x=to, y=from)) +
  geom_tile(aes(fill=src_case), col="grey") +
  scale_y_discrete(limits=rev) +
  scale_fill_brewer() +
  coord_fixed()  +
  labs(x = element_blank(), y = element_blank(), fill="source-to-target") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Concordance as Incidence Matrix")

gg_pm_mtx <- gg_inc_mtx + 
  geom_text(data = dplyr::filter(inc_long, !is.na(weight)), aes(label=round(weight, 2))) +
  ggtitle("adding equal weights for Valid Panel Map")
```

::::{style="display: flex;"}
:::{}
```{r gg-no-weight-martix}
gg_inc_mtx
```
:::

:::{}
```{r gg-equal-weight-matrix}
gg_pm_mtx
```
:::

::::


### Helper Function for equal Mapping Weights

#### Definition

This is a helper function for making a valid Panel Map with equal Mapping Weights from a concordance table.

```{r}
#' Helper to build equal split panel map
#'
#' Generate panel map using all *distinct* correspondences between two classifications.
#'
#' @param code_dict Data frame containing correspondence between source and destination codes
#' @param code_in Variable in `code_dict` containing source codes to convert from.
#' @param code_out Variable in `code_dict` containing destination codes to convert to.
#' @param .weights_to (optional) new column name for storing weights that will be applied to. The default name is `split_<<code_in>>`.
#' input values.
#'
#' @return Returns panel map as tibble
#' @export
#'
#' @examples
make_pm_equal <- function(code_dict, code_in, code_out, .weights_to = NULL){
  ## check and remove for duplicates
  n_dups <- sum(duplicated(code_dict))
  no_dup_links <- n_dups == 0
  if (!no_dup_links) {
    message("Removing duplicate code_in/code_out rows")
    code_dict <- code_dict |>
    dplyr::distinct({{code_in}}, {{code_out}})
  }

  ## make column name for weights
  .weights_to <- .weights_to %||% paste("split", deparse(substitute(code_in)), sep = "_")

  ## make panel map
  panel_map <- code_dict |>
    dplyr::group_by({{code_in}}) |>
    dplyr::mutate(n_dest = dplyr::n(),
                  !!.weights_to := 1 / n_dest) |>
    dplyr::ungroup() |>
    dplyr::select(-n_dest)

  return(panel_map)
}
```

Use this helper on the concordance table defined above:
```{r use-make-pm-equal}
make_pm_equal(codes_BA, std_A, std_B, "weights")
```
#### Conditionals

This function uses the `no_dup_links` flag to removes any duplicate instructions/links, to avoid assigning unequal shares to each target code/category (shown as `naive_share`):

```{r no-dup-links, message=FALSE}
library(dplyr)
codes <- tribble(~code_in, ~code_out,
                 "cake", "piece_01",
                 "cake", "piece_02",
                 "cake", "piece_03",
                 "cake", "piece_03" ## duplicated row
                 )

codes |>
  ## equal share by code_out
  mutate(equal_share = 1 / n_distinct(code_out)) |>
  ## without duplicates removed
  group_by(code_in) |>
  mutate("n_dest" = n(),
         weight := 1 / n_dest) |>
  ungroup() |>
  select(-n_dest) |>
  group_by(code_out) |>
  summarise(
    weights = paste(weight, collapse = "+"),
    naive_share = sum(weight),
    equal_share = unique(equal_share)
)
```

#### Tests
```{r test-make-pm-equal}
testthat::test_that(
  "make_pm_equal() works",
  {
    testthat::expect_identical(
      make_pm_equal(equal_pm$codes_BA, std_A, std_B, .weights_to = "weight"), equal_pm$pm_BA)
    testthat::expect_no_message(
      make_pm_equal(equal_pm$codes_BA, std_A, std_B, .weights_to = "weight"))
  }
)
testthat::test_that(
  "make_pm_equal() handles duplicate link correctly",
  {
    dup_codes_BA <- rbind(equal_pm$codes_BA, equal_pm$codes_BA[1, ])
    testthat::expect_message(
      make_pm_equal(dup_codes_BA, std_A, std_B)
    )
    testthat::expect_identical(
      make_pm_equal(dup_codes_BA, std_A, std_B, .weights_to = "weight"), equal_pm$pm_BA
    )
  }
)
```

## Valid Panel Maps

### Concepts

A valid panel map is an mapping from source to target nomenclatures which when applied to suitably dimensioned source data, transforms that data into the target nomenclature without creation or loss of value (beyond floating point rounding). This can also be thought of as a condition whereby the sum total of a variable remains the same before and after the transformation.

The following condition is necessary and sufficient for a set of Source Codes, Target Codes and Mapping Weights to be a valid panel map:

> The sum of all Mapping Weights associated with any given Source Code totals to 1

To demonstrate, let us generate some source data:
```{r}
## generate some data
set.seed(1832)
std_A_codes <- unique(codes_BA$std_A)
(data_in <- 
    dplyr::tibble(std_A = std_A_codes,
                  A_100   = 100,
                  A_prod  = round(abs(rnorm(length(std_A_codes)) * 10000),2)
                  )
  )
```
Now let's switch to using the matrix representation of panel maps:
```{r fnc-pm-to-mtx}
inc_long_to_mtx <- function(inc_long, to, weights){
  inc_wide <- inc_long |>
    tidyr::pivot_wider(names_from = {{to}}, values_from = {{weights}})
  
  inc_mtx <- as.matrix(inc_wide[,-1])
  dimnames(inc_mtx)[[1]] <- inc_wide[,1, drop=TRUE]
  
  return(inc_mtx)
}
```

Let $\bf{C}$ be a $n \times m$ matrix showing the incidence between two disjoint sets (`inc_mtx`), and let $\bf{X}$ be the source variables (`x_mtx`) requiring transformation. Then, the transformed data is $\bf{Z} = \bf{C'X}$:

```{r pm-to-mtx}
## incidence matrix
inc_mtx <- inc_long |>
  tidyr::replace_na(list(weight=0)) |>
  inc_long_to_mtx(to, weight)

## source data matrix
x_mtx <- as.matrix(data_in[,-1])
dimnames(x_mtx)[[1]] <- std_A_codes

## transformed data
z_mtx <- t(inc_mtx) %*% x_mtx
```
::::{style="display: flex;"}
:::{}
```{r print-inc-mtx}
round(t(inc_mtx), 2)
```
:::

:::{}
```{r print-data-in-mtx}
print(x_mtx)
```
:::
::::

```{r print-data-out-mtx}
print(z_mtx)
```

Notice that the sum total of `A_100` is the same before and after the transformation.

::::{style="display: flex;"}
:::{}
```{r}
colSums(x_mtx)
```
:::

:::{}
```{r}
colSums(z_mtx)
```
:::
::::

Now, let's edit the panel map such that the weights no longer sum to one:

```{r bad-weights-pm}
## edit weights
bad_pm <- pm_BA |> 
  dplyr::mutate(weight = dplyr::case_when(
                           weight == 1 ~ weight,
                           weight < 0.5 ~ weight - 0.03,
                           weight >= 0.5 ~ weight + 0.01,
                           T ~ weight))

## incidence matrix
bad_mtx <- bad_pm |>
  inc_long_to_mtx(std_B, weight)
bad_mtx[is.na(bad_mtx)] <- 0

## transform data badly
bad_z <- t(bad_mtx) %*% x_mtx
```

Notice what happens when we apply the transformation:

::::{style="display: flex;"}
:::{}
```{r print-bad-mtx}
round(t(bad_mtx), 2)
```
:::

:::{}
```{r print-bad-data-in}
print(x_mtx)
```
:::
::::

```{r print-bad-data-out}
print(bad_z)
```

Notice that the sum totals are no longer the same before and after the transformation:

::::{style="display: flex;"}
:::{}
```{r}
colSums(x_mtx)
```
:::

:::{}
```{r}
colSums(bad_z)
```
:::
::::

Hence, the validity condition can also be expressed as follows:
> A given incidence matrix $\bf{K}$ with dimensions $n \times m$ is a valid panel map if and only if $\bf{K}\boldsymbol{1} = \boldsymbol{1}$ where $\boldsymbol{1}$ is a unit vector of length $m$:

```{r valid-weights-mtx}
ones <- rep_len(1, ncol(inc_mtx))
```

::::{style="display: flex;"}
:::{}
```{r}
round(inc_mtx, 2)
```
:::

:::{}
```{r}
inc_mtx %*% ones
```
:::
::::

### Checking Function

#### Definition
```{r weight-fncs}
#' Flag Bad Mapping Weights
#' 
has_bad_weights <- function(pm, code_in, code_out, weights){
  bad_rows <- pm %>%
    dplyr::group_by({{code_in}}) %>%
    dplyr::summarise(total = sum({{weights}}),
                     weights = paste({{weights}}, collapse=",")) %>%
    dplyr::filter(total != 1)
  
  is_bad <- !(nrow(bad_rows) == 0)
  
  result <- list(bool = is_bad,
                 table = bad_rows)
  return(result)
}

#' Check panel map weights are valid
#' 
#' for use in pipes
#' 
#' @param pm Data Frame containing weighted links `weights` between `code_in` and `code_out`.
#' @inherit make_pm_equal
#' @param weights Column containing weights for transforming values from `code_in` to `code_out`
#'
#' @exports 
#' 
#' @returns 
check_pm_weights <- function(pm, code_in, code_out, weights){
  
  has_result <- has_bad_weights(pm, {{code_in}}, {{code_out}}, {{weights}})
  
  if (!has_result$bool){
    return(pm)
  } else {
    # TODO: add informative error message
    return(has_result$table)
  }
}
```

#### Tests

- flag function returns expected output
- check function works as expected:
  - returns informative error message
  - returns unchanged panel map

```r
testthat::testthat(
  "has_bad_weights returns expected lists",
  {
    
  }
)
```


## Valid Transformations

### Concepts


## Other
### Single Source Variable

In the most simple case, we have one source variable which we are trying to apply the concordance to.

```{r single-data-in}


```


### Basic Panel Map, Multiple Source Variables
data_in <- tidyr::expand_grid(country = c("AUS", "JPN"),
                   std_A = code_in) %>%
  dplyr::mutate(A_100 = 100,
                A_prod = abs(rnorm(nrow(.))) * 10000) %>%
  dplyr::mutate(value_str = stringi::stri_rand_strings(nrow(.), 5)) ## bad value!)



## generate code_dict with weights
eps <- 0.001 # small "dust" to mess up weights

weights_BA <- codes_BA %>%
    dplyr::group_by(std_A) %>%
    dplyr::mutate(n_dest = dplyr::n_distinct(std_B),
                  weight = 1 / n_dest) %>%
    dplyr::ungroup() %>%
  # add bad weights
    dplyr::mutate(weight_more = dplyr::case_when(weight == 1 ~ weight,
                                         TRUE ~ weight + eps),
                  weight_less = dplyr::case_when(n_dest == 3 ~ 0.33,
                                          n_dest == 4 ~ 0.2,
                                          TRUE ~ weight)
                  )

## generate panel_map_BA

panel_map <- weights_BA %>%
  select(std_B, std_A, weight)


## generate data_map
data_map_BA <- dplyr::left_join(data_in, weights_BA, by = "std_A")

## final data // collapse destination codes with multiple transfers
data_AB_out <- data_map_BA %>%
  dplyr::group_by(country) %>%
  dplyr::mutate(across(starts_with("A_"), ~ .x * weight)) %>%
  dplyr::group_by(std_B, .add = TRUE) %>%
  dplyr::summarise(dplyr::across(starts_with("A_"), ~ sum(.x), .names = "{.col}_out"),
                   .groups = "drop_last")

toy_AB <- list("data_in" = data_in,
                "codes_BA" = codes_BA,
                "weights_BA" = weights_BA,
               "pm_BA" = panel_map,
                "data_map" = data_map_BA,
                "data_out" = data_AB_out)
